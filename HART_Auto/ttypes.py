#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class License(object):
    HAPI_LICENSE_NONE = 0
    HAPI_LICENSE_HOUDINI_ENGINE = 1
    HAPI_LICENSE_HOUDINI = 2
    HAPI_LICENSE_HOUDINI_FX = 3
    HAPI_LICENSE_HOUDINI_ENGINE_INDIE = 4
    HAPI_LICENSE_HOUDINI_INDIE = 5
    HAPI_LICENSE_MAX = 6

    _VALUES_TO_NAMES = {
        0: "HAPI_LICENSE_NONE",
        1: "HAPI_LICENSE_HOUDINI_ENGINE",
        2: "HAPI_LICENSE_HOUDINI",
        3: "HAPI_LICENSE_HOUDINI_FX",
        4: "HAPI_LICENSE_HOUDINI_ENGINE_INDIE",
        5: "HAPI_LICENSE_HOUDINI_INDIE",
        6: "HAPI_LICENSE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_LICENSE_NONE": 0,
        "HAPI_LICENSE_HOUDINI_ENGINE": 1,
        "HAPI_LICENSE_HOUDINI": 2,
        "HAPI_LICENSE_HOUDINI_FX": 3,
        "HAPI_LICENSE_HOUDINI_ENGINE_INDIE": 4,
        "HAPI_LICENSE_HOUDINI_INDIE": 5,
        "HAPI_LICENSE_MAX": 6,
    }


class StatusType(object):
    HAPI_STATUS_CALL_RESULT = 0
    HAPI_STATUS_COOK_RESULT = 1
    HAPI_STATUS_COOK_STATE = 2
    HAPI_STATUS_MAX = 3

    _VALUES_TO_NAMES = {
        0: "HAPI_STATUS_CALL_RESULT",
        1: "HAPI_STATUS_COOK_RESULT",
        2: "HAPI_STATUS_COOK_STATE",
        3: "HAPI_STATUS_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_STATUS_CALL_RESULT": 0,
        "HAPI_STATUS_COOK_RESULT": 1,
        "HAPI_STATUS_COOK_STATE": 2,
        "HAPI_STATUS_MAX": 3,
    }


class StatusVerbosity(object):
    HAPI_STATUSVERBOSITY_0 = 0
    HAPI_STATUSVERBOSITY_1 = 1
    HAPI_STATUSVERBOSITY_2 = 2
    HAPI_STATUSVERBOSITY_ALL = 2
    HAPI_STATUSVERBOSITY_ERRORS = 0
    HAPI_STATUSVERBOSITY_WARNINGS = 1
    HAPI_STATUSVERBOSITY_MESSAGES = 2

    _VALUES_TO_NAMES = {
        0: "HAPI_STATUSVERBOSITY_0",
        1: "HAPI_STATUSVERBOSITY_1",
        2: "HAPI_STATUSVERBOSITY_2",
        2: "HAPI_STATUSVERBOSITY_ALL",
        0: "HAPI_STATUSVERBOSITY_ERRORS",
        1: "HAPI_STATUSVERBOSITY_WARNINGS",
        2: "HAPI_STATUSVERBOSITY_MESSAGES",
    }

    _NAMES_TO_VALUES = {
        "HAPI_STATUSVERBOSITY_0": 0,
        "HAPI_STATUSVERBOSITY_1": 1,
        "HAPI_STATUSVERBOSITY_2": 2,
        "HAPI_STATUSVERBOSITY_ALL": 2,
        "HAPI_STATUSVERBOSITY_ERRORS": 0,
        "HAPI_STATUSVERBOSITY_WARNINGS": 1,
        "HAPI_STATUSVERBOSITY_MESSAGES": 2,
    }


class Result(object):
    HAPI_RESULT_SUCCESS = 0
    HAPI_RESULT_FAILURE = 1
    HAPI_RESULT_ALREADY_INITIALIZED = 2
    HAPI_RESULT_NOT_INITIALIZED = 3
    HAPI_RESULT_CANT_LOADFILE = 4
    HAPI_RESULT_PARM_SET_FAILED = 5
    HAPI_RESULT_INVALID_ARGUMENT = 6
    HAPI_RESULT_CANT_LOAD_GEO = 7
    HAPI_RESULT_CANT_GENERATE_PRESET = 8
    HAPI_RESULT_CANT_LOAD_PRESET = 9
    HAPI_RESULT_ASSET_DEF_ALREADY_LOADED = 10
    HAPI_RESULT_NO_LICENSE_FOUND = 110
    HAPI_RESULT_DISALLOWED_NC_LICENSE_FOUND = 120
    HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_C_LICENSE = 130
    HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_LC_LICENSE = 140
    HAPI_RESULT_DISALLOWED_LC_ASSET_WITH_C_LICENSE = 150
    HAPI_RESULT_DISALLOWED_HENGINEINDIE_W_3PARTY_PLUGIN = 160
    HAPI_RESULT_ASSET_INVALID = 200
    HAPI_RESULT_NODE_INVALID = 210
    HAPI_RESULT_USER_INTERRUPTED = 300
    HAPI_RESULT_INVALID_SESSION = 400

    _VALUES_TO_NAMES = {
        0: "HAPI_RESULT_SUCCESS",
        1: "HAPI_RESULT_FAILURE",
        2: "HAPI_RESULT_ALREADY_INITIALIZED",
        3: "HAPI_RESULT_NOT_INITIALIZED",
        4: "HAPI_RESULT_CANT_LOADFILE",
        5: "HAPI_RESULT_PARM_SET_FAILED",
        6: "HAPI_RESULT_INVALID_ARGUMENT",
        7: "HAPI_RESULT_CANT_LOAD_GEO",
        8: "HAPI_RESULT_CANT_GENERATE_PRESET",
        9: "HAPI_RESULT_CANT_LOAD_PRESET",
        10: "HAPI_RESULT_ASSET_DEF_ALREADY_LOADED",
        110: "HAPI_RESULT_NO_LICENSE_FOUND",
        120: "HAPI_RESULT_DISALLOWED_NC_LICENSE_FOUND",
        130: "HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_C_LICENSE",
        140: "HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_LC_LICENSE",
        150: "HAPI_RESULT_DISALLOWED_LC_ASSET_WITH_C_LICENSE",
        160: "HAPI_RESULT_DISALLOWED_HENGINEINDIE_W_3PARTY_PLUGIN",
        200: "HAPI_RESULT_ASSET_INVALID",
        210: "HAPI_RESULT_NODE_INVALID",
        300: "HAPI_RESULT_USER_INTERRUPTED",
        400: "HAPI_RESULT_INVALID_SESSION",
    }

    _NAMES_TO_VALUES = {
        "HAPI_RESULT_SUCCESS": 0,
        "HAPI_RESULT_FAILURE": 1,
        "HAPI_RESULT_ALREADY_INITIALIZED": 2,
        "HAPI_RESULT_NOT_INITIALIZED": 3,
        "HAPI_RESULT_CANT_LOADFILE": 4,
        "HAPI_RESULT_PARM_SET_FAILED": 5,
        "HAPI_RESULT_INVALID_ARGUMENT": 6,
        "HAPI_RESULT_CANT_LOAD_GEO": 7,
        "HAPI_RESULT_CANT_GENERATE_PRESET": 8,
        "HAPI_RESULT_CANT_LOAD_PRESET": 9,
        "HAPI_RESULT_ASSET_DEF_ALREADY_LOADED": 10,
        "HAPI_RESULT_NO_LICENSE_FOUND": 110,
        "HAPI_RESULT_DISALLOWED_NC_LICENSE_FOUND": 120,
        "HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_C_LICENSE": 130,
        "HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_LC_LICENSE": 140,
        "HAPI_RESULT_DISALLOWED_LC_ASSET_WITH_C_LICENSE": 150,
        "HAPI_RESULT_DISALLOWED_HENGINEINDIE_W_3PARTY_PLUGIN": 160,
        "HAPI_RESULT_ASSET_INVALID": 200,
        "HAPI_RESULT_NODE_INVALID": 210,
        "HAPI_RESULT_USER_INTERRUPTED": 300,
        "HAPI_RESULT_INVALID_SESSION": 400,
    }


class ErrorCode(object):
    HAPI_ERRORCODE_ASSET_DEF_NOT_FOUND = 1
    HAPI_ERRORCODE_PYTHON_NODE_ERROR = 2

    _VALUES_TO_NAMES = {
        1: "HAPI_ERRORCODE_ASSET_DEF_NOT_FOUND",
        2: "HAPI_ERRORCODE_PYTHON_NODE_ERROR",
    }

    _NAMES_TO_VALUES = {
        "HAPI_ERRORCODE_ASSET_DEF_NOT_FOUND": 1,
        "HAPI_ERRORCODE_PYTHON_NODE_ERROR": 2,
    }


class SessionType(object):
    HAPI_SESSION_INPROCESS = 0
    HAPI_SESSION_THRIFT = 1
    HAPI_SESSION_CUSTOM1 = 2
    HAPI_SESSION_CUSTOM2 = 3
    HAPI_SESSION_CUSTOM3 = 4
    HAPI_SESSION_MAX = 5

    _VALUES_TO_NAMES = {
        0: "HAPI_SESSION_INPROCESS",
        1: "HAPI_SESSION_THRIFT",
        2: "HAPI_SESSION_CUSTOM1",
        3: "HAPI_SESSION_CUSTOM2",
        4: "HAPI_SESSION_CUSTOM3",
        5: "HAPI_SESSION_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_SESSION_INPROCESS": 0,
        "HAPI_SESSION_THRIFT": 1,
        "HAPI_SESSION_CUSTOM1": 2,
        "HAPI_SESSION_CUSTOM2": 3,
        "HAPI_SESSION_CUSTOM3": 4,
        "HAPI_SESSION_MAX": 5,
    }


class State(object):
    HAPI_STATE_READY = 0
    HAPI_STATE_READY_WITH_FATAL_ERRORS = 1
    HAPI_STATE_READY_WITH_COOK_ERRORS = 2
    HAPI_STATE_STARTING_COOK = 3
    HAPI_STATE_COOKING = 4
    HAPI_STATE_STARTING_LOAD = 5
    HAPI_STATE_LOADING = 6
    HAPI_STATE_MAX = 7
    HAPI_STATE_MAX_READY_STATE = 2

    _VALUES_TO_NAMES = {
        0: "HAPI_STATE_READY",
        1: "HAPI_STATE_READY_WITH_FATAL_ERRORS",
        2: "HAPI_STATE_READY_WITH_COOK_ERRORS",
        3: "HAPI_STATE_STARTING_COOK",
        4: "HAPI_STATE_COOKING",
        5: "HAPI_STATE_STARTING_LOAD",
        6: "HAPI_STATE_LOADING",
        7: "HAPI_STATE_MAX",
        2: "HAPI_STATE_MAX_READY_STATE",
    }

    _NAMES_TO_VALUES = {
        "HAPI_STATE_READY": 0,
        "HAPI_STATE_READY_WITH_FATAL_ERRORS": 1,
        "HAPI_STATE_READY_WITH_COOK_ERRORS": 2,
        "HAPI_STATE_STARTING_COOK": 3,
        "HAPI_STATE_COOKING": 4,
        "HAPI_STATE_STARTING_LOAD": 5,
        "HAPI_STATE_LOADING": 6,
        "HAPI_STATE_MAX": 7,
        "HAPI_STATE_MAX_READY_STATE": 2,
    }


class PackedPrimInstancingMode(object):
    HAPI_PACKEDPRIM_INSTANCING_MODE_INVALID = -1
    HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED = 0
    HAPI_PACKEDPRIM_INSTANCING_MODE_HIERARCHY = 1
    HAPI_PACKEDPRIM_INSTANCING_MODE_FLAT = 2
    HAPI_PACKEDPRIM_INSTANCING_MODE_MAX = 3

    _VALUES_TO_NAMES = {
        -1: "HAPI_PACKEDPRIM_INSTANCING_MODE_INVALID",
        0: "HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED",
        1: "HAPI_PACKEDPRIM_INSTANCING_MODE_HIERARCHY",
        2: "HAPI_PACKEDPRIM_INSTANCING_MODE_FLAT",
        3: "HAPI_PACKEDPRIM_INSTANCING_MODE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PACKEDPRIM_INSTANCING_MODE_INVALID": -1,
        "HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED": 0,
        "HAPI_PACKEDPRIM_INSTANCING_MODE_HIERARCHY": 1,
        "HAPI_PACKEDPRIM_INSTANCING_MODE_FLAT": 2,
        "HAPI_PACKEDPRIM_INSTANCING_MODE_MAX": 3,
    }


class Permissions(object):
    HAPI_PERMISSIONS_NON_APPLICABLE = 0
    HAPI_PERMISSIONS_READ_WRITE = 1
    HAPI_PERMISSIONS_READ_ONLY = 2
    HAPI_PERMISSIONS_WRITE_ONLY = 3
    HAPI_PERMISSIONS_MAX = 4

    _VALUES_TO_NAMES = {
        0: "HAPI_PERMISSIONS_NON_APPLICABLE",
        1: "HAPI_PERMISSIONS_READ_WRITE",
        2: "HAPI_PERMISSIONS_READ_ONLY",
        3: "HAPI_PERMISSIONS_WRITE_ONLY",
        4: "HAPI_PERMISSIONS_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PERMISSIONS_NON_APPLICABLE": 0,
        "HAPI_PERMISSIONS_READ_WRITE": 1,
        "HAPI_PERMISSIONS_READ_ONLY": 2,
        "HAPI_PERMISSIONS_WRITE_ONLY": 3,
        "HAPI_PERMISSIONS_MAX": 4,
    }


class RampType(object):
    HAPI_RAMPTYPE_INVALID = -1
    HAPI_RAMPTYPE_FLOAT = 0
    HAPI_RAMPTYPE_COLOR = 1
    HAPI_RAMPTYPE_MAX = 2

    _VALUES_TO_NAMES = {
        -1: "HAPI_RAMPTYPE_INVALID",
        0: "HAPI_RAMPTYPE_FLOAT",
        1: "HAPI_RAMPTYPE_COLOR",
        2: "HAPI_RAMPTYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_RAMPTYPE_INVALID": -1,
        "HAPI_RAMPTYPE_FLOAT": 0,
        "HAPI_RAMPTYPE_COLOR": 1,
        "HAPI_RAMPTYPE_MAX": 2,
    }


class ParmType(object):
    HAPI_PARMTYPE_INT = 0
    HAPI_PARMTYPE_MULTIPARMLIST = 1
    HAPI_PARMTYPE_TOGGLE = 2
    HAPI_PARMTYPE_BUTTON = 3
    HAPI_PARMTYPE_FLOAT = 4
    HAPI_PARMTYPE_COLOR = 5
    HAPI_PARMTYPE_STRING = 6
    HAPI_PARMTYPE_PATH_FILE = 7
    HAPI_PARMTYPE_PATH_FILE_GEO = 8
    HAPI_PARMTYPE_PATH_FILE_IMAGE = 9
    HAPI_PARMTYPE_NODE = 10
    HAPI_PARMTYPE_FOLDERLIST = 11
    HAPI_PARMTYPE_FOLDERLIST_RADIO = 12
    HAPI_PARMTYPE_FOLDER = 13
    HAPI_PARMTYPE_LABEL = 14
    HAPI_PARMTYPE_SEPARATOR = 15
    HAPI_PARMTYPE_PATH_FILE_DIR = 16
    HAPI_PARMTYPE_MAX = 17
    HAPI_PARMTYPE_INT_START = 0
    HAPI_PARMTYPE_INT_END = 3
    HAPI_PARMTYPE_FLOAT_START = 4
    HAPI_PARMTYPE_FLOAT_END = 5
    HAPI_PARMTYPE_STRING_START = 6
    HAPI_PARMTYPE_STRING_END = 10
    HAPI_PARMTYPE_PATH_START = 7
    HAPI_PARMTYPE_PATH_END = 9
    HAPI_PARMTYPE_NODE_START = 10
    HAPI_PARMTYPE_NODE_END = 10
    HAPI_PARMTYPE_CONTAINER_START = 11
    HAPI_PARMTYPE_CONTAINER_END = 12
    HAPI_PARMTYPE_NONVALUE_START = 13
    HAPI_PARMTYPE_NONVALUE_END = 15

    _VALUES_TO_NAMES = {
        0: "HAPI_PARMTYPE_INT",
        1: "HAPI_PARMTYPE_MULTIPARMLIST",
        2: "HAPI_PARMTYPE_TOGGLE",
        3: "HAPI_PARMTYPE_BUTTON",
        4: "HAPI_PARMTYPE_FLOAT",
        5: "HAPI_PARMTYPE_COLOR",
        6: "HAPI_PARMTYPE_STRING",
        7: "HAPI_PARMTYPE_PATH_FILE",
        8: "HAPI_PARMTYPE_PATH_FILE_GEO",
        9: "HAPI_PARMTYPE_PATH_FILE_IMAGE",
        10: "HAPI_PARMTYPE_NODE",
        11: "HAPI_PARMTYPE_FOLDERLIST",
        12: "HAPI_PARMTYPE_FOLDERLIST_RADIO",
        13: "HAPI_PARMTYPE_FOLDER",
        14: "HAPI_PARMTYPE_LABEL",
        15: "HAPI_PARMTYPE_SEPARATOR",
        16: "HAPI_PARMTYPE_PATH_FILE_DIR",
        17: "HAPI_PARMTYPE_MAX",
        0: "HAPI_PARMTYPE_INT_START",
        3: "HAPI_PARMTYPE_INT_END",
        4: "HAPI_PARMTYPE_FLOAT_START",
        5: "HAPI_PARMTYPE_FLOAT_END",
        6: "HAPI_PARMTYPE_STRING_START",
        10: "HAPI_PARMTYPE_STRING_END",
        7: "HAPI_PARMTYPE_PATH_START",
        9: "HAPI_PARMTYPE_PATH_END",
        10: "HAPI_PARMTYPE_NODE_START",
        10: "HAPI_PARMTYPE_NODE_END",
        11: "HAPI_PARMTYPE_CONTAINER_START",
        12: "HAPI_PARMTYPE_CONTAINER_END",
        13: "HAPI_PARMTYPE_NONVALUE_START",
        15: "HAPI_PARMTYPE_NONVALUE_END",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PARMTYPE_INT": 0,
        "HAPI_PARMTYPE_MULTIPARMLIST": 1,
        "HAPI_PARMTYPE_TOGGLE": 2,
        "HAPI_PARMTYPE_BUTTON": 3,
        "HAPI_PARMTYPE_FLOAT": 4,
        "HAPI_PARMTYPE_COLOR": 5,
        "HAPI_PARMTYPE_STRING": 6,
        "HAPI_PARMTYPE_PATH_FILE": 7,
        "HAPI_PARMTYPE_PATH_FILE_GEO": 8,
        "HAPI_PARMTYPE_PATH_FILE_IMAGE": 9,
        "HAPI_PARMTYPE_NODE": 10,
        "HAPI_PARMTYPE_FOLDERLIST": 11,
        "HAPI_PARMTYPE_FOLDERLIST_RADIO": 12,
        "HAPI_PARMTYPE_FOLDER": 13,
        "HAPI_PARMTYPE_LABEL": 14,
        "HAPI_PARMTYPE_SEPARATOR": 15,
        "HAPI_PARMTYPE_PATH_FILE_DIR": 16,
        "HAPI_PARMTYPE_MAX": 17,
        "HAPI_PARMTYPE_INT_START": 0,
        "HAPI_PARMTYPE_INT_END": 3,
        "HAPI_PARMTYPE_FLOAT_START": 4,
        "HAPI_PARMTYPE_FLOAT_END": 5,
        "HAPI_PARMTYPE_STRING_START": 6,
        "HAPI_PARMTYPE_STRING_END": 10,
        "HAPI_PARMTYPE_PATH_START": 7,
        "HAPI_PARMTYPE_PATH_END": 9,
        "HAPI_PARMTYPE_NODE_START": 10,
        "HAPI_PARMTYPE_NODE_END": 10,
        "HAPI_PARMTYPE_CONTAINER_START": 11,
        "HAPI_PARMTYPE_CONTAINER_END": 12,
        "HAPI_PARMTYPE_NONVALUE_START": 13,
        "HAPI_PARMTYPE_NONVALUE_END": 15,
    }


class PrmScriptType(object):
    HAPI_PRM_SCRIPT_TYPE_INT = 0
    HAPI_PRM_SCRIPT_TYPE_FLOAT = 1
    HAPI_PRM_SCRIPT_TYPE_ANGLE = 2
    HAPI_PRM_SCRIPT_TYPE_STRING = 3
    HAPI_PRM_SCRIPT_TYPE_FILE = 4
    HAPI_PRM_SCRIPT_TYPE_DIRECTORY = 5
    HAPI_PRM_SCRIPT_TYPE_IMAGE = 6
    HAPI_PRM_SCRIPT_TYPE_GEOMETRY = 7
    HAPI_PRM_SCRIPT_TYPE_TOGGLE = 8
    HAPI_PRM_SCRIPT_TYPE_BUTTON = 9
    HAPI_PRM_SCRIPT_TYPE_VECTOR2 = 10
    HAPI_PRM_SCRIPT_TYPE_VECTOR3 = 11
    HAPI_PRM_SCRIPT_TYPE_VECTOR4 = 12
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR2 = 13
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR3 = 14
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR4 = 15
    HAPI_PRM_SCRIPT_TYPE_UV = 16
    HAPI_PRM_SCRIPT_TYPE_UVW = 17
    HAPI_PRM_SCRIPT_TYPE_DIR = 18
    HAPI_PRM_SCRIPT_TYPE_COLOR = 19
    HAPI_PRM_SCRIPT_TYPE_COLOR4 = 20
    HAPI_PRM_SCRIPT_TYPE_OPPATH = 21
    HAPI_PRM_SCRIPT_TYPE_OPLIST = 22
    HAPI_PRM_SCRIPT_TYPE_OBJECT = 23
    HAPI_PRM_SCRIPT_TYPE_OBJECTLIST = 24
    HAPI_PRM_SCRIPT_TYPE_RENDER = 25
    HAPI_PRM_SCRIPT_TYPE_SEPARATOR = 26
    HAPI_PRM_SCRIPT_TYPE_GEOMETRY_DATA = 27
    HAPI_PRM_SCRIPT_TYPE_KEY_VALUE_DICT = 28
    HAPI_PRM_SCRIPT_TYPE_LABEL = 29
    HAPI_PRM_SCRIPT_TYPE_RGBAMASK = 30
    HAPI_PRM_SCRIPT_TYPE_ORDINAL = 31
    HAPI_PRM_SCRIPT_TYPE_RAMP_FLT = 32
    HAPI_PRM_SCRIPT_TYPE_RAMP_RGB = 33
    HAPI_PRM_SCRIPT_TYPE_FLOAT_LOG = 34
    HAPI_PRM_SCRIPT_TYPE_INT_LOG = 35
    HAPI_PRM_SCRIPT_TYPE_DATA = 36
    HAPI_PRM_SCRIPT_TYPE_FLOAT_MINMAX = 37
    HAPI_PRM_SCRIPT_TYPE_INT_MINMAX = 38
    HAPI_PRM_SCRIPT_TYPE_INT_STARTEND = 39
    HAPI_PRM_SCRIPT_TYPE_BUTTONSTRIP = 40
    HAPI_PRM_SCRIPT_TYPE_ICONSTRIP = 41
    HAPI_PRM_SCRIPT_TYPE_GROUPRADIO = 1000
    HAPI_PRM_SCRIPT_TYPE_GROUPCOLLAPSIBLE = 1001
    HAPI_PRM_SCRIPT_TYPE_GROUPSIMPLE = 1002
    HAPI_PRM_SCRIPT_TYPE_GROUP = 1003

    _VALUES_TO_NAMES = {
        0: "HAPI_PRM_SCRIPT_TYPE_INT",
        1: "HAPI_PRM_SCRIPT_TYPE_FLOAT",
        2: "HAPI_PRM_SCRIPT_TYPE_ANGLE",
        3: "HAPI_PRM_SCRIPT_TYPE_STRING",
        4: "HAPI_PRM_SCRIPT_TYPE_FILE",
        5: "HAPI_PRM_SCRIPT_TYPE_DIRECTORY",
        6: "HAPI_PRM_SCRIPT_TYPE_IMAGE",
        7: "HAPI_PRM_SCRIPT_TYPE_GEOMETRY",
        8: "HAPI_PRM_SCRIPT_TYPE_TOGGLE",
        9: "HAPI_PRM_SCRIPT_TYPE_BUTTON",
        10: "HAPI_PRM_SCRIPT_TYPE_VECTOR2",
        11: "HAPI_PRM_SCRIPT_TYPE_VECTOR3",
        12: "HAPI_PRM_SCRIPT_TYPE_VECTOR4",
        13: "HAPI_PRM_SCRIPT_TYPE_INTVECTOR2",
        14: "HAPI_PRM_SCRIPT_TYPE_INTVECTOR3",
        15: "HAPI_PRM_SCRIPT_TYPE_INTVECTOR4",
        16: "HAPI_PRM_SCRIPT_TYPE_UV",
        17: "HAPI_PRM_SCRIPT_TYPE_UVW",
        18: "HAPI_PRM_SCRIPT_TYPE_DIR",
        19: "HAPI_PRM_SCRIPT_TYPE_COLOR",
        20: "HAPI_PRM_SCRIPT_TYPE_COLOR4",
        21: "HAPI_PRM_SCRIPT_TYPE_OPPATH",
        22: "HAPI_PRM_SCRIPT_TYPE_OPLIST",
        23: "HAPI_PRM_SCRIPT_TYPE_OBJECT",
        24: "HAPI_PRM_SCRIPT_TYPE_OBJECTLIST",
        25: "HAPI_PRM_SCRIPT_TYPE_RENDER",
        26: "HAPI_PRM_SCRIPT_TYPE_SEPARATOR",
        27: "HAPI_PRM_SCRIPT_TYPE_GEOMETRY_DATA",
        28: "HAPI_PRM_SCRIPT_TYPE_KEY_VALUE_DICT",
        29: "HAPI_PRM_SCRIPT_TYPE_LABEL",
        30: "HAPI_PRM_SCRIPT_TYPE_RGBAMASK",
        31: "HAPI_PRM_SCRIPT_TYPE_ORDINAL",
        32: "HAPI_PRM_SCRIPT_TYPE_RAMP_FLT",
        33: "HAPI_PRM_SCRIPT_TYPE_RAMP_RGB",
        34: "HAPI_PRM_SCRIPT_TYPE_FLOAT_LOG",
        35: "HAPI_PRM_SCRIPT_TYPE_INT_LOG",
        36: "HAPI_PRM_SCRIPT_TYPE_DATA",
        37: "HAPI_PRM_SCRIPT_TYPE_FLOAT_MINMAX",
        38: "HAPI_PRM_SCRIPT_TYPE_INT_MINMAX",
        39: "HAPI_PRM_SCRIPT_TYPE_INT_STARTEND",
        40: "HAPI_PRM_SCRIPT_TYPE_BUTTONSTRIP",
        41: "HAPI_PRM_SCRIPT_TYPE_ICONSTRIP",
        1000: "HAPI_PRM_SCRIPT_TYPE_GROUPRADIO",
        1001: "HAPI_PRM_SCRIPT_TYPE_GROUPCOLLAPSIBLE",
        1002: "HAPI_PRM_SCRIPT_TYPE_GROUPSIMPLE",
        1003: "HAPI_PRM_SCRIPT_TYPE_GROUP",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PRM_SCRIPT_TYPE_INT": 0,
        "HAPI_PRM_SCRIPT_TYPE_FLOAT": 1,
        "HAPI_PRM_SCRIPT_TYPE_ANGLE": 2,
        "HAPI_PRM_SCRIPT_TYPE_STRING": 3,
        "HAPI_PRM_SCRIPT_TYPE_FILE": 4,
        "HAPI_PRM_SCRIPT_TYPE_DIRECTORY": 5,
        "HAPI_PRM_SCRIPT_TYPE_IMAGE": 6,
        "HAPI_PRM_SCRIPT_TYPE_GEOMETRY": 7,
        "HAPI_PRM_SCRIPT_TYPE_TOGGLE": 8,
        "HAPI_PRM_SCRIPT_TYPE_BUTTON": 9,
        "HAPI_PRM_SCRIPT_TYPE_VECTOR2": 10,
        "HAPI_PRM_SCRIPT_TYPE_VECTOR3": 11,
        "HAPI_PRM_SCRIPT_TYPE_VECTOR4": 12,
        "HAPI_PRM_SCRIPT_TYPE_INTVECTOR2": 13,
        "HAPI_PRM_SCRIPT_TYPE_INTVECTOR3": 14,
        "HAPI_PRM_SCRIPT_TYPE_INTVECTOR4": 15,
        "HAPI_PRM_SCRIPT_TYPE_UV": 16,
        "HAPI_PRM_SCRIPT_TYPE_UVW": 17,
        "HAPI_PRM_SCRIPT_TYPE_DIR": 18,
        "HAPI_PRM_SCRIPT_TYPE_COLOR": 19,
        "HAPI_PRM_SCRIPT_TYPE_COLOR4": 20,
        "HAPI_PRM_SCRIPT_TYPE_OPPATH": 21,
        "HAPI_PRM_SCRIPT_TYPE_OPLIST": 22,
        "HAPI_PRM_SCRIPT_TYPE_OBJECT": 23,
        "HAPI_PRM_SCRIPT_TYPE_OBJECTLIST": 24,
        "HAPI_PRM_SCRIPT_TYPE_RENDER": 25,
        "HAPI_PRM_SCRIPT_TYPE_SEPARATOR": 26,
        "HAPI_PRM_SCRIPT_TYPE_GEOMETRY_DATA": 27,
        "HAPI_PRM_SCRIPT_TYPE_KEY_VALUE_DICT": 28,
        "HAPI_PRM_SCRIPT_TYPE_LABEL": 29,
        "HAPI_PRM_SCRIPT_TYPE_RGBAMASK": 30,
        "HAPI_PRM_SCRIPT_TYPE_ORDINAL": 31,
        "HAPI_PRM_SCRIPT_TYPE_RAMP_FLT": 32,
        "HAPI_PRM_SCRIPT_TYPE_RAMP_RGB": 33,
        "HAPI_PRM_SCRIPT_TYPE_FLOAT_LOG": 34,
        "HAPI_PRM_SCRIPT_TYPE_INT_LOG": 35,
        "HAPI_PRM_SCRIPT_TYPE_DATA": 36,
        "HAPI_PRM_SCRIPT_TYPE_FLOAT_MINMAX": 37,
        "HAPI_PRM_SCRIPT_TYPE_INT_MINMAX": 38,
        "HAPI_PRM_SCRIPT_TYPE_INT_STARTEND": 39,
        "HAPI_PRM_SCRIPT_TYPE_BUTTONSTRIP": 40,
        "HAPI_PRM_SCRIPT_TYPE_ICONSTRIP": 41,
        "HAPI_PRM_SCRIPT_TYPE_GROUPRADIO": 1000,
        "HAPI_PRM_SCRIPT_TYPE_GROUPCOLLAPSIBLE": 1001,
        "HAPI_PRM_SCRIPT_TYPE_GROUPSIMPLE": 1002,
        "HAPI_PRM_SCRIPT_TYPE_GROUP": 1003,
    }


class ChoiceListType(object):
    HAPI_CHOICELISTTYPE_NONE = 0
    HAPI_CHOICELISTTYPE_NORMAL = 1
    HAPI_CHOICELISTTYPE_MINI = 2
    HAPI_CHOICELISTTYPE_REPLACE = 3
    HAPI_CHOICELISTTYPE_TOGGLE = 4

    _VALUES_TO_NAMES = {
        0: "HAPI_CHOICELISTTYPE_NONE",
        1: "HAPI_CHOICELISTTYPE_NORMAL",
        2: "HAPI_CHOICELISTTYPE_MINI",
        3: "HAPI_CHOICELISTTYPE_REPLACE",
        4: "HAPI_CHOICELISTTYPE_TOGGLE",
    }

    _NAMES_TO_VALUES = {
        "HAPI_CHOICELISTTYPE_NONE": 0,
        "HAPI_CHOICELISTTYPE_NORMAL": 1,
        "HAPI_CHOICELISTTYPE_MINI": 2,
        "HAPI_CHOICELISTTYPE_REPLACE": 3,
        "HAPI_CHOICELISTTYPE_TOGGLE": 4,
    }


class PresetType(object):
    HAPI_PRESETTYPE_INVALID = -1
    HAPI_PRESETTYPE_BINARY = 0
    HAPI_PRESETTYPE_IDX = 1
    HAPI_PRESETTYPE_MAX = 2

    _VALUES_TO_NAMES = {
        -1: "HAPI_PRESETTYPE_INVALID",
        0: "HAPI_PRESETTYPE_BINARY",
        1: "HAPI_PRESETTYPE_IDX",
        2: "HAPI_PRESETTYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PRESETTYPE_INVALID": -1,
        "HAPI_PRESETTYPE_BINARY": 0,
        "HAPI_PRESETTYPE_IDX": 1,
        "HAPI_PRESETTYPE_MAX": 2,
    }


class NodeType(object):
    HAPI_NODETYPE_ANY = -1
    HAPI_NODETYPE_NONE = 0
    HAPI_NODETYPE_OBJ = 1
    HAPI_NODETYPE_SOP = 2
    HAPI_NODETYPE_CHOP = 4
    HAPI_NODETYPE_ROP = 8
    HAPI_NODETYPE_SHOP = 16
    HAPI_NODETYPE_COP = 32
    HAPI_NODETYPE_VOP = 64
    HAPI_NODETYPE_DOP = 128
    HAPI_NODETYPE_TOP = 256

    _VALUES_TO_NAMES = {
        -1: "HAPI_NODETYPE_ANY",
        0: "HAPI_NODETYPE_NONE",
        1: "HAPI_NODETYPE_OBJ",
        2: "HAPI_NODETYPE_SOP",
        4: "HAPI_NODETYPE_CHOP",
        8: "HAPI_NODETYPE_ROP",
        16: "HAPI_NODETYPE_SHOP",
        32: "HAPI_NODETYPE_COP",
        64: "HAPI_NODETYPE_VOP",
        128: "HAPI_NODETYPE_DOP",
        256: "HAPI_NODETYPE_TOP",
    }

    _NAMES_TO_VALUES = {
        "HAPI_NODETYPE_ANY": -1,
        "HAPI_NODETYPE_NONE": 0,
        "HAPI_NODETYPE_OBJ": 1,
        "HAPI_NODETYPE_SOP": 2,
        "HAPI_NODETYPE_CHOP": 4,
        "HAPI_NODETYPE_ROP": 8,
        "HAPI_NODETYPE_SHOP": 16,
        "HAPI_NODETYPE_COP": 32,
        "HAPI_NODETYPE_VOP": 64,
        "HAPI_NODETYPE_DOP": 128,
        "HAPI_NODETYPE_TOP": 256,
    }


class NodeFlags(object):
    HAPI_NODEFLAGS_ANY = -1
    HAPI_NODEFLAGS_NONE = 0
    HAPI_NODEFLAGS_DISPLAY = 1
    HAPI_NODEFLAGS_RENDER = 2
    HAPI_NODEFLAGS_TEMPLATED = 4
    HAPI_NODEFLAGS_LOCKED = 8
    HAPI_NODEFLAGS_EDITABLE = 16
    HAPI_NODEFLAGS_BYPASS = 32
    HAPI_NODEFLAGS_NETWORK = 64
    HAPI_NODEFLAGS_OBJ_GEOMETRY = 128
    HAPI_NODEFLAGS_OBJ_CAMERA = 256
    HAPI_NODEFLAGS_OBJ_LIGHT = 512
    HAPI_NODEFLAGS_OBJ_SUBNET = 1024
    HAPI_NODEFLAGS_SOP_CURVE = 2048
    HAPI_NODEFLAGS_SOP_GUIDE = 4096
    HAPI_NODEFLAGS_TOP_NONSCHEDULER = 8192

    _VALUES_TO_NAMES = {
        -1: "HAPI_NODEFLAGS_ANY",
        0: "HAPI_NODEFLAGS_NONE",
        1: "HAPI_NODEFLAGS_DISPLAY",
        2: "HAPI_NODEFLAGS_RENDER",
        4: "HAPI_NODEFLAGS_TEMPLATED",
        8: "HAPI_NODEFLAGS_LOCKED",
        16: "HAPI_NODEFLAGS_EDITABLE",
        32: "HAPI_NODEFLAGS_BYPASS",
        64: "HAPI_NODEFLAGS_NETWORK",
        128: "HAPI_NODEFLAGS_OBJ_GEOMETRY",
        256: "HAPI_NODEFLAGS_OBJ_CAMERA",
        512: "HAPI_NODEFLAGS_OBJ_LIGHT",
        1024: "HAPI_NODEFLAGS_OBJ_SUBNET",
        2048: "HAPI_NODEFLAGS_SOP_CURVE",
        4096: "HAPI_NODEFLAGS_SOP_GUIDE",
        8192: "HAPI_NODEFLAGS_TOP_NONSCHEDULER",
    }

    _NAMES_TO_VALUES = {
        "HAPI_NODEFLAGS_ANY": -1,
        "HAPI_NODEFLAGS_NONE": 0,
        "HAPI_NODEFLAGS_DISPLAY": 1,
        "HAPI_NODEFLAGS_RENDER": 2,
        "HAPI_NODEFLAGS_TEMPLATED": 4,
        "HAPI_NODEFLAGS_LOCKED": 8,
        "HAPI_NODEFLAGS_EDITABLE": 16,
        "HAPI_NODEFLAGS_BYPASS": 32,
        "HAPI_NODEFLAGS_NETWORK": 64,
        "HAPI_NODEFLAGS_OBJ_GEOMETRY": 128,
        "HAPI_NODEFLAGS_OBJ_CAMERA": 256,
        "HAPI_NODEFLAGS_OBJ_LIGHT": 512,
        "HAPI_NODEFLAGS_OBJ_SUBNET": 1024,
        "HAPI_NODEFLAGS_SOP_CURVE": 2048,
        "HAPI_NODEFLAGS_SOP_GUIDE": 4096,
        "HAPI_NODEFLAGS_TOP_NONSCHEDULER": 8192,
    }


class GroupType(object):
    HAPI_GROUPTYPE_INVALID = -1
    HAPI_GROUPTYPE_POINT = 0
    HAPI_GROUPTYPE_PRIM = 1
    HAPI_GROUPTYPE_MAX = 2

    _VALUES_TO_NAMES = {
        -1: "HAPI_GROUPTYPE_INVALID",
        0: "HAPI_GROUPTYPE_POINT",
        1: "HAPI_GROUPTYPE_PRIM",
        2: "HAPI_GROUPTYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_GROUPTYPE_INVALID": -1,
        "HAPI_GROUPTYPE_POINT": 0,
        "HAPI_GROUPTYPE_PRIM": 1,
        "HAPI_GROUPTYPE_MAX": 2,
    }


class AttributeOwner(object):
    HAPI_ATTROWNER_INVALID = -1
    HAPI_ATTROWNER_VERTEX = 0
    HAPI_ATTROWNER_POINT = 1
    HAPI_ATTROWNER_PRIM = 2
    HAPI_ATTROWNER_DETAIL = 3
    HAPI_ATTROWNER_MAX = 4

    _VALUES_TO_NAMES = {
        -1: "HAPI_ATTROWNER_INVALID",
        0: "HAPI_ATTROWNER_VERTEX",
        1: "HAPI_ATTROWNER_POINT",
        2: "HAPI_ATTROWNER_PRIM",
        3: "HAPI_ATTROWNER_DETAIL",
        4: "HAPI_ATTROWNER_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_ATTROWNER_INVALID": -1,
        "HAPI_ATTROWNER_VERTEX": 0,
        "HAPI_ATTROWNER_POINT": 1,
        "HAPI_ATTROWNER_PRIM": 2,
        "HAPI_ATTROWNER_DETAIL": 3,
        "HAPI_ATTROWNER_MAX": 4,
    }


class CurveType(object):
    HAPI_CURVETYPE_INVALID = -1
    HAPI_CURVETYPE_LINEAR = 0
    HAPI_CURVETYPE_NURBS = 1
    HAPI_CURVETYPE_BEZIER = 2
    HAPI_CURVETYPE_MAX = 3

    _VALUES_TO_NAMES = {
        -1: "HAPI_CURVETYPE_INVALID",
        0: "HAPI_CURVETYPE_LINEAR",
        1: "HAPI_CURVETYPE_NURBS",
        2: "HAPI_CURVETYPE_BEZIER",
        3: "HAPI_CURVETYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_CURVETYPE_INVALID": -1,
        "HAPI_CURVETYPE_LINEAR": 0,
        "HAPI_CURVETYPE_NURBS": 1,
        "HAPI_CURVETYPE_BEZIER": 2,
        "HAPI_CURVETYPE_MAX": 3,
    }


class VolumeType(object):
    HAPI_VOLUMETYPE_INVALID = -1
    HAPI_VOLUMETYPE_HOUDINI = 0
    HAPI_VOLUMETYPE_VDB = 1
    HAPI_VOLUMETYPE_MAX = 2

    _VALUES_TO_NAMES = {
        -1: "HAPI_VOLUMETYPE_INVALID",
        0: "HAPI_VOLUMETYPE_HOUDINI",
        1: "HAPI_VOLUMETYPE_VDB",
        2: "HAPI_VOLUMETYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_VOLUMETYPE_INVALID": -1,
        "HAPI_VOLUMETYPE_HOUDINI": 0,
        "HAPI_VOLUMETYPE_VDB": 1,
        "HAPI_VOLUMETYPE_MAX": 2,
    }


class StorageType(object):
    HAPI_STORAGETYPE_INVALID = -1
    HAPI_STORAGETYPE_INT = 0
    HAPI_STORAGETYPE_INT64 = 1
    HAPI_STORAGETYPE_FLOAT = 2
    HAPI_STORAGETYPE_FLOAT64 = 3
    HAPI_STORAGETYPE_STRING = 4
    HAPI_STORAGETYPE_MAX = 5

    _VALUES_TO_NAMES = {
        -1: "HAPI_STORAGETYPE_INVALID",
        0: "HAPI_STORAGETYPE_INT",
        1: "HAPI_STORAGETYPE_INT64",
        2: "HAPI_STORAGETYPE_FLOAT",
        3: "HAPI_STORAGETYPE_FLOAT64",
        4: "HAPI_STORAGETYPE_STRING",
        5: "HAPI_STORAGETYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_STORAGETYPE_INVALID": -1,
        "HAPI_STORAGETYPE_INT": 0,
        "HAPI_STORAGETYPE_INT64": 1,
        "HAPI_STORAGETYPE_FLOAT": 2,
        "HAPI_STORAGETYPE_FLOAT64": 3,
        "HAPI_STORAGETYPE_STRING": 4,
        "HAPI_STORAGETYPE_MAX": 5,
    }


class AttributeTypeInfo(object):
    HAPI_ATTRIBUTE_TYPE_INVALID = -1
    HAPI_ATTRIBUTE_TYPE_NONE = 0
    HAPI_ATTRIBUTE_TYPE_POINT = 1
    HAPI_ATTRIBUTE_TYPE_HPOINT = 2
    HAPI_ATTRIBUTE_TYPE_VECTOR = 3
    HAPI_ATTRIBUTE_TYPE_NORMAL = 4
    HAPI_ATTRIBUTE_TYPE_COLOR = 5
    HAPI_ATTRIBUTE_TYPE_QUATERNION = 6
    HAPI_ATTRIBUTE_TYPE_MATRIX3 = 7
    HAPI_ATTRIBUTE_TYPE_MATRIX = 8
    HAPI_ATTRIBUTE_TYPE_ST = 9
    HAPI_ATTRIBUTE_TYPE_HIDDEN = 10
    HAPI_ATTRIBUTE_TYPE_BOX2 = 11
    HAPI_ATTRIBUTE_TYPE_BOX = 12
    HAPI_ATTRIBUTE_TYPE_TEXTURE = 13
    HAPI_ATTRIBUTE_TYPE_MAX = 14

    _VALUES_TO_NAMES = {
        -1: "HAPI_ATTRIBUTE_TYPE_INVALID",
        0: "HAPI_ATTRIBUTE_TYPE_NONE",
        1: "HAPI_ATTRIBUTE_TYPE_POINT",
        2: "HAPI_ATTRIBUTE_TYPE_HPOINT",
        3: "HAPI_ATTRIBUTE_TYPE_VECTOR",
        4: "HAPI_ATTRIBUTE_TYPE_NORMAL",
        5: "HAPI_ATTRIBUTE_TYPE_COLOR",
        6: "HAPI_ATTRIBUTE_TYPE_QUATERNION",
        7: "HAPI_ATTRIBUTE_TYPE_MATRIX3",
        8: "HAPI_ATTRIBUTE_TYPE_MATRIX",
        9: "HAPI_ATTRIBUTE_TYPE_ST",
        10: "HAPI_ATTRIBUTE_TYPE_HIDDEN",
        11: "HAPI_ATTRIBUTE_TYPE_BOX2",
        12: "HAPI_ATTRIBUTE_TYPE_BOX",
        13: "HAPI_ATTRIBUTE_TYPE_TEXTURE",
        14: "HAPI_ATTRIBUTE_TYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_ATTRIBUTE_TYPE_INVALID": -1,
        "HAPI_ATTRIBUTE_TYPE_NONE": 0,
        "HAPI_ATTRIBUTE_TYPE_POINT": 1,
        "HAPI_ATTRIBUTE_TYPE_HPOINT": 2,
        "HAPI_ATTRIBUTE_TYPE_VECTOR": 3,
        "HAPI_ATTRIBUTE_TYPE_NORMAL": 4,
        "HAPI_ATTRIBUTE_TYPE_COLOR": 5,
        "HAPI_ATTRIBUTE_TYPE_QUATERNION": 6,
        "HAPI_ATTRIBUTE_TYPE_MATRIX3": 7,
        "HAPI_ATTRIBUTE_TYPE_MATRIX": 8,
        "HAPI_ATTRIBUTE_TYPE_ST": 9,
        "HAPI_ATTRIBUTE_TYPE_HIDDEN": 10,
        "HAPI_ATTRIBUTE_TYPE_BOX2": 11,
        "HAPI_ATTRIBUTE_TYPE_BOX": 12,
        "HAPI_ATTRIBUTE_TYPE_TEXTURE": 13,
        "HAPI_ATTRIBUTE_TYPE_MAX": 14,
    }


class GeoType(object):
    HAPI_GEOTYPE_INVALID = -1
    HAPI_GEOTYPE_DEFAULT = 0
    HAPI_GEOTYPE_INTERMEDIATE = 1
    HAPI_GEOTYPE_INPUT = 2
    HAPI_GEOTYPE_CURVE = 3
    HAPI_GEOTYPE_MAX = 4

    _VALUES_TO_NAMES = {
        -1: "HAPI_GEOTYPE_INVALID",
        0: "HAPI_GEOTYPE_DEFAULT",
        1: "HAPI_GEOTYPE_INTERMEDIATE",
        2: "HAPI_GEOTYPE_INPUT",
        3: "HAPI_GEOTYPE_CURVE",
        4: "HAPI_GEOTYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_GEOTYPE_INVALID": -1,
        "HAPI_GEOTYPE_DEFAULT": 0,
        "HAPI_GEOTYPE_INTERMEDIATE": 1,
        "HAPI_GEOTYPE_INPUT": 2,
        "HAPI_GEOTYPE_CURVE": 3,
        "HAPI_GEOTYPE_MAX": 4,
    }


class PartType(object):
    HAPI_PARTTYPE_INVALID = -1
    HAPI_PARTTYPE_MESH = 0
    HAPI_PARTTYPE_CURVE = 1
    HAPI_PARTTYPE_VOLUME = 2
    HAPI_PARTTYPE_INSTANCER = 3
    HAPI_PARTTYPE_BOX = 4
    HAPI_PARTTYPE_SPHERE = 5
    HAPI_PARTTYPE_MAX = 6

    _VALUES_TO_NAMES = {
        -1: "HAPI_PARTTYPE_INVALID",
        0: "HAPI_PARTTYPE_MESH",
        1: "HAPI_PARTTYPE_CURVE",
        2: "HAPI_PARTTYPE_VOLUME",
        3: "HAPI_PARTTYPE_INSTANCER",
        4: "HAPI_PARTTYPE_BOX",
        5: "HAPI_PARTTYPE_SPHERE",
        6: "HAPI_PARTTYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PARTTYPE_INVALID": -1,
        "HAPI_PARTTYPE_MESH": 0,
        "HAPI_PARTTYPE_CURVE": 1,
        "HAPI_PARTTYPE_VOLUME": 2,
        "HAPI_PARTTYPE_INSTANCER": 3,
        "HAPI_PARTTYPE_BOX": 4,
        "HAPI_PARTTYPE_SPHERE": 5,
        "HAPI_PARTTYPE_MAX": 6,
    }


class InputType(object):
    HAPI_INPUT_INVALID = -1
    HAPI_INPUT_TRANSFORM = 0
    HAPI_INPUT_GEOMETRY = 1
    HAPI_INPUT_MAX = 2

    _VALUES_TO_NAMES = {
        -1: "HAPI_INPUT_INVALID",
        0: "HAPI_INPUT_TRANSFORM",
        1: "HAPI_INPUT_GEOMETRY",
        2: "HAPI_INPUT_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_INPUT_INVALID": -1,
        "HAPI_INPUT_TRANSFORM": 0,
        "HAPI_INPUT_GEOMETRY": 1,
        "HAPI_INPUT_MAX": 2,
    }


class CurveOrders(object):
    HAPI_CURVE_ORDER_VARYING = 0
    HAPI_CURVE_ORDER_INVALID = 1
    HAPI_CURVE_ORDER_LINEAR = 2
    HAPI_CURVE_ORDER_QUADRATIC = 3
    HAPI_CURVE_ORDER_CUBIC = 4

    _VALUES_TO_NAMES = {
        0: "HAPI_CURVE_ORDER_VARYING",
        1: "HAPI_CURVE_ORDER_INVALID",
        2: "HAPI_CURVE_ORDER_LINEAR",
        3: "HAPI_CURVE_ORDER_QUADRATIC",
        4: "HAPI_CURVE_ORDER_CUBIC",
    }

    _NAMES_TO_VALUES = {
        "HAPI_CURVE_ORDER_VARYING": 0,
        "HAPI_CURVE_ORDER_INVALID": 1,
        "HAPI_CURVE_ORDER_LINEAR": 2,
        "HAPI_CURVE_ORDER_QUADRATIC": 3,
        "HAPI_CURVE_ORDER_CUBIC": 4,
    }


class TransformComponent(object):
    HAPI_TRANSFORM_TX = 0
    HAPI_TRANSFORM_TY = 1
    HAPI_TRANSFORM_TZ = 2
    HAPI_TRANSFORM_RX = 3
    HAPI_TRANSFORM_RY = 4
    HAPI_TRANSFORM_RZ = 5
    HAPI_TRANSFORM_QX = 6
    HAPI_TRANSFORM_QY = 7
    HAPI_TRANSFORM_QZ = 8
    HAPI_TRANSFORM_QW = 9
    HAPI_TRANSFORM_SX = 10
    HAPI_TRANSFORM_SY = 11
    HAPI_TRANSFORM_SZ = 12

    _VALUES_TO_NAMES = {
        0: "HAPI_TRANSFORM_TX",
        1: "HAPI_TRANSFORM_TY",
        2: "HAPI_TRANSFORM_TZ",
        3: "HAPI_TRANSFORM_RX",
        4: "HAPI_TRANSFORM_RY",
        5: "HAPI_TRANSFORM_RZ",
        6: "HAPI_TRANSFORM_QX",
        7: "HAPI_TRANSFORM_QY",
        8: "HAPI_TRANSFORM_QZ",
        9: "HAPI_TRANSFORM_QW",
        10: "HAPI_TRANSFORM_SX",
        11: "HAPI_TRANSFORM_SY",
        12: "HAPI_TRANSFORM_SZ",
    }

    _NAMES_TO_VALUES = {
        "HAPI_TRANSFORM_TX": 0,
        "HAPI_TRANSFORM_TY": 1,
        "HAPI_TRANSFORM_TZ": 2,
        "HAPI_TRANSFORM_RX": 3,
        "HAPI_TRANSFORM_RY": 4,
        "HAPI_TRANSFORM_RZ": 5,
        "HAPI_TRANSFORM_QX": 6,
        "HAPI_TRANSFORM_QY": 7,
        "HAPI_TRANSFORM_QZ": 8,
        "HAPI_TRANSFORM_QW": 9,
        "HAPI_TRANSFORM_SX": 10,
        "HAPI_TRANSFORM_SY": 11,
        "HAPI_TRANSFORM_SZ": 12,
    }


class RSTOrder(object):
    HAPI_TRS = 0
    HAPI_TSR = 1
    HAPI_RTS = 2
    HAPI_RST = 3
    HAPI_STR = 4
    HAPI_SRT = 5
    HAPI_RSTORDER_DEFAULT = 5

    _VALUES_TO_NAMES = {
        0: "HAPI_TRS",
        1: "HAPI_TSR",
        2: "HAPI_RTS",
        3: "HAPI_RST",
        4: "HAPI_STR",
        5: "HAPI_SRT",
        5: "HAPI_RSTORDER_DEFAULT",
    }

    _NAMES_TO_VALUES = {
        "HAPI_TRS": 0,
        "HAPI_TSR": 1,
        "HAPI_RTS": 2,
        "HAPI_RST": 3,
        "HAPI_STR": 4,
        "HAPI_SRT": 5,
        "HAPI_RSTORDER_DEFAULT": 5,
    }


class XYZOrder(object):
    HAPI_XYZ = 0
    HAPI_XZY = 1
    HAPI_YXZ = 2
    HAPI_YZX = 3
    HAPI_ZXY = 4
    HAPI_ZYX = 5
    HAPI_XYZORDER_DEFAULT = 0

    _VALUES_TO_NAMES = {
        0: "HAPI_XYZ",
        1: "HAPI_XZY",
        2: "HAPI_YXZ",
        3: "HAPI_YZX",
        4: "HAPI_ZXY",
        5: "HAPI_ZYX",
        0: "HAPI_XYZORDER_DEFAULT",
    }

    _NAMES_TO_VALUES = {
        "HAPI_XYZ": 0,
        "HAPI_XZY": 1,
        "HAPI_YXZ": 2,
        "HAPI_YZX": 3,
        "HAPI_ZXY": 4,
        "HAPI_ZYX": 5,
        "HAPI_XYZORDER_DEFAULT": 0,
    }


class ImageDataFormat(object):
    HAPI_IMAGE_DATA_UNKNOWN = -1
    HAPI_IMAGE_DATA_INT8 = 0
    HAPI_IMAGE_DATA_INT16 = 1
    HAPI_IMAGE_DATA_INT32 = 2
    HAPI_IMAGE_DATA_FLOAT16 = 3
    HAPI_IMAGE_DATA_FLOAT32 = 4
    HAPI_IMAGE_DATA_MAX = 5
    HAPI_IMAGE_DATA_DEFAULT = 0

    _VALUES_TO_NAMES = {
        -1: "HAPI_IMAGE_DATA_UNKNOWN",
        0: "HAPI_IMAGE_DATA_INT8",
        1: "HAPI_IMAGE_DATA_INT16",
        2: "HAPI_IMAGE_DATA_INT32",
        3: "HAPI_IMAGE_DATA_FLOAT16",
        4: "HAPI_IMAGE_DATA_FLOAT32",
        5: "HAPI_IMAGE_DATA_MAX",
        0: "HAPI_IMAGE_DATA_DEFAULT",
    }

    _NAMES_TO_VALUES = {
        "HAPI_IMAGE_DATA_UNKNOWN": -1,
        "HAPI_IMAGE_DATA_INT8": 0,
        "HAPI_IMAGE_DATA_INT16": 1,
        "HAPI_IMAGE_DATA_INT32": 2,
        "HAPI_IMAGE_DATA_FLOAT16": 3,
        "HAPI_IMAGE_DATA_FLOAT32": 4,
        "HAPI_IMAGE_DATA_MAX": 5,
        "HAPI_IMAGE_DATA_DEFAULT": 0,
    }


class ImagePacking(object):
    HAPI_IMAGE_PACKING_UNKNOWN = -1
    HAPI_IMAGE_PACKING_SINGLE = 0
    HAPI_IMAGE_PACKING_DUAL = 1
    HAPI_IMAGE_PACKING_RGB = 2
    HAPI_IMAGE_PACKING_BGR = 3
    HAPI_IMAGE_PACKING_RGBA = 4
    HAPI_IMAGE_PACKING_ABGR = 5
    HAPI_IMAGE_PACKING_MAX = 6
    HAPI_IMAGE_PACKING_DEFAULT3 = 2
    HAPI_IMAGE_PACKING_DEFAULT4 = 4

    _VALUES_TO_NAMES = {
        -1: "HAPI_IMAGE_PACKING_UNKNOWN",
        0: "HAPI_IMAGE_PACKING_SINGLE",
        1: "HAPI_IMAGE_PACKING_DUAL",
        2: "HAPI_IMAGE_PACKING_RGB",
        3: "HAPI_IMAGE_PACKING_BGR",
        4: "HAPI_IMAGE_PACKING_RGBA",
        5: "HAPI_IMAGE_PACKING_ABGR",
        6: "HAPI_IMAGE_PACKING_MAX",
        2: "HAPI_IMAGE_PACKING_DEFAULT3",
        4: "HAPI_IMAGE_PACKING_DEFAULT4",
    }

    _NAMES_TO_VALUES = {
        "HAPI_IMAGE_PACKING_UNKNOWN": -1,
        "HAPI_IMAGE_PACKING_SINGLE": 0,
        "HAPI_IMAGE_PACKING_DUAL": 1,
        "HAPI_IMAGE_PACKING_RGB": 2,
        "HAPI_IMAGE_PACKING_BGR": 3,
        "HAPI_IMAGE_PACKING_RGBA": 4,
        "HAPI_IMAGE_PACKING_ABGR": 5,
        "HAPI_IMAGE_PACKING_MAX": 6,
        "HAPI_IMAGE_PACKING_DEFAULT3": 2,
        "HAPI_IMAGE_PACKING_DEFAULT4": 4,
    }


class EnvIntType(object):
    HAPI_ENVINT_INVALID = -1
    HAPI_ENVINT_VERSION_HOUDINI_MAJOR = 100
    HAPI_ENVINT_VERSION_HOUDINI_MINOR = 110
    HAPI_ENVINT_VERSION_HOUDINI_BUILD = 120
    HAPI_ENVINT_VERSION_HOUDINI_PATCH = 130
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MAJOR = 200
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MINOR = 210
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_API = 220
    HAPI_ENVINT_MAX = 221

    _VALUES_TO_NAMES = {
        -1: "HAPI_ENVINT_INVALID",
        100: "HAPI_ENVINT_VERSION_HOUDINI_MAJOR",
        110: "HAPI_ENVINT_VERSION_HOUDINI_MINOR",
        120: "HAPI_ENVINT_VERSION_HOUDINI_BUILD",
        130: "HAPI_ENVINT_VERSION_HOUDINI_PATCH",
        200: "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MAJOR",
        210: "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MINOR",
        220: "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_API",
        221: "HAPI_ENVINT_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_ENVINT_INVALID": -1,
        "HAPI_ENVINT_VERSION_HOUDINI_MAJOR": 100,
        "HAPI_ENVINT_VERSION_HOUDINI_MINOR": 110,
        "HAPI_ENVINT_VERSION_HOUDINI_BUILD": 120,
        "HAPI_ENVINT_VERSION_HOUDINI_PATCH": 130,
        "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MAJOR": 200,
        "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MINOR": 210,
        "HAPI_ENVINT_VERSION_HOUDINI_ENGINE_API": 220,
        "HAPI_ENVINT_MAX": 221,
    }


class SessionEnvIntType(object):
    HAPI_SESSIONENVINT_INVALID = -1
    HAPI_SESSIONENVINT_LICENSE = 100
    HAPI_SESSIONENVINT_MAX = 101

    _VALUES_TO_NAMES = {
        -1: "HAPI_SESSIONENVINT_INVALID",
        100: "HAPI_SESSIONENVINT_LICENSE",
        101: "HAPI_SESSIONENVINT_MAX",
    }

    _NAMES_TO_VALUES = {
        "HAPI_SESSIONENVINT_INVALID": -1,
        "HAPI_SESSIONENVINT_LICENSE": 100,
        "HAPI_SESSIONENVINT_MAX": 101,
    }


class CacheProperty(object):
    HAPI_CACHEPROP_CURRENT = 0
    HAPI_CACHEPROP_HAS_MIN = 1
    HAPI_CACHEPROP_MIN = 2
    HAPI_CACHEPROP_HAS_MAX = 3
    HAPI_CACHEPROP_MAX = 4
    HAPI_CACHEPROP_CULL_LEVEL = 5

    _VALUES_TO_NAMES = {
        0: "HAPI_CACHEPROP_CURRENT",
        1: "HAPI_CACHEPROP_HAS_MIN",
        2: "HAPI_CACHEPROP_MIN",
        3: "HAPI_CACHEPROP_HAS_MAX",
        4: "HAPI_CACHEPROP_MAX",
        5: "HAPI_CACHEPROP_CULL_LEVEL",
    }

    _NAMES_TO_VALUES = {
        "HAPI_CACHEPROP_CURRENT": 0,
        "HAPI_CACHEPROP_HAS_MIN": 1,
        "HAPI_CACHEPROP_MIN": 2,
        "HAPI_CACHEPROP_HAS_MAX": 3,
        "HAPI_CACHEPROP_MAX": 4,
        "HAPI_CACHEPROP_CULL_LEVEL": 5,
    }


class HeightFieldSampling(object):
    HAPI_HEIGHTFIELD_SAMPLING_CENTER = 0
    HAPI_HEIGHTFIELD_SAMPLING_CORNER = 1

    _VALUES_TO_NAMES = {
        0: "HAPI_HEIGHTFIELD_SAMPLING_CENTER",
        1: "HAPI_HEIGHTFIELD_SAMPLING_CORNER",
    }

    _NAMES_TO_VALUES = {
        "HAPI_HEIGHTFIELD_SAMPLING_CENTER": 0,
        "HAPI_HEIGHTFIELD_SAMPLING_CORNER": 1,
    }


class PDG_State(object):
    HAPI_PDG_STATE_READY = 0
    HAPI_PDG_STATE_COOKING = 1
    HAPI_PDG_STATE_MAX = 2
    HAPI_PDG_STATE_MAX_READY_STATE = 0

    _VALUES_TO_NAMES = {
        0: "HAPI_PDG_STATE_READY",
        1: "HAPI_PDG_STATE_COOKING",
        2: "HAPI_PDG_STATE_MAX",
        0: "HAPI_PDG_STATE_MAX_READY_STATE",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PDG_STATE_READY": 0,
        "HAPI_PDG_STATE_COOKING": 1,
        "HAPI_PDG_STATE_MAX": 2,
        "HAPI_PDG_STATE_MAX_READY_STATE": 0,
    }


class PDG_EventType(object):
    HAPI_PDG_EVENT_NULL = 0
    HAPI_PDG_EVENT_WORKITEM_ADD = 1
    HAPI_PDG_EVENT_WORKITEM_REMOVE = 2
    HAPI_PDG_EVENT_WORKITEM_STATE_CHANGE = 3
    HAPI_PDG_EVENT_WORKITEM_ADD_DEP = 4
    HAPI_PDG_EVENT_WORKITEM_REMOVE_DEP = 5
    HAPI_PDG_EVENT_WORKITEM_ADD_PARENT = 6
    HAPI_PDG_EVENT_WORKITEM_REMOVE_PARENT = 7
    HAPI_PDG_EVENT_NODE_CLEAR = 8
    HAPI_PDG_EVENT_COOK_ERROR = 9
    HAPI_PDG_EVENT_COOK_WARNING = 10
    HAPI_PDG_EVENT_COOK_COMPLETE = 11
    HAPI_PDG_EVENT_DIRTY_START = 12
    HAPI_PDG_EVENT_DIRTY_STOP = 13
    HAPI_PDG_EVENT_DIRTY_ALL = 14
    HAPI_PDG_EVENT_UI_SELECT = 15
    HAPI_PDG_EVENT_NODE_CREATE = 16
    HAPI_PDG_EVENT_NODE_REMOVE = 17
    HAPI_PDG_EVENT_NODE_RENAME = 18
    HAPI_PDG_EVENT_NODE_CONNECT = 19
    HAPI_PDG_EVENT_NODE_DISCONNECT = 20
    HAPI_PDG_EVENT_WORKITEM_SET_INT = 21
    HAPI_PDG_EVENT_WORKITEM_SET_FLOAT = 22
    HAPI_PDG_EVENT_WORKITEM_SET_STRING = 23
    HAPI_PDG_EVENT_WORKITEM_SET_FILE = 24
    HAPI_PDG_EVENT_WORKITEM_SET_PYOBJECT = 25
    HAPI_PDG_EVENT_WORKITEM_SET_GEOMETRY = 26
    HAPI_PDG_EVENT_WORKITEM_RESULT = 27
    HAPI_PDG_EVENT_WORKITEM_PRIORITY = 28
    HAPI_PDG_EVENT_COOK_START = 29
    HAPI_PDG_EVENT_WORKITEM_ADD_STATIC_ANCESTOR = 30
    HAPI_PDG_EVENT_WORKITEM_REMOVE_STATIC_ANCESTOR = 31
    HAPI_PDG_EVENT_NODE_PROGRESS_UPDATE = 32
    HAPI_PDG_EVENT_ALL = 33
    HAPI_PDG_EVENT_LOG = 34
    HAPI_PDG_CONTEXT_EVENTS = 35

    _VALUES_TO_NAMES = {
        0: "HAPI_PDG_EVENT_NULL",
        1: "HAPI_PDG_EVENT_WORKITEM_ADD",
        2: "HAPI_PDG_EVENT_WORKITEM_REMOVE",
        3: "HAPI_PDG_EVENT_WORKITEM_STATE_CHANGE",
        4: "HAPI_PDG_EVENT_WORKITEM_ADD_DEP",
        5: "HAPI_PDG_EVENT_WORKITEM_REMOVE_DEP",
        6: "HAPI_PDG_EVENT_WORKITEM_ADD_PARENT",
        7: "HAPI_PDG_EVENT_WORKITEM_REMOVE_PARENT",
        8: "HAPI_PDG_EVENT_NODE_CLEAR",
        9: "HAPI_PDG_EVENT_COOK_ERROR",
        10: "HAPI_PDG_EVENT_COOK_WARNING",
        11: "HAPI_PDG_EVENT_COOK_COMPLETE",
        12: "HAPI_PDG_EVENT_DIRTY_START",
        13: "HAPI_PDG_EVENT_DIRTY_STOP",
        14: "HAPI_PDG_EVENT_DIRTY_ALL",
        15: "HAPI_PDG_EVENT_UI_SELECT",
        16: "HAPI_PDG_EVENT_NODE_CREATE",
        17: "HAPI_PDG_EVENT_NODE_REMOVE",
        18: "HAPI_PDG_EVENT_NODE_RENAME",
        19: "HAPI_PDG_EVENT_NODE_CONNECT",
        20: "HAPI_PDG_EVENT_NODE_DISCONNECT",
        21: "HAPI_PDG_EVENT_WORKITEM_SET_INT",
        22: "HAPI_PDG_EVENT_WORKITEM_SET_FLOAT",
        23: "HAPI_PDG_EVENT_WORKITEM_SET_STRING",
        24: "HAPI_PDG_EVENT_WORKITEM_SET_FILE",
        25: "HAPI_PDG_EVENT_WORKITEM_SET_PYOBJECT",
        26: "HAPI_PDG_EVENT_WORKITEM_SET_GEOMETRY",
        27: "HAPI_PDG_EVENT_WORKITEM_RESULT",
        28: "HAPI_PDG_EVENT_WORKITEM_PRIORITY",
        29: "HAPI_PDG_EVENT_COOK_START",
        30: "HAPI_PDG_EVENT_WORKITEM_ADD_STATIC_ANCESTOR",
        31: "HAPI_PDG_EVENT_WORKITEM_REMOVE_STATIC_ANCESTOR",
        32: "HAPI_PDG_EVENT_NODE_PROGRESS_UPDATE",
        33: "HAPI_PDG_EVENT_ALL",
        34: "HAPI_PDG_EVENT_LOG",
        35: "HAPI_PDG_CONTEXT_EVENTS",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PDG_EVENT_NULL": 0,
        "HAPI_PDG_EVENT_WORKITEM_ADD": 1,
        "HAPI_PDG_EVENT_WORKITEM_REMOVE": 2,
        "HAPI_PDG_EVENT_WORKITEM_STATE_CHANGE": 3,
        "HAPI_PDG_EVENT_WORKITEM_ADD_DEP": 4,
        "HAPI_PDG_EVENT_WORKITEM_REMOVE_DEP": 5,
        "HAPI_PDG_EVENT_WORKITEM_ADD_PARENT": 6,
        "HAPI_PDG_EVENT_WORKITEM_REMOVE_PARENT": 7,
        "HAPI_PDG_EVENT_NODE_CLEAR": 8,
        "HAPI_PDG_EVENT_COOK_ERROR": 9,
        "HAPI_PDG_EVENT_COOK_WARNING": 10,
        "HAPI_PDG_EVENT_COOK_COMPLETE": 11,
        "HAPI_PDG_EVENT_DIRTY_START": 12,
        "HAPI_PDG_EVENT_DIRTY_STOP": 13,
        "HAPI_PDG_EVENT_DIRTY_ALL": 14,
        "HAPI_PDG_EVENT_UI_SELECT": 15,
        "HAPI_PDG_EVENT_NODE_CREATE": 16,
        "HAPI_PDG_EVENT_NODE_REMOVE": 17,
        "HAPI_PDG_EVENT_NODE_RENAME": 18,
        "HAPI_PDG_EVENT_NODE_CONNECT": 19,
        "HAPI_PDG_EVENT_NODE_DISCONNECT": 20,
        "HAPI_PDG_EVENT_WORKITEM_SET_INT": 21,
        "HAPI_PDG_EVENT_WORKITEM_SET_FLOAT": 22,
        "HAPI_PDG_EVENT_WORKITEM_SET_STRING": 23,
        "HAPI_PDG_EVENT_WORKITEM_SET_FILE": 24,
        "HAPI_PDG_EVENT_WORKITEM_SET_PYOBJECT": 25,
        "HAPI_PDG_EVENT_WORKITEM_SET_GEOMETRY": 26,
        "HAPI_PDG_EVENT_WORKITEM_RESULT": 27,
        "HAPI_PDG_EVENT_WORKITEM_PRIORITY": 28,
        "HAPI_PDG_EVENT_COOK_START": 29,
        "HAPI_PDG_EVENT_WORKITEM_ADD_STATIC_ANCESTOR": 30,
        "HAPI_PDG_EVENT_WORKITEM_REMOVE_STATIC_ANCESTOR": 31,
        "HAPI_PDG_EVENT_NODE_PROGRESS_UPDATE": 32,
        "HAPI_PDG_EVENT_ALL": 33,
        "HAPI_PDG_EVENT_LOG": 34,
        "HAPI_PDG_CONTEXT_EVENTS": 35,
    }


class PDG_WorkitemState(object):
    HAPI_PDG_WORKITEM_UNDEFINED = 0
    HAPI_PDG_WORKITEM_UNCOOKED = 1
    HAPI_PDG_WORKITEM_WAITING = 2
    HAPI_PDG_WORKITEM_SCHEDULED = 3
    HAPI_PDG_WORKITEM_COOKING = 4
    HAPI_PDG_WORKITEM_COOKED_SUCCESS = 5
    HAPI_PDG_WORKITEM_COOKED_CACHE = 6
    HAPI_PDG_WORKITEM_COOKED_FAIL = 7
    HAPI_PDG_WORKITEM_COOKED_CANCEL = 8
    HAPI_PDG_WORKITEM_DIRTY = 9

    _VALUES_TO_NAMES = {
        0: "HAPI_PDG_WORKITEM_UNDEFINED",
        1: "HAPI_PDG_WORKITEM_UNCOOKED",
        2: "HAPI_PDG_WORKITEM_WAITING",
        3: "HAPI_PDG_WORKITEM_SCHEDULED",
        4: "HAPI_PDG_WORKITEM_COOKING",
        5: "HAPI_PDG_WORKITEM_COOKED_SUCCESS",
        6: "HAPI_PDG_WORKITEM_COOKED_CACHE",
        7: "HAPI_PDG_WORKITEM_COOKED_FAIL",
        8: "HAPI_PDG_WORKITEM_COOKED_CANCEL",
        9: "HAPI_PDG_WORKITEM_DIRTY",
    }

    _NAMES_TO_VALUES = {
        "HAPI_PDG_WORKITEM_UNDEFINED": 0,
        "HAPI_PDG_WORKITEM_UNCOOKED": 1,
        "HAPI_PDG_WORKITEM_WAITING": 2,
        "HAPI_PDG_WORKITEM_SCHEDULED": 3,
        "HAPI_PDG_WORKITEM_COOKING": 4,
        "HAPI_PDG_WORKITEM_COOKED_SUCCESS": 5,
        "HAPI_PDG_WORKITEM_COOKED_CACHE": 6,
        "HAPI_PDG_WORKITEM_COOKED_FAIL": 7,
        "HAPI_PDG_WORKITEM_COOKED_CANCEL": 8,
        "HAPI_PDG_WORKITEM_DIRTY": 9,
    }


class Transform(object):
    """
    Attributes:
     - position
     - rotationQuaternion
     - scale
     - shear
     - rstOrder

    """


    def __init__(self, position=None, rotationQuaternion=None, scale=None, shear=None, rstOrder=None,):
        self.position = position
        self.rotationQuaternion = rotationQuaternion
        self.scale = scale
        self.shear = shear
        self.rstOrder = rstOrder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.position = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readDouble()
                        self.position.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.rotationQuaternion = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.rotationQuaternion.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.scale = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readDouble()
                        self.scale.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.shear = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = iprot.readDouble()
                        self.shear.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.rstOrder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Transform')
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.position))
            for iter24 in self.position:
                oprot.writeDouble(iter24)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotationQuaternion is not None:
            oprot.writeFieldBegin('rotationQuaternion', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.rotationQuaternion))
            for iter25 in self.rotationQuaternion:
                oprot.writeDouble(iter25)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.scale))
            for iter26 in self.scale:
                oprot.writeDouble(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.shear is not None:
            oprot.writeFieldBegin('shear', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.shear))
            for iter27 in self.shear:
                oprot.writeDouble(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rstOrder is not None:
            oprot.writeFieldBegin('rstOrder', TType.I32, 5)
            oprot.writeI32(self.rstOrder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TransformEuler(object):
    """
    Attributes:
     - position
     - rotationEuler
     - scale
     - shear
     - rotationOrder
     - rstOrder

    """


    def __init__(self, position=None, rotationEuler=None, scale=None, shear=None, rotationOrder=None, rstOrder=None,):
        self.position = position
        self.rotationEuler = rotationEuler
        self.scale = scale
        self.shear = shear
        self.rotationOrder = rotationOrder
        self.rstOrder = rstOrder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.position = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readDouble()
                        self.position.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.rotationEuler = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readDouble()
                        self.rotationEuler.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.scale = []
                    (_etype43, _size40) = iprot.readListBegin()
                    for _i44 in range(_size40):
                        _elem45 = iprot.readDouble()
                        self.scale.append(_elem45)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.shear = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = iprot.readDouble()
                        self.shear.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.rotationOrder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.rstOrder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransformEuler')
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.position))
            for iter52 in self.position:
                oprot.writeDouble(iter52)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotationEuler is not None:
            oprot.writeFieldBegin('rotationEuler', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.rotationEuler))
            for iter53 in self.rotationEuler:
                oprot.writeDouble(iter53)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.scale))
            for iter54 in self.scale:
                oprot.writeDouble(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.shear is not None:
            oprot.writeFieldBegin('shear', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.shear))
            for iter55 in self.shear:
                oprot.writeDouble(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotationOrder is not None:
            oprot.writeFieldBegin('rotationOrder', TType.I32, 5)
            oprot.writeI32(self.rotationOrder)
            oprot.writeFieldEnd()
        if self.rstOrder is not None:
            oprot.writeFieldBegin('rstOrder', TType.I32, 6)
            oprot.writeI32(self.rstOrder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ThriftServerOptions(object):
    """
    Attributes:
     - autoClose
     - timeoutMs

    """


    def __init__(self, autoClose=None, timeoutMs=None,):
        self.autoClose = autoClose
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.autoClose = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.timeoutMs = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ThriftServerOptions')
        if self.autoClose is not None:
            oprot.writeFieldBegin('autoClose', TType.BOOL, 1)
            oprot.writeBool(self.autoClose)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.DOUBLE, 2)
            oprot.writeDouble(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimelineOptions(object):
    """
    Attributes:
     - fps
     - startTime
     - endTime

    """


    def __init__(self, fps=None, startTime=None, endTime=None,):
        self.fps = fps
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.fps = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.startTime = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.endTime = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimelineOptions')
        if self.fps is not None:
            oprot.writeFieldBegin('fps', TType.DOUBLE, 1)
            oprot.writeDouble(self.fps)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.DOUBLE, 2)
            oprot.writeDouble(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.DOUBLE, 3)
            oprot.writeDouble(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AssetInfo(object):
    """
    Attributes:
     - nodeId
     - objectNodeId
     - hasEverCooked
     - nameSH
     - labelSH
     - filePathSH
     - versionSH
     - fullOpNameSH
     - helpTextSH
     - helpURLSH
     - objectCount
     - handleCount
     - transformInputCount
     - geoInputCount
     - geoOutputCount
     - haveObjectsChanged
     - haveMaterialsChanged

    """


    def __init__(self, nodeId=None, objectNodeId=None, hasEverCooked=None, nameSH=None, labelSH=None, filePathSH=None, versionSH=None, fullOpNameSH=None, helpTextSH=None, helpURLSH=None, objectCount=None, handleCount=None, transformInputCount=None, geoInputCount=None, geoOutputCount=None, haveObjectsChanged=None, haveMaterialsChanged=None,):
        self.nodeId = nodeId
        self.objectNodeId = objectNodeId
        self.hasEverCooked = hasEverCooked
        self.nameSH = nameSH
        self.labelSH = labelSH
        self.filePathSH = filePathSH
        self.versionSH = versionSH
        self.fullOpNameSH = fullOpNameSH
        self.helpTextSH = helpTextSH
        self.helpURLSH = helpURLSH
        self.objectCount = objectCount
        self.handleCount = handleCount
        self.transformInputCount = transformInputCount
        self.geoInputCount = geoInputCount
        self.geoOutputCount = geoOutputCount
        self.haveObjectsChanged = haveObjectsChanged
        self.haveMaterialsChanged = haveMaterialsChanged

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.objectNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasEverCooked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.labelSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.filePathSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.versionSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.fullOpNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.helpTextSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.helpURLSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.objectCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.handleCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.transformInputCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.geoInputCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.geoOutputCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.haveObjectsChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.haveMaterialsChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AssetInfo')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 1)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        if self.objectNodeId is not None:
            oprot.writeFieldBegin('objectNodeId', TType.I32, 2)
            oprot.writeI32(self.objectNodeId)
            oprot.writeFieldEnd()
        if self.hasEverCooked is not None:
            oprot.writeFieldBegin('hasEverCooked', TType.BOOL, 3)
            oprot.writeBool(self.hasEverCooked)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 4)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.labelSH is not None:
            oprot.writeFieldBegin('labelSH', TType.I32, 5)
            oprot.writeI32(self.labelSH)
            oprot.writeFieldEnd()
        if self.filePathSH is not None:
            oprot.writeFieldBegin('filePathSH', TType.I32, 6)
            oprot.writeI32(self.filePathSH)
            oprot.writeFieldEnd()
        if self.versionSH is not None:
            oprot.writeFieldBegin('versionSH', TType.I32, 7)
            oprot.writeI32(self.versionSH)
            oprot.writeFieldEnd()
        if self.fullOpNameSH is not None:
            oprot.writeFieldBegin('fullOpNameSH', TType.I32, 8)
            oprot.writeI32(self.fullOpNameSH)
            oprot.writeFieldEnd()
        if self.helpTextSH is not None:
            oprot.writeFieldBegin('helpTextSH', TType.I32, 9)
            oprot.writeI32(self.helpTextSH)
            oprot.writeFieldEnd()
        if self.helpURLSH is not None:
            oprot.writeFieldBegin('helpURLSH', TType.I32, 10)
            oprot.writeI32(self.helpURLSH)
            oprot.writeFieldEnd()
        if self.objectCount is not None:
            oprot.writeFieldBegin('objectCount', TType.I32, 11)
            oprot.writeI32(self.objectCount)
            oprot.writeFieldEnd()
        if self.handleCount is not None:
            oprot.writeFieldBegin('handleCount', TType.I32, 12)
            oprot.writeI32(self.handleCount)
            oprot.writeFieldEnd()
        if self.transformInputCount is not None:
            oprot.writeFieldBegin('transformInputCount', TType.I32, 13)
            oprot.writeI32(self.transformInputCount)
            oprot.writeFieldEnd()
        if self.geoInputCount is not None:
            oprot.writeFieldBegin('geoInputCount', TType.I32, 14)
            oprot.writeI32(self.geoInputCount)
            oprot.writeFieldEnd()
        if self.geoOutputCount is not None:
            oprot.writeFieldBegin('geoOutputCount', TType.I32, 15)
            oprot.writeI32(self.geoOutputCount)
            oprot.writeFieldEnd()
        if self.haveObjectsChanged is not None:
            oprot.writeFieldBegin('haveObjectsChanged', TType.BOOL, 16)
            oprot.writeBool(self.haveObjectsChanged)
            oprot.writeFieldEnd()
        if self.haveMaterialsChanged is not None:
            oprot.writeFieldBegin('haveMaterialsChanged', TType.BOOL, 17)
            oprot.writeBool(self.haveMaterialsChanged)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CookOptions(object):
    """
    Attributes:
     - splitGeosByGroup
     - splitGeosByAttribute
     - splitAttrSH
     - maxVerticesPerPrimitive
     - refineCurveToLinear
     - curveRefineLOD
     - clearErrorsAndWarnings
     - cookTemplatedGeos
     - splitPointsByVertexAttributes
     - packedPrimInstancingMode
     - handleBoxPartTypes
     - handleSpherePartTypes
     - checkPartChanges
     - extraFlags

    """


    def __init__(self, splitGeosByGroup=None, splitGeosByAttribute=None, splitAttrSH=None, maxVerticesPerPrimitive=None, refineCurveToLinear=None, curveRefineLOD=None, clearErrorsAndWarnings=None, cookTemplatedGeos=None, splitPointsByVertexAttributes=None, packedPrimInstancingMode=None, handleBoxPartTypes=None, handleSpherePartTypes=None, checkPartChanges=None, extraFlags=None,):
        self.splitGeosByGroup = splitGeosByGroup
        self.splitGeosByAttribute = splitGeosByAttribute
        self.splitAttrSH = splitAttrSH
        self.maxVerticesPerPrimitive = maxVerticesPerPrimitive
        self.refineCurveToLinear = refineCurveToLinear
        self.curveRefineLOD = curveRefineLOD
        self.clearErrorsAndWarnings = clearErrorsAndWarnings
        self.cookTemplatedGeos = cookTemplatedGeos
        self.splitPointsByVertexAttributes = splitPointsByVertexAttributes
        self.packedPrimInstancingMode = packedPrimInstancingMode
        self.handleBoxPartTypes = handleBoxPartTypes
        self.handleSpherePartTypes = handleSpherePartTypes
        self.checkPartChanges = checkPartChanges
        self.extraFlags = extraFlags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.splitGeosByGroup = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.splitGeosByAttribute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.splitAttrSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxVerticesPerPrimitive = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.refineCurveToLinear = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.curveRefineLOD = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.clearErrorsAndWarnings = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.cookTemplatedGeos = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.splitPointsByVertexAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.packedPrimInstancingMode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.handleBoxPartTypes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.handleSpherePartTypes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.checkPartChanges = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.extraFlags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CookOptions')
        if self.splitGeosByGroup is not None:
            oprot.writeFieldBegin('splitGeosByGroup', TType.BOOL, 1)
            oprot.writeBool(self.splitGeosByGroup)
            oprot.writeFieldEnd()
        if self.splitGeosByAttribute is not None:
            oprot.writeFieldBegin('splitGeosByAttribute', TType.BOOL, 2)
            oprot.writeBool(self.splitGeosByAttribute)
            oprot.writeFieldEnd()
        if self.splitAttrSH is not None:
            oprot.writeFieldBegin('splitAttrSH', TType.I32, 3)
            oprot.writeI32(self.splitAttrSH)
            oprot.writeFieldEnd()
        if self.maxVerticesPerPrimitive is not None:
            oprot.writeFieldBegin('maxVerticesPerPrimitive', TType.I32, 4)
            oprot.writeI32(self.maxVerticesPerPrimitive)
            oprot.writeFieldEnd()
        if self.refineCurveToLinear is not None:
            oprot.writeFieldBegin('refineCurveToLinear', TType.BOOL, 5)
            oprot.writeBool(self.refineCurveToLinear)
            oprot.writeFieldEnd()
        if self.curveRefineLOD is not None:
            oprot.writeFieldBegin('curveRefineLOD', TType.DOUBLE, 6)
            oprot.writeDouble(self.curveRefineLOD)
            oprot.writeFieldEnd()
        if self.clearErrorsAndWarnings is not None:
            oprot.writeFieldBegin('clearErrorsAndWarnings', TType.BOOL, 7)
            oprot.writeBool(self.clearErrorsAndWarnings)
            oprot.writeFieldEnd()
        if self.cookTemplatedGeos is not None:
            oprot.writeFieldBegin('cookTemplatedGeos', TType.BOOL, 8)
            oprot.writeBool(self.cookTemplatedGeos)
            oprot.writeFieldEnd()
        if self.splitPointsByVertexAttributes is not None:
            oprot.writeFieldBegin('splitPointsByVertexAttributes', TType.BOOL, 9)
            oprot.writeBool(self.splitPointsByVertexAttributes)
            oprot.writeFieldEnd()
        if self.packedPrimInstancingMode is not None:
            oprot.writeFieldBegin('packedPrimInstancingMode', TType.I32, 10)
            oprot.writeI32(self.packedPrimInstancingMode)
            oprot.writeFieldEnd()
        if self.handleBoxPartTypes is not None:
            oprot.writeFieldBegin('handleBoxPartTypes', TType.BOOL, 11)
            oprot.writeBool(self.handleBoxPartTypes)
            oprot.writeFieldEnd()
        if self.handleSpherePartTypes is not None:
            oprot.writeFieldBegin('handleSpherePartTypes', TType.BOOL, 12)
            oprot.writeBool(self.handleSpherePartTypes)
            oprot.writeFieldEnd()
        if self.checkPartChanges is not None:
            oprot.writeFieldBegin('checkPartChanges', TType.BOOL, 13)
            oprot.writeBool(self.checkPartChanges)
            oprot.writeFieldEnd()
        if self.extraFlags is not None:
            oprot.writeFieldBegin('extraFlags', TType.I32, 14)
            oprot.writeI32(self.extraFlags)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeInfo(object):
    """
    Attributes:
     - id
     - parentId
     - nameSH
     - type
     - isValid
     - totalCookCount
     - uniqueHoudiniNodeId
     - internalNodePathSH
     - parmCount
     - parmIntValueCount
     - parmFloatValueCount
     - parmStringValueCount
     - parmChoiceCount
     - childNodeCount
     - inputCount
     - outputCount
     - createdPostAssetLoad
     - isTimeDependent

    """


    def __init__(self, id=None, parentId=None, nameSH=None, type=None, isValid=None, totalCookCount=None, uniqueHoudiniNodeId=None, internalNodePathSH=None, parmCount=None, parmIntValueCount=None, parmFloatValueCount=None, parmStringValueCount=None, parmChoiceCount=None, childNodeCount=None, inputCount=None, outputCount=None, createdPostAssetLoad=None, isTimeDependent=None,):
        self.id = id
        self.parentId = parentId
        self.nameSH = nameSH
        self.type = type
        self.isValid = isValid
        self.totalCookCount = totalCookCount
        self.uniqueHoudiniNodeId = uniqueHoudiniNodeId
        self.internalNodePathSH = internalNodePathSH
        self.parmCount = parmCount
        self.parmIntValueCount = parmIntValueCount
        self.parmFloatValueCount = parmFloatValueCount
        self.parmStringValueCount = parmStringValueCount
        self.parmChoiceCount = parmChoiceCount
        self.childNodeCount = childNodeCount
        self.inputCount = inputCount
        self.outputCount = outputCount
        self.createdPostAssetLoad = createdPostAssetLoad
        self.isTimeDependent = isTimeDependent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isValid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.totalCookCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.uniqueHoudiniNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.internalNodePathSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.parmCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.parmIntValueCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.parmFloatValueCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.parmStringValueCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.parmChoiceCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.childNodeCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.inputCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.outputCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.createdPostAssetLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BOOL:
                    self.isTimeDependent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.parentId is not None:
            oprot.writeFieldBegin('parentId', TType.I32, 2)
            oprot.writeI32(self.parentId)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 3)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.isValid is not None:
            oprot.writeFieldBegin('isValid', TType.BOOL, 5)
            oprot.writeBool(self.isValid)
            oprot.writeFieldEnd()
        if self.totalCookCount is not None:
            oprot.writeFieldBegin('totalCookCount', TType.I32, 6)
            oprot.writeI32(self.totalCookCount)
            oprot.writeFieldEnd()
        if self.uniqueHoudiniNodeId is not None:
            oprot.writeFieldBegin('uniqueHoudiniNodeId', TType.I32, 7)
            oprot.writeI32(self.uniqueHoudiniNodeId)
            oprot.writeFieldEnd()
        if self.internalNodePathSH is not None:
            oprot.writeFieldBegin('internalNodePathSH', TType.I32, 8)
            oprot.writeI32(self.internalNodePathSH)
            oprot.writeFieldEnd()
        if self.parmCount is not None:
            oprot.writeFieldBegin('parmCount', TType.I32, 9)
            oprot.writeI32(self.parmCount)
            oprot.writeFieldEnd()
        if self.parmIntValueCount is not None:
            oprot.writeFieldBegin('parmIntValueCount', TType.I32, 10)
            oprot.writeI32(self.parmIntValueCount)
            oprot.writeFieldEnd()
        if self.parmFloatValueCount is not None:
            oprot.writeFieldBegin('parmFloatValueCount', TType.I32, 11)
            oprot.writeI32(self.parmFloatValueCount)
            oprot.writeFieldEnd()
        if self.parmStringValueCount is not None:
            oprot.writeFieldBegin('parmStringValueCount', TType.I32, 12)
            oprot.writeI32(self.parmStringValueCount)
            oprot.writeFieldEnd()
        if self.parmChoiceCount is not None:
            oprot.writeFieldBegin('parmChoiceCount', TType.I32, 13)
            oprot.writeI32(self.parmChoiceCount)
            oprot.writeFieldEnd()
        if self.childNodeCount is not None:
            oprot.writeFieldBegin('childNodeCount', TType.I32, 14)
            oprot.writeI32(self.childNodeCount)
            oprot.writeFieldEnd()
        if self.inputCount is not None:
            oprot.writeFieldBegin('inputCount', TType.I32, 15)
            oprot.writeI32(self.inputCount)
            oprot.writeFieldEnd()
        if self.outputCount is not None:
            oprot.writeFieldBegin('outputCount', TType.I32, 16)
            oprot.writeI32(self.outputCount)
            oprot.writeFieldEnd()
        if self.createdPostAssetLoad is not None:
            oprot.writeFieldBegin('createdPostAssetLoad', TType.BOOL, 17)
            oprot.writeBool(self.createdPostAssetLoad)
            oprot.writeFieldEnd()
        if self.isTimeDependent is not None:
            oprot.writeFieldBegin('isTimeDependent', TType.BOOL, 18)
            oprot.writeBool(self.isTimeDependent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParmInfo(object):
    """
    Attributes:
     - id
     - parentId
     - childIndex
     - type
     - scriptType
     - typeInfoSH
     - permissions
     - tagCount
     - size
     - choiceListType
     - choiceCount
     - nameSH
     - labelSH
     - templateNameSH
     - helpSH
     - hasMin
     - hasMax
     - hasUIMin
     - hasUIMax
     - min
     - max
     - UIMin
     - UIMax
     - invisible
     - disabled
     - spare
     - joinNext
     - labelNone
     - intValuesIndex
     - floatValuesIndex
     - stringValuesIndex
     - choiceIndex
     - inputNodeType
     - inputNodeFlag
     - isChildOfMultiParm
     - instanceNum
     - instanceLength
     - instanceCount
     - instanceStartOffset
     - rampType
     - visibilityConditionSH
     - disabledConditionSH

    """


    def __init__(self, id=None, parentId=None, childIndex=None, type=None, scriptType=None, typeInfoSH=None, permissions=None, tagCount=None, size=None, choiceListType=None, choiceCount=None, nameSH=None, labelSH=None, templateNameSH=None, helpSH=None, hasMin=None, hasMax=None, hasUIMin=None, hasUIMax=None, min=None, max=None, UIMin=None, UIMax=None, invisible=None, disabled=None, spare=None, joinNext=None, labelNone=None, intValuesIndex=None, floatValuesIndex=None, stringValuesIndex=None, choiceIndex=None, inputNodeType=None, inputNodeFlag=None, isChildOfMultiParm=None, instanceNum=None, instanceLength=None, instanceCount=None, instanceStartOffset=None, rampType=None, visibilityConditionSH=None, disabledConditionSH=None,):
        self.id = id
        self.parentId = parentId
        self.childIndex = childIndex
        self.type = type
        self.scriptType = scriptType
        self.typeInfoSH = typeInfoSH
        self.permissions = permissions
        self.tagCount = tagCount
        self.size = size
        self.choiceListType = choiceListType
        self.choiceCount = choiceCount
        self.nameSH = nameSH
        self.labelSH = labelSH
        self.templateNameSH = templateNameSH
        self.helpSH = helpSH
        self.hasMin = hasMin
        self.hasMax = hasMax
        self.hasUIMin = hasUIMin
        self.hasUIMax = hasUIMax
        self.min = min
        self.max = max
        self.UIMin = UIMin
        self.UIMax = UIMax
        self.invisible = invisible
        self.disabled = disabled
        self.spare = spare
        self.joinNext = joinNext
        self.labelNone = labelNone
        self.intValuesIndex = intValuesIndex
        self.floatValuesIndex = floatValuesIndex
        self.stringValuesIndex = stringValuesIndex
        self.choiceIndex = choiceIndex
        self.inputNodeType = inputNodeType
        self.inputNodeFlag = inputNodeFlag
        self.isChildOfMultiParm = isChildOfMultiParm
        self.instanceNum = instanceNum
        self.instanceLength = instanceLength
        self.instanceCount = instanceCount
        self.instanceStartOffset = instanceStartOffset
        self.rampType = rampType
        self.visibilityConditionSH = visibilityConditionSH
        self.disabledConditionSH = disabledConditionSH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.childIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.scriptType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.typeInfoSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.permissions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.tagCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.choiceListType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.choiceCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.labelSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.templateNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.helpSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.hasMin = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.hasMax = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BOOL:
                    self.hasUIMin = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.hasUIMax = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.DOUBLE:
                    self.min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.DOUBLE:
                    self.max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.DOUBLE:
                    self.UIMin = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.DOUBLE:
                    self.UIMax = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.BOOL:
                    self.invisible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.BOOL:
                    self.disabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.BOOL:
                    self.spare = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.BOOL:
                    self.joinNext = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.BOOL:
                    self.labelNone = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.I32:
                    self.intValuesIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I32:
                    self.floatValuesIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.stringValuesIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I32:
                    self.choiceIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I32:
                    self.inputNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I32:
                    self.inputNodeFlag = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.BOOL:
                    self.isChildOfMultiParm = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.I32:
                    self.instanceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 37:
                if ftype == TType.I32:
                    self.instanceLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 38:
                if ftype == TType.I32:
                    self.instanceCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 39:
                if ftype == TType.I32:
                    self.instanceStartOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 40:
                if ftype == TType.I32:
                    self.rampType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 41:
                if ftype == TType.I32:
                    self.visibilityConditionSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 42:
                if ftype == TType.I32:
                    self.disabledConditionSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.parentId is not None:
            oprot.writeFieldBegin('parentId', TType.I32, 2)
            oprot.writeI32(self.parentId)
            oprot.writeFieldEnd()
        if self.childIndex is not None:
            oprot.writeFieldBegin('childIndex', TType.I32, 3)
            oprot.writeI32(self.childIndex)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.scriptType is not None:
            oprot.writeFieldBegin('scriptType', TType.I32, 5)
            oprot.writeI32(self.scriptType)
            oprot.writeFieldEnd()
        if self.typeInfoSH is not None:
            oprot.writeFieldBegin('typeInfoSH', TType.I32, 6)
            oprot.writeI32(self.typeInfoSH)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.I32, 7)
            oprot.writeI32(self.permissions)
            oprot.writeFieldEnd()
        if self.tagCount is not None:
            oprot.writeFieldBegin('tagCount', TType.I32, 8)
            oprot.writeI32(self.tagCount)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 9)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.choiceListType is not None:
            oprot.writeFieldBegin('choiceListType', TType.I32, 10)
            oprot.writeI32(self.choiceListType)
            oprot.writeFieldEnd()
        if self.choiceCount is not None:
            oprot.writeFieldBegin('choiceCount', TType.I32, 11)
            oprot.writeI32(self.choiceCount)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 12)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.labelSH is not None:
            oprot.writeFieldBegin('labelSH', TType.I32, 13)
            oprot.writeI32(self.labelSH)
            oprot.writeFieldEnd()
        if self.templateNameSH is not None:
            oprot.writeFieldBegin('templateNameSH', TType.I32, 14)
            oprot.writeI32(self.templateNameSH)
            oprot.writeFieldEnd()
        if self.helpSH is not None:
            oprot.writeFieldBegin('helpSH', TType.I32, 15)
            oprot.writeI32(self.helpSH)
            oprot.writeFieldEnd()
        if self.hasMin is not None:
            oprot.writeFieldBegin('hasMin', TType.BOOL, 16)
            oprot.writeBool(self.hasMin)
            oprot.writeFieldEnd()
        if self.hasMax is not None:
            oprot.writeFieldBegin('hasMax', TType.BOOL, 17)
            oprot.writeBool(self.hasMax)
            oprot.writeFieldEnd()
        if self.hasUIMin is not None:
            oprot.writeFieldBegin('hasUIMin', TType.BOOL, 18)
            oprot.writeBool(self.hasUIMin)
            oprot.writeFieldEnd()
        if self.hasUIMax is not None:
            oprot.writeFieldBegin('hasUIMax', TType.BOOL, 19)
            oprot.writeBool(self.hasUIMax)
            oprot.writeFieldEnd()
        if self.min is not None:
            oprot.writeFieldBegin('min', TType.DOUBLE, 20)
            oprot.writeDouble(self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.DOUBLE, 21)
            oprot.writeDouble(self.max)
            oprot.writeFieldEnd()
        if self.UIMin is not None:
            oprot.writeFieldBegin('UIMin', TType.DOUBLE, 22)
            oprot.writeDouble(self.UIMin)
            oprot.writeFieldEnd()
        if self.UIMax is not None:
            oprot.writeFieldBegin('UIMax', TType.DOUBLE, 23)
            oprot.writeDouble(self.UIMax)
            oprot.writeFieldEnd()
        if self.invisible is not None:
            oprot.writeFieldBegin('invisible', TType.BOOL, 24)
            oprot.writeBool(self.invisible)
            oprot.writeFieldEnd()
        if self.disabled is not None:
            oprot.writeFieldBegin('disabled', TType.BOOL, 25)
            oprot.writeBool(self.disabled)
            oprot.writeFieldEnd()
        if self.spare is not None:
            oprot.writeFieldBegin('spare', TType.BOOL, 26)
            oprot.writeBool(self.spare)
            oprot.writeFieldEnd()
        if self.joinNext is not None:
            oprot.writeFieldBegin('joinNext', TType.BOOL, 27)
            oprot.writeBool(self.joinNext)
            oprot.writeFieldEnd()
        if self.labelNone is not None:
            oprot.writeFieldBegin('labelNone', TType.BOOL, 28)
            oprot.writeBool(self.labelNone)
            oprot.writeFieldEnd()
        if self.intValuesIndex is not None:
            oprot.writeFieldBegin('intValuesIndex', TType.I32, 29)
            oprot.writeI32(self.intValuesIndex)
            oprot.writeFieldEnd()
        if self.floatValuesIndex is not None:
            oprot.writeFieldBegin('floatValuesIndex', TType.I32, 30)
            oprot.writeI32(self.floatValuesIndex)
            oprot.writeFieldEnd()
        if self.stringValuesIndex is not None:
            oprot.writeFieldBegin('stringValuesIndex', TType.I32, 31)
            oprot.writeI32(self.stringValuesIndex)
            oprot.writeFieldEnd()
        if self.choiceIndex is not None:
            oprot.writeFieldBegin('choiceIndex', TType.I32, 32)
            oprot.writeI32(self.choiceIndex)
            oprot.writeFieldEnd()
        if self.inputNodeType is not None:
            oprot.writeFieldBegin('inputNodeType', TType.I32, 33)
            oprot.writeI32(self.inputNodeType)
            oprot.writeFieldEnd()
        if self.inputNodeFlag is not None:
            oprot.writeFieldBegin('inputNodeFlag', TType.I32, 34)
            oprot.writeI32(self.inputNodeFlag)
            oprot.writeFieldEnd()
        if self.isChildOfMultiParm is not None:
            oprot.writeFieldBegin('isChildOfMultiParm', TType.BOOL, 35)
            oprot.writeBool(self.isChildOfMultiParm)
            oprot.writeFieldEnd()
        if self.instanceNum is not None:
            oprot.writeFieldBegin('instanceNum', TType.I32, 36)
            oprot.writeI32(self.instanceNum)
            oprot.writeFieldEnd()
        if self.instanceLength is not None:
            oprot.writeFieldBegin('instanceLength', TType.I32, 37)
            oprot.writeI32(self.instanceLength)
            oprot.writeFieldEnd()
        if self.instanceCount is not None:
            oprot.writeFieldBegin('instanceCount', TType.I32, 38)
            oprot.writeI32(self.instanceCount)
            oprot.writeFieldEnd()
        if self.instanceStartOffset is not None:
            oprot.writeFieldBegin('instanceStartOffset', TType.I32, 39)
            oprot.writeI32(self.instanceStartOffset)
            oprot.writeFieldEnd()
        if self.rampType is not None:
            oprot.writeFieldBegin('rampType', TType.I32, 40)
            oprot.writeI32(self.rampType)
            oprot.writeFieldEnd()
        if self.visibilityConditionSH is not None:
            oprot.writeFieldBegin('visibilityConditionSH', TType.I32, 41)
            oprot.writeI32(self.visibilityConditionSH)
            oprot.writeFieldEnd()
        if self.disabledConditionSH is not None:
            oprot.writeFieldBegin('disabledConditionSH', TType.I32, 42)
            oprot.writeI32(self.disabledConditionSH)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParmChoiceInfo(object):
    """
    Attributes:
     - parentParmId
     - labelSH
     - valueSH

    """


    def __init__(self, parentParmId=None, labelSH=None, valueSH=None,):
        self.parentParmId = parentParmId
        self.labelSH = labelSH
        self.valueSH = valueSH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parentParmId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.labelSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.valueSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmChoiceInfo')
        if self.parentParmId is not None:
            oprot.writeFieldBegin('parentParmId', TType.I32, 1)
            oprot.writeI32(self.parentParmId)
            oprot.writeFieldEnd()
        if self.labelSH is not None:
            oprot.writeFieldBegin('labelSH', TType.I32, 2)
            oprot.writeI32(self.labelSH)
            oprot.writeFieldEnd()
        if self.valueSH is not None:
            oprot.writeFieldBegin('valueSH', TType.I32, 3)
            oprot.writeI32(self.valueSH)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HandleInfo(object):
    """
    Attributes:
     - nameSH
     - typeNameSH
     - bindingsCount

    """


    def __init__(self, nameSH=None, typeNameSH=None, bindingsCount=None,):
        self.nameSH = nameSH
        self.typeNameSH = typeNameSH
        self.bindingsCount = bindingsCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.typeNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.bindingsCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HandleInfo')
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 1)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.typeNameSH is not None:
            oprot.writeFieldBegin('typeNameSH', TType.I32, 2)
            oprot.writeI32(self.typeNameSH)
            oprot.writeFieldEnd()
        if self.bindingsCount is not None:
            oprot.writeFieldBegin('bindingsCount', TType.I32, 3)
            oprot.writeI32(self.bindingsCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HandleBindingInfo(object):
    """
    Attributes:
     - handleParmNameSH
     - assetParmNameSH
     - assetParmId
     - assetParmIndex

    """


    def __init__(self, handleParmNameSH=None, assetParmNameSH=None, assetParmId=None, assetParmIndex=None,):
        self.handleParmNameSH = handleParmNameSH
        self.assetParmNameSH = assetParmNameSH
        self.assetParmId = assetParmId
        self.assetParmIndex = assetParmIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handleParmNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.assetParmNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.assetParmId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.assetParmIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HandleBindingInfo')
        if self.handleParmNameSH is not None:
            oprot.writeFieldBegin('handleParmNameSH', TType.I32, 1)
            oprot.writeI32(self.handleParmNameSH)
            oprot.writeFieldEnd()
        if self.assetParmNameSH is not None:
            oprot.writeFieldBegin('assetParmNameSH', TType.I32, 2)
            oprot.writeI32(self.assetParmNameSH)
            oprot.writeFieldEnd()
        if self.assetParmId is not None:
            oprot.writeFieldBegin('assetParmId', TType.I32, 3)
            oprot.writeI32(self.assetParmId)
            oprot.writeFieldEnd()
        if self.assetParmIndex is not None:
            oprot.writeFieldBegin('assetParmIndex', TType.I32, 4)
            oprot.writeI32(self.assetParmIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ObjectInfo(object):
    """
    Attributes:
     - nameSH
     - objectInstancePathSH
     - hasTransformChanged
     - haveGeosChanged
     - isVisible
     - isInstancer
     - isInstanced
     - geoCount
     - nodeId
     - objectToInstanceId

    """


    def __init__(self, nameSH=None, objectInstancePathSH=None, hasTransformChanged=None, haveGeosChanged=None, isVisible=None, isInstancer=None, isInstanced=None, geoCount=None, nodeId=None, objectToInstanceId=None,):
        self.nameSH = nameSH
        self.objectInstancePathSH = objectInstancePathSH
        self.hasTransformChanged = hasTransformChanged
        self.haveGeosChanged = haveGeosChanged
        self.isVisible = isVisible
        self.isInstancer = isInstancer
        self.isInstanced = isInstanced
        self.geoCount = geoCount
        self.nodeId = nodeId
        self.objectToInstanceId = objectToInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.objectInstancePathSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasTransformChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.haveGeosChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isVisible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isInstancer = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isInstanced = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.geoCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.objectToInstanceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ObjectInfo')
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 1)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.objectInstancePathSH is not None:
            oprot.writeFieldBegin('objectInstancePathSH', TType.I32, 2)
            oprot.writeI32(self.objectInstancePathSH)
            oprot.writeFieldEnd()
        if self.hasTransformChanged is not None:
            oprot.writeFieldBegin('hasTransformChanged', TType.BOOL, 3)
            oprot.writeBool(self.hasTransformChanged)
            oprot.writeFieldEnd()
        if self.haveGeosChanged is not None:
            oprot.writeFieldBegin('haveGeosChanged', TType.BOOL, 4)
            oprot.writeBool(self.haveGeosChanged)
            oprot.writeFieldEnd()
        if self.isVisible is not None:
            oprot.writeFieldBegin('isVisible', TType.BOOL, 5)
            oprot.writeBool(self.isVisible)
            oprot.writeFieldEnd()
        if self.isInstancer is not None:
            oprot.writeFieldBegin('isInstancer', TType.BOOL, 6)
            oprot.writeBool(self.isInstancer)
            oprot.writeFieldEnd()
        if self.isInstanced is not None:
            oprot.writeFieldBegin('isInstanced', TType.BOOL, 7)
            oprot.writeBool(self.isInstanced)
            oprot.writeFieldEnd()
        if self.geoCount is not None:
            oprot.writeFieldBegin('geoCount', TType.I32, 8)
            oprot.writeI32(self.geoCount)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 9)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        if self.objectToInstanceId is not None:
            oprot.writeFieldBegin('objectToInstanceId', TType.I32, 10)
            oprot.writeI32(self.objectToInstanceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GeoInfo(object):
    """
    Attributes:
     - type
     - nameSH
     - nodeId
     - isEditable
     - isTemplated
     - isDisplayGeo
     - hasGeoChanged
     - hasMaterialChanged
     - pointGroupCount
     - primitiveGroupCount
     - partCount

    """


    def __init__(self, type=None, nameSH=None, nodeId=None, isEditable=None, isTemplated=None, isDisplayGeo=None, hasGeoChanged=None, hasMaterialChanged=None, pointGroupCount=None, primitiveGroupCount=None, partCount=None,):
        self.type = type
        self.nameSH = nameSH
        self.nodeId = nodeId
        self.isEditable = isEditable
        self.isTemplated = isTemplated
        self.isDisplayGeo = isDisplayGeo
        self.hasGeoChanged = hasGeoChanged
        self.hasMaterialChanged = hasMaterialChanged
        self.pointGroupCount = pointGroupCount
        self.primitiveGroupCount = primitiveGroupCount
        self.partCount = partCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isEditable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isTemplated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isDisplayGeo = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasGeoChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.hasMaterialChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.pointGroupCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.primitiveGroupCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.partCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GeoInfo')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 2)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 3)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        if self.isEditable is not None:
            oprot.writeFieldBegin('isEditable', TType.BOOL, 4)
            oprot.writeBool(self.isEditable)
            oprot.writeFieldEnd()
        if self.isTemplated is not None:
            oprot.writeFieldBegin('isTemplated', TType.BOOL, 5)
            oprot.writeBool(self.isTemplated)
            oprot.writeFieldEnd()
        if self.isDisplayGeo is not None:
            oprot.writeFieldBegin('isDisplayGeo', TType.BOOL, 6)
            oprot.writeBool(self.isDisplayGeo)
            oprot.writeFieldEnd()
        if self.hasGeoChanged is not None:
            oprot.writeFieldBegin('hasGeoChanged', TType.BOOL, 7)
            oprot.writeBool(self.hasGeoChanged)
            oprot.writeFieldEnd()
        if self.hasMaterialChanged is not None:
            oprot.writeFieldBegin('hasMaterialChanged', TType.BOOL, 8)
            oprot.writeBool(self.hasMaterialChanged)
            oprot.writeFieldEnd()
        if self.pointGroupCount is not None:
            oprot.writeFieldBegin('pointGroupCount', TType.I32, 9)
            oprot.writeI32(self.pointGroupCount)
            oprot.writeFieldEnd()
        if self.primitiveGroupCount is not None:
            oprot.writeFieldBegin('primitiveGroupCount', TType.I32, 10)
            oprot.writeI32(self.primitiveGroupCount)
            oprot.writeFieldEnd()
        if self.partCount is not None:
            oprot.writeFieldBegin('partCount', TType.I32, 11)
            oprot.writeI32(self.partCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartInfo(object):
    """
    Attributes:
     - id
     - nameSH
     - type
     - faceCount
     - vertexCount
     - pointCount
     - attributeCounts
     - isInstanced
     - instancedPartCount
     - instanceCount
     - hasChanged

    """


    def __init__(self, id=None, nameSH=None, type=None, faceCount=None, vertexCount=None, pointCount=None, attributeCounts=None, isInstanced=None, instancedPartCount=None, instanceCount=None, hasChanged=None,):
        self.id = id
        self.nameSH = nameSH
        self.type = type
        self.faceCount = faceCount
        self.vertexCount = vertexCount
        self.pointCount = pointCount
        self.attributeCounts = attributeCounts
        self.isInstanced = isInstanced
        self.instancedPartCount = instancedPartCount
        self.instanceCount = instanceCount
        self.hasChanged = hasChanged

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.faceCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.vertexCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.pointCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.attributeCounts = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI32()
                        self.attributeCounts.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isInstanced = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.instancedPartCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.instanceCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.hasChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 2)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.faceCount is not None:
            oprot.writeFieldBegin('faceCount', TType.I32, 4)
            oprot.writeI32(self.faceCount)
            oprot.writeFieldEnd()
        if self.vertexCount is not None:
            oprot.writeFieldBegin('vertexCount', TType.I32, 5)
            oprot.writeI32(self.vertexCount)
            oprot.writeFieldEnd()
        if self.pointCount is not None:
            oprot.writeFieldBegin('pointCount', TType.I32, 6)
            oprot.writeI32(self.pointCount)
            oprot.writeFieldEnd()
        if self.attributeCounts is not None:
            oprot.writeFieldBegin('attributeCounts', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.attributeCounts))
            for iter62 in self.attributeCounts:
                oprot.writeI32(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isInstanced is not None:
            oprot.writeFieldBegin('isInstanced', TType.BOOL, 8)
            oprot.writeBool(self.isInstanced)
            oprot.writeFieldEnd()
        if self.instancedPartCount is not None:
            oprot.writeFieldBegin('instancedPartCount', TType.I32, 9)
            oprot.writeI32(self.instancedPartCount)
            oprot.writeFieldEnd()
        if self.instanceCount is not None:
            oprot.writeFieldBegin('instanceCount', TType.I32, 10)
            oprot.writeI32(self.instanceCount)
            oprot.writeFieldEnd()
        if self.hasChanged is not None:
            oprot.writeFieldBegin('hasChanged', TType.BOOL, 11)
            oprot.writeBool(self.hasChanged)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AttributeInfo(object):
    """
    Attributes:
     - exists
     - owner
     - storage
     - originalOwner
     - count
     - tupleSize
     - typeInfo

    """


    def __init__(self, exists=None, owner=None, storage=None, originalOwner=None, count=None, tupleSize=None, typeInfo=None,):
        self.exists = exists
        self.owner = owner
        self.storage = storage
        self.originalOwner = originalOwner
        self.count = count
        self.tupleSize = tupleSize
        self.typeInfo = typeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.owner = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.storage = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.originalOwner = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.tupleSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.typeInfo = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AttributeInfo')
        if self.exists is not None:
            oprot.writeFieldBegin('exists', TType.BOOL, 1)
            oprot.writeBool(self.exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.I32, 2)
            oprot.writeI32(self.owner)
            oprot.writeFieldEnd()
        if self.storage is not None:
            oprot.writeFieldBegin('storage', TType.I32, 3)
            oprot.writeI32(self.storage)
            oprot.writeFieldEnd()
        if self.originalOwner is not None:
            oprot.writeFieldBegin('originalOwner', TType.I32, 4)
            oprot.writeI32(self.originalOwner)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 5)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.tupleSize is not None:
            oprot.writeFieldBegin('tupleSize', TType.I32, 6)
            oprot.writeI32(self.tupleSize)
            oprot.writeFieldEnd()
        if self.typeInfo is not None:
            oprot.writeFieldBegin('typeInfo', TType.I32, 7)
            oprot.writeI32(self.typeInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MaterialInfo(object):
    """
    Attributes:
     - nodeId
     - exists
     - hasChanged

    """


    def __init__(self, nodeId=None, exists=None, hasChanged=None,):
        self.nodeId = nodeId
        self.exists = exists
        self.hasChanged = hasChanged

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasChanged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MaterialInfo')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 1)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        if self.exists is not None:
            oprot.writeFieldBegin('exists', TType.BOOL, 2)
            oprot.writeBool(self.exists)
            oprot.writeFieldEnd()
        if self.hasChanged is not None:
            oprot.writeFieldBegin('hasChanged', TType.BOOL, 3)
            oprot.writeBool(self.hasChanged)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImageFileFormat(object):
    """
    Attributes:
     - nameSH
     - descriptionSH
     - defaultExtensionSH

    """


    def __init__(self, nameSH=None, descriptionSH=None, defaultExtensionSH=None,):
        self.nameSH = nameSH
        self.descriptionSH = descriptionSH
        self.defaultExtensionSH = defaultExtensionSH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.descriptionSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.defaultExtensionSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ImageFileFormat')
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 1)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.descriptionSH is not None:
            oprot.writeFieldBegin('descriptionSH', TType.I32, 2)
            oprot.writeI32(self.descriptionSH)
            oprot.writeFieldEnd()
        if self.defaultExtensionSH is not None:
            oprot.writeFieldBegin('defaultExtensionSH', TType.I32, 3)
            oprot.writeI32(self.defaultExtensionSH)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImageInfo(object):
    """
    Attributes:
     - imageFileFormatNameSH
     - xRes
     - yRes
     - dataFormat
     - interleaved
     - packing
     - gamma

    """


    def __init__(self, imageFileFormatNameSH=None, xRes=None, yRes=None, dataFormat=None, interleaved=None, packing=None, gamma=None,):
        self.imageFileFormatNameSH = imageFileFormatNameSH
        self.xRes = xRes
        self.yRes = yRes
        self.dataFormat = dataFormat
        self.interleaved = interleaved
        self.packing = packing
        self.gamma = gamma

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.imageFileFormatNameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.xRes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.yRes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataFormat = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.interleaved = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.packing = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.gamma = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ImageInfo')
        if self.imageFileFormatNameSH is not None:
            oprot.writeFieldBegin('imageFileFormatNameSH', TType.I32, 1)
            oprot.writeI32(self.imageFileFormatNameSH)
            oprot.writeFieldEnd()
        if self.xRes is not None:
            oprot.writeFieldBegin('xRes', TType.I32, 2)
            oprot.writeI32(self.xRes)
            oprot.writeFieldEnd()
        if self.yRes is not None:
            oprot.writeFieldBegin('yRes', TType.I32, 3)
            oprot.writeI32(self.yRes)
            oprot.writeFieldEnd()
        if self.dataFormat is not None:
            oprot.writeFieldBegin('dataFormat', TType.I32, 4)
            oprot.writeI32(self.dataFormat)
            oprot.writeFieldEnd()
        if self.interleaved is not None:
            oprot.writeFieldBegin('interleaved', TType.BOOL, 5)
            oprot.writeBool(self.interleaved)
            oprot.writeFieldEnd()
        if self.packing is not None:
            oprot.writeFieldBegin('packing', TType.I32, 6)
            oprot.writeI32(self.packing)
            oprot.writeFieldEnd()
        if self.gamma is not None:
            oprot.writeFieldBegin('gamma', TType.DOUBLE, 7)
            oprot.writeDouble(self.gamma)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Keyframe(object):
    """
    Attributes:
     - time
     - value
     - inTangent
     - outTangent

    """


    def __init__(self, time=None, value=None, inTangent=None, outTangent=None,):
        self.time = time
        self.value = value
        self.inTangent = inTangent
        self.outTangent = outTangent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.inTangent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.outTangent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Keyframe')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.DOUBLE, 1)
            oprot.writeDouble(self.time)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        if self.inTangent is not None:
            oprot.writeFieldBegin('inTangent', TType.DOUBLE, 3)
            oprot.writeDouble(self.inTangent)
            oprot.writeFieldEnd()
        if self.outTangent is not None:
            oprot.writeFieldBegin('outTangent', TType.DOUBLE, 4)
            oprot.writeDouble(self.outTangent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VolumeInfo(object):
    """
    Attributes:
     - nameSH
     - type
     - xLength
     - yLength
     - zLength
     - minX
     - minY
     - minZ
     - tupleSize
     - storage
     - tileSize
     - transform
     - hasTaper
     - xTaper
     - yTaper

    """


    def __init__(self, nameSH=None, type=None, xLength=None, yLength=None, zLength=None, minX=None, minY=None, minZ=None, tupleSize=None, storage=None, tileSize=None, transform=None, hasTaper=None, xTaper=None, yTaper=None,):
        self.nameSH = nameSH
        self.type = type
        self.xLength = xLength
        self.yLength = yLength
        self.zLength = zLength
        self.minX = minX
        self.minY = minY
        self.minZ = minZ
        self.tupleSize = tupleSize
        self.storage = storage
        self.tileSize = tileSize
        self.transform = transform
        self.hasTaper = hasTaper
        self.xTaper = xTaper
        self.yTaper = yTaper

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.xLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.yLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.zLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.minX = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.minY = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.minZ = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.tupleSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.storage = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.tileSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.transform = Transform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.hasTaper = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.xTaper = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.DOUBLE:
                    self.yTaper = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VolumeInfo')
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 1)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.xLength is not None:
            oprot.writeFieldBegin('xLength', TType.I32, 3)
            oprot.writeI32(self.xLength)
            oprot.writeFieldEnd()
        if self.yLength is not None:
            oprot.writeFieldBegin('yLength', TType.I32, 4)
            oprot.writeI32(self.yLength)
            oprot.writeFieldEnd()
        if self.zLength is not None:
            oprot.writeFieldBegin('zLength', TType.I32, 5)
            oprot.writeI32(self.zLength)
            oprot.writeFieldEnd()
        if self.minX is not None:
            oprot.writeFieldBegin('minX', TType.I32, 6)
            oprot.writeI32(self.minX)
            oprot.writeFieldEnd()
        if self.minY is not None:
            oprot.writeFieldBegin('minY', TType.I32, 7)
            oprot.writeI32(self.minY)
            oprot.writeFieldEnd()
        if self.minZ is not None:
            oprot.writeFieldBegin('minZ', TType.I32, 8)
            oprot.writeI32(self.minZ)
            oprot.writeFieldEnd()
        if self.tupleSize is not None:
            oprot.writeFieldBegin('tupleSize', TType.I32, 9)
            oprot.writeI32(self.tupleSize)
            oprot.writeFieldEnd()
        if self.storage is not None:
            oprot.writeFieldBegin('storage', TType.I32, 10)
            oprot.writeI32(self.storage)
            oprot.writeFieldEnd()
        if self.tileSize is not None:
            oprot.writeFieldBegin('tileSize', TType.I32, 11)
            oprot.writeI32(self.tileSize)
            oprot.writeFieldEnd()
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 12)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.hasTaper is not None:
            oprot.writeFieldBegin('hasTaper', TType.BOOL, 13)
            oprot.writeBool(self.hasTaper)
            oprot.writeFieldEnd()
        if self.xTaper is not None:
            oprot.writeFieldBegin('xTaper', TType.DOUBLE, 14)
            oprot.writeDouble(self.xTaper)
            oprot.writeFieldEnd()
        if self.yTaper is not None:
            oprot.writeFieldBegin('yTaper', TType.DOUBLE, 15)
            oprot.writeDouble(self.yTaper)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VolumeTileInfo(object):
    """
    Attributes:
     - minX
     - minY
     - minZ
     - isValid

    """


    def __init__(self, minX=None, minY=None, minZ=None, isValid=None,):
        self.minX = minX
        self.minY = minY
        self.minZ = minZ
        self.isValid = isValid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minX = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.minY = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.minZ = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isValid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VolumeTileInfo')
        if self.minX is not None:
            oprot.writeFieldBegin('minX', TType.I32, 1)
            oprot.writeI32(self.minX)
            oprot.writeFieldEnd()
        if self.minY is not None:
            oprot.writeFieldBegin('minY', TType.I32, 2)
            oprot.writeI32(self.minY)
            oprot.writeFieldEnd()
        if self.minZ is not None:
            oprot.writeFieldBegin('minZ', TType.I32, 3)
            oprot.writeI32(self.minZ)
            oprot.writeFieldEnd()
        if self.isValid is not None:
            oprot.writeFieldBegin('isValid', TType.BOOL, 4)
            oprot.writeBool(self.isValid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurveInfo(object):
    """
    Attributes:
     - curveType
     - curveCount
     - vertexCount
     - knotCount
     - isPeriodic
     - isRational
     - order
     - hasKnots

    """


    def __init__(self, curveType=None, curveCount=None, vertexCount=None, knotCount=None, isPeriodic=None, isRational=None, order=None, hasKnots=None,):
        self.curveType = curveType
        self.curveCount = curveCount
        self.vertexCount = vertexCount
        self.knotCount = knotCount
        self.isPeriodic = isPeriodic
        self.isRational = isRational
        self.order = order
        self.hasKnots = hasKnots

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.curveType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.curveCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.vertexCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.knotCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isPeriodic = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isRational = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.hasKnots = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurveInfo')
        if self.curveType is not None:
            oprot.writeFieldBegin('curveType', TType.I32, 1)
            oprot.writeI32(self.curveType)
            oprot.writeFieldEnd()
        if self.curveCount is not None:
            oprot.writeFieldBegin('curveCount', TType.I32, 2)
            oprot.writeI32(self.curveCount)
            oprot.writeFieldEnd()
        if self.vertexCount is not None:
            oprot.writeFieldBegin('vertexCount', TType.I32, 3)
            oprot.writeI32(self.vertexCount)
            oprot.writeFieldEnd()
        if self.knotCount is not None:
            oprot.writeFieldBegin('knotCount', TType.I32, 4)
            oprot.writeI32(self.knotCount)
            oprot.writeFieldEnd()
        if self.isPeriodic is not None:
            oprot.writeFieldBegin('isPeriodic', TType.BOOL, 5)
            oprot.writeBool(self.isPeriodic)
            oprot.writeFieldEnd()
        if self.isRational is not None:
            oprot.writeFieldBegin('isRational', TType.BOOL, 6)
            oprot.writeBool(self.isRational)
            oprot.writeFieldEnd()
        if self.order is not None:
            oprot.writeFieldBegin('order', TType.I32, 7)
            oprot.writeI32(self.order)
            oprot.writeFieldEnd()
        if self.hasKnots is not None:
            oprot.writeFieldBegin('hasKnots', TType.BOOL, 8)
            oprot.writeBool(self.hasKnots)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BoxInfo(object):
    """
    Attributes:
     - center
     - size
     - rotation

    """


    def __init__(self, center=None, size=None, rotation=None,):
        self.center = center
        self.size = size
        self.rotation = rotation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.center = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readDouble()
                        self.center.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.size = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = iprot.readDouble()
                        self.size.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rotation = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = iprot.readDouble()
                        self.rotation.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BoxInfo')
        if self.center is not None:
            oprot.writeFieldBegin('center', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.center))
            for iter81 in self.center:
                oprot.writeDouble(iter81)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.size))
            for iter82 in self.size:
                oprot.writeDouble(iter82)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotation is not None:
            oprot.writeFieldBegin('rotation', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.rotation))
            for iter83 in self.rotation:
                oprot.writeDouble(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SphereInfo(object):
    """
    Attributes:
     - center
     - radius

    """


    def __init__(self, center=None, radius=None,):
        self.center = center
        self.radius = radius

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.center = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readDouble()
                        self.center.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.radius = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SphereInfo')
        if self.center is not None:
            oprot.writeFieldBegin('center', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.center))
            for iter90 in self.center:
                oprot.writeDouble(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.radius is not None:
            oprot.writeFieldBegin('radius', TType.DOUBLE, 2)
            oprot.writeDouble(self.radius)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PDG_EventInfo(object):
    """
    Attributes:
     - nodeId
     - workitemId
     - dependencyId
     - currentState
     - lastState
     - eventType
     - msgSH

    """


    def __init__(self, nodeId=None, workitemId=None, dependencyId=None, currentState=None, lastState=None, eventType=None, msgSH=None,):
        self.nodeId = nodeId
        self.workitemId = workitemId
        self.dependencyId = dependencyId
        self.currentState = currentState
        self.lastState = lastState
        self.eventType = eventType
        self.msgSH = msgSH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitemId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dependencyId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.currentState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.lastState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.msgSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PDG_EventInfo')
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 1)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        if self.workitemId is not None:
            oprot.writeFieldBegin('workitemId', TType.I32, 2)
            oprot.writeI32(self.workitemId)
            oprot.writeFieldEnd()
        if self.dependencyId is not None:
            oprot.writeFieldBegin('dependencyId', TType.I32, 3)
            oprot.writeI32(self.dependencyId)
            oprot.writeFieldEnd()
        if self.currentState is not None:
            oprot.writeFieldBegin('currentState', TType.I32, 4)
            oprot.writeI32(self.currentState)
            oprot.writeFieldEnd()
        if self.lastState is not None:
            oprot.writeFieldBegin('lastState', TType.I32, 5)
            oprot.writeI32(self.lastState)
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.I32, 6)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        if self.msgSH is not None:
            oprot.writeFieldBegin('msgSH', TType.I32, 7)
            oprot.writeI32(self.msgSH)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PDG_WorkitemInfo(object):
    """
    Attributes:
     - index
     - numResults
     - nameSH

    """


    def __init__(self, index=None, numResults=None, nameSH=None,):
        self.index = index
        self.numResults = numResults
        self.nameSH = nameSH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.numResults = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.nameSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PDG_WorkitemInfo')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.numResults is not None:
            oprot.writeFieldBegin('numResults', TType.I32, 2)
            oprot.writeI32(self.numResults)
            oprot.writeFieldEnd()
        if self.nameSH is not None:
            oprot.writeFieldBegin('nameSH', TType.I32, 3)
            oprot.writeI32(self.nameSH)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PDG_WorkitemResultInfo(object):
    """
    Attributes:
     - resultSH
     - resultTagSH
     - resultHash

    """


    def __init__(self, resultSH=None, resultTagSH=None, resultHash=None,):
        self.resultSH = resultSH
        self.resultTagSH = resultTagSH
        self.resultHash = resultHash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.resultSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.resultTagSH = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.resultHash = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PDG_WorkitemResultInfo')
        if self.resultSH is not None:
            oprot.writeFieldBegin('resultSH', TType.I32, 1)
            oprot.writeI32(self.resultSH)
            oprot.writeFieldEnd()
        if self.resultTagSH is not None:
            oprot.writeFieldBegin('resultTagSH', TType.I32, 2)
            oprot.writeI32(self.resultTagSH)
            oprot.writeFieldEnd()
        if self.resultHash is not None:
            oprot.writeFieldBegin('resultHash', TType.I64, 3)
            oprot.writeI64(self.resultHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Viewport(object):
    """
    Attributes:
     - position
     - rotationQuaternion
     - offset

    """


    def __init__(self, position=None, rotationQuaternion=None, offset=None,):
        self.position = position
        self.rotationQuaternion = rotationQuaternion
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.position = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readDouble()
                        self.position.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.rotationQuaternion = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = iprot.readDouble()
                        self.rotationQuaternion.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.offset = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Viewport')
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.position))
            for iter103 in self.position:
                oprot.writeDouble(iter103)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rotationQuaternion is not None:
            oprot.writeFieldBegin('rotationQuaternion', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.rotationQuaternion))
            for iter104 in self.rotationQuaternion:
                oprot.writeDouble(iter104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.DOUBLE, 3)
            oprot.writeDouble(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SessionSyncInfo(object):
    """
    Attributes:
     - cookUsingHoudiniTime
     - syncViewport

    """


    def __init__(self, cookUsingHoudiniTime=None, syncViewport=None,):
        self.cookUsingHoudiniTime = cookUsingHoudiniTime
        self.syncViewport = syncViewport

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.cookUsingHoudiniTime = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.syncViewport = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SessionSyncInfo')
        if self.cookUsingHoudiniTime is not None:
            oprot.writeFieldBegin('cookUsingHoudiniTime', TType.BOOL, 1)
            oprot.writeBool(self.cookUsingHoudiniTime)
            oprot.writeFieldEnd()
        if self.syncViewport is not None:
            oprot.writeFieldBegin('syncViewport', TType.BOOL, 2)
            oprot.writeBool(self.syncViewport)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetSessionEnvInt_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionEnvInt_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetServerEnvInt_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvInt_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetServerEnvString_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvString_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetServerEnvVarCount_Out(object):
    """
    Attributes:
     - result
     - env_count

    """


    def __init__(self, result=None, env_count=None,):
        self.result = result
        self.env_count = env_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.env_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.env_count is not None:
            oprot.writeFieldBegin('env_count', TType.I32, 2)
            oprot.writeI32(self.env_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetServerEnvVarList_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readI32()
                        self.values_array.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter111 in self.values_array:
                oprot.writeI32(iter111)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStatus_Out(object):
    """
    Attributes:
     - result
     - status

    """


    def __init__(self, result=None, status=None,):
        self.result = result
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatus_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStatusStringBufLength_Out(object):
    """
    Attributes:
     - result
     - buffer_length

    """


    def __init__(self, result=None, buffer_length=None,):
        self.result = result
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusStringBufLength_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 2)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStatusString_Out(object):
    """
    Attributes:
     - result
     - string_value

    """


    def __init__(self, result=None, string_value=None,):
        self.result = result
        self.string_value = string_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusString_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 2)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ComposeNodeCookResult_Out(object):
    """
    Attributes:
     - result
     - buffer_length

    """


    def __init__(self, result=None, buffer_length=None,):
        self.result = result
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeNodeCookResult_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 2)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetComposedNodeCookResult_Out(object):
    """
    Attributes:
     - result
     - string_value

    """


    def __init__(self, result=None, string_value=None,):
        self.result = result
        self.string_value = string_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedNodeCookResult_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 2)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CheckForSpecificErrors_Out(object):
    """
    Attributes:
     - result
     - errors_found

    """


    def __init__(self, result=None, errors_found=None,):
        self.result = result
        self.errors_found = errors_found

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.errors_found = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckForSpecificErrors_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.errors_found is not None:
            oprot.writeFieldBegin('errors_found', TType.I32, 2)
            oprot.writeI32(self.errors_found)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCookingTotalCount_Out(object):
    """
    Attributes:
     - result
     - count

    """


    def __init__(self, result=None, count=None,):
        self.result = result
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingTotalCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCookingCurrentCount_Out(object):
    """
    Attributes:
     - result
     - count

    """


    def __init__(self, result=None, count=None,):
        self.result = result
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingCurrentCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConvertTransform_Out(object):
    """
    Attributes:
     - result
     - transform_out

    """


    def __init__(self, result=None, transform_out=None,):
        self.result = result
        self.transform_out = transform_out

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transform_out = TransformEuler()
                    self.transform_out.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransform_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transform_out is not None:
            oprot.writeFieldBegin('transform_out', TType.STRUCT, 2)
            self.transform_out.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConvertMatrixToQuat_Out(object):
    """
    Attributes:
     - result
     - transform_out

    """


    def __init__(self, result=None, transform_out=None,):
        self.result = result
        self.transform_out = transform_out

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transform_out = Transform()
                    self.transform_out.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToQuat_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transform_out is not None:
            oprot.writeFieldBegin('transform_out', TType.STRUCT, 2)
            self.transform_out.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConvertMatrixToEuler_Out(object):
    """
    Attributes:
     - result
     - transform_out

    """


    def __init__(self, result=None, transform_out=None,):
        self.result = result
        self.transform_out = transform_out

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transform_out = TransformEuler()
                    self.transform_out.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToEuler_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transform_out is not None:
            oprot.writeFieldBegin('transform_out', TType.STRUCT, 2)
            self.transform_out.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConvertTransformQuatToMatrix_Out(object):
    """
    Attributes:
     - result
     - matrix

    """


    def __init__(self, result=None, matrix=None,):
        self.result = result
        self.matrix = matrix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matrix = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = iprot.readDouble()
                        self.matrix.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformQuatToMatrix_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.matrix is not None:
            oprot.writeFieldBegin('matrix', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.matrix))
            for iter118 in self.matrix:
                oprot.writeDouble(iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConvertTransformEulerToMatrix_Out(object):
    """
    Attributes:
     - result
     - matrix

    """


    def __init__(self, result=None, matrix=None,):
        self.result = result
        self.matrix = matrix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matrix = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readDouble()
                        self.matrix.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformEulerToMatrix_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.matrix is not None:
            oprot.writeFieldBegin('matrix', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.matrix))
            for iter125 in self.matrix:
                oprot.writeDouble(iter125)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStringBufLength_Out(object):
    """
    Attributes:
     - result
     - buffer_length

    """


    def __init__(self, result=None, buffer_length=None,):
        self.result = result
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBufLength_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 2)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetString_Out(object):
    """
    Attributes:
     - result
     - string_value

    """


    def __init__(self, result=None, string_value=None,):
        self.result = result
        self.string_value = string_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetString_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 2)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetCustomString_Out(object):
    """
    Attributes:
     - result
     - handle_value

    """


    def __init__(self, result=None, handle_value=None,):
        self.result = result
        self.handle_value = handle_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.handle_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCustomString_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.handle_value is not None:
            oprot.writeFieldBegin('handle_value', TType.I32, 2)
            oprot.writeI32(self.handle_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStringBatchSize_Out(object):
    """
    Attributes:
     - result
     - string_buffer_size

    """


    def __init__(self, result=None, string_buffer_size=None,):
        self.result = result
        self.string_buffer_size = string_buffer_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.string_buffer_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatchSize_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.string_buffer_size is not None:
            oprot.writeFieldBegin('string_buffer_size', TType.I32, 2)
            oprot.writeI32(self.string_buffer_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetStringBatch_Out(object):
    """
    Attributes:
     - result
     - char_buffer

    """


    def __init__(self, result=None, char_buffer=None,):
        self.result = result
        self.char_buffer = char_buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.char_buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatch_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.char_buffer is not None:
            oprot.writeFieldBegin('char_buffer', TType.STRING, 2)
            oprot.writeBinary(self.char_buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTime_Out(object):
    """
    Attributes:
     - result
     - time

    """


    def __init__(self, result=None, time=None,):
        self.result = result
        self.time = time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTime_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.DOUBLE, 2)
            oprot.writeDouble(self.time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetUseHoudiniTime_Out(object):
    """
    Attributes:
     - result
     - enabled

    """


    def __init__(self, result=None, enabled=None,):
        self.result = result
        self.enabled = enabled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUseHoudiniTime_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 2)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTimelineOptions_Out(object):
    """
    Attributes:
     - result
     - timeline_options

    """


    def __init__(self, result=None, timeline_options=None,):
        self.result = result
        self.timeline_options = timeline_options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeline_options = TimelineOptions()
                    self.timeline_options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTimelineOptions_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.timeline_options is not None:
            oprot.writeFieldBegin('timeline_options', TType.STRUCT, 2)
            self.timeline_options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadAssetLibraryFromFile_Out(object):
    """
    Attributes:
     - result
     - library_id

    """


    def __init__(self, result=None, library_id=None,):
        self.result = result
        self.library_id = library_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromFile_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 2)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadAssetLibraryFromMemory_Out(object):
    """
    Attributes:
     - result
     - library_id

    """


    def __init__(self, result=None, library_id=None,):
        self.result = result
        self.library_id = library_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromMemory_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 2)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAvailableAssetCount_Out(object):
    """
    Attributes:
     - result
     - asset_count

    """


    def __init__(self, result=None, asset_count=None,):
        self.result = result
        self.asset_count = asset_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.asset_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssetCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.asset_count is not None:
            oprot.writeFieldBegin('asset_count', TType.I32, 2)
            oprot.writeI32(self.asset_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAvailableAssets_Out(object):
    """
    Attributes:
     - result
     - asset_names_array

    """


    def __init__(self, result=None, asset_names_array=None,):
        self.result = result
        self.asset_names_array = asset_names_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.asset_names_array = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = iprot.readI32()
                        self.asset_names_array.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssets_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.asset_names_array is not None:
            oprot.writeFieldBegin('asset_names_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.asset_names_array))
            for iter132 in self.asset_names_array:
                oprot.writeI32(iter132)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAssetInfo_Out(object):
    """
    Attributes:
     - result
     - asset_info

    """


    def __init__(self, result=None, asset_info=None,):
        self.result = result
        self.asset_info = asset_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.asset_info = AssetInfo()
                    self.asset_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.asset_info is not None:
            oprot.writeFieldBegin('asset_info', TType.STRUCT, 2)
            self.asset_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAssetDefinitionParmCounts_Out(object):
    """
    Attributes:
     - result
     - parm_count
     - int_value_count
     - float_value_count
     - string_value_count
     - choice_value_count

    """


    def __init__(self, result=None, parm_count=None, int_value_count=None, float_value_count=None, string_value_count=None, choice_value_count=None,):
        self.result = result
        self.parm_count = parm_count
        self.int_value_count = int_value_count
        self.float_value_count = float_value_count
        self.string_value_count = string_value_count
        self.choice_value_count = choice_value_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.int_value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.float_value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.string_value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.choice_value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmCounts_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_count is not None:
            oprot.writeFieldBegin('parm_count', TType.I32, 2)
            oprot.writeI32(self.parm_count)
            oprot.writeFieldEnd()
        if self.int_value_count is not None:
            oprot.writeFieldBegin('int_value_count', TType.I32, 3)
            oprot.writeI32(self.int_value_count)
            oprot.writeFieldEnd()
        if self.float_value_count is not None:
            oprot.writeFieldBegin('float_value_count', TType.I32, 4)
            oprot.writeI32(self.float_value_count)
            oprot.writeFieldEnd()
        if self.string_value_count is not None:
            oprot.writeFieldBegin('string_value_count', TType.I32, 5)
            oprot.writeI32(self.string_value_count)
            oprot.writeFieldEnd()
        if self.choice_value_count is not None:
            oprot.writeFieldBegin('choice_value_count', TType.I32, 6)
            oprot.writeI32(self.choice_value_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAssetDefinitionParmInfos_Out(object):
    """
    Attributes:
     - result
     - parm_infos_array

    """


    def __init__(self, result=None, parm_infos_array=None,):
        self.result = result
        self.parm_infos_array = parm_infos_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.parm_infos_array = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = ParmInfo()
                        _elem138.read(iprot)
                        self.parm_infos_array.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmInfos_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_infos_array is not None:
            oprot.writeFieldBegin('parm_infos_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.parm_infos_array))
            for iter139 in self.parm_infos_array:
                iter139.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAssetDefinitionParmValues_Out(object):
    """
    Attributes:
     - result
     - int_values_array
     - float_values_array
     - string_values_array
     - choice_values_array

    """


    def __init__(self, result=None, int_values_array=None, float_values_array=None, string_values_array=None, choice_values_array=None,):
        self.result = result
        self.int_values_array = int_values_array
        self.float_values_array = float_values_array
        self.string_values_array = string_values_array
        self.choice_values_array = choice_values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.int_values_array = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = iprot.readI32()
                        self.int_values_array.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.float_values_array = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = iprot.readDouble()
                        self.float_values_array.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.string_values_array = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iprot.readI32()
                        self.string_values_array.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.choice_values_array = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = ParmChoiceInfo()
                        _elem163.read(iprot)
                        self.choice_values_array.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmValues_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.int_values_array is not None:
            oprot.writeFieldBegin('int_values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.int_values_array))
            for iter164 in self.int_values_array:
                oprot.writeI32(iter164)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.float_values_array is not None:
            oprot.writeFieldBegin('float_values_array', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.float_values_array))
            for iter165 in self.float_values_array:
                oprot.writeDouble(iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.string_values_array is not None:
            oprot.writeFieldBegin('string_values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.string_values_array))
            for iter166 in self.string_values_array:
                oprot.writeI32(iter166)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.choice_values_array is not None:
            oprot.writeFieldBegin('choice_values_array', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.choice_values_array))
            for iter167 in self.choice_values_array:
                iter167.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IsNodeValid_Out(object):
    """
    Attributes:
     - result
     - answer

    """


    def __init__(self, result=None, answer=None,):
        self.result = result
        self.answer = answer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.answer = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IsNodeValid_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.answer is not None:
            oprot.writeFieldBegin('answer', TType.BOOL, 2)
            oprot.writeBool(self.answer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNodeInfo_Out(object):
    """
    Attributes:
     - result
     - node_info

    """


    def __init__(self, result=None, node_info=None,):
        self.result = result
        self.node_info = node_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.node_info = NodeInfo()
                    self.node_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.node_info is not None:
            oprot.writeFieldBegin('node_info', TType.STRUCT, 2)
            self.node_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNodePath_Out(object):
    """
    Attributes:
     - result
     - path

    """


    def __init__(self, result=None, path=None,):
        self.result = result
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.path = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodePath_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.I32, 2)
            oprot.writeI32(self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetManagerNodeId_Out(object):
    """
    Attributes:
     - result
     - node_id

    """


    def __init__(self, result=None, node_id=None,):
        self.result = result
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetManagerNodeId_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ComposeChildNodeList_Out(object):
    """
    Attributes:
     - result
     - count

    """


    def __init__(self, result=None, count=None,):
        self.result = result
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeChildNodeList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetComposedChildNodeList_Out(object):
    """
    Attributes:
     - result
     - child_node_ids_array

    """


    def __init__(self, result=None, child_node_ids_array=None,):
        self.result = result
        self.child_node_ids_array = child_node_ids_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.child_node_ids_array = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = iprot.readI32()
                        self.child_node_ids_array.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedChildNodeList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.child_node_ids_array is not None:
            oprot.writeFieldBegin('child_node_ids_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.child_node_ids_array))
            for iter174 in self.child_node_ids_array:
                oprot.writeI32(iter174)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateNode_Out(object):
    """
    Attributes:
     - result
     - new_node_id

    """


    def __init__(self, result=None, new_node_id=None,):
        self.result = result
        self.new_node_id = new_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.new_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateNode_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.new_node_id is not None:
            oprot.writeFieldBegin('new_node_id', TType.I32, 2)
            oprot.writeI32(self.new_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateInputNode_Out(object):
    """
    Attributes:
     - result
     - node_id

    """


    def __init__(self, result=None, node_id=None,):
        self.result = result
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateInputNode_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateHeightfieldInputNode_Out(object):
    """
    Attributes:
     - result
     - heightfield_node_id
     - height_node_id
     - mask_node_id
     - merge_node_id

    """


    def __init__(self, result=None, heightfield_node_id=None, height_node_id=None, mask_node_id=None, merge_node_id=None,):
        self.result = result
        self.heightfield_node_id = heightfield_node_id
        self.height_node_id = height_node_id
        self.mask_node_id = mask_node_id
        self.merge_node_id = merge_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.heightfield_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.height_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mask_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.merge_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputNode_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.heightfield_node_id is not None:
            oprot.writeFieldBegin('heightfield_node_id', TType.I32, 2)
            oprot.writeI32(self.heightfield_node_id)
            oprot.writeFieldEnd()
        if self.height_node_id is not None:
            oprot.writeFieldBegin('height_node_id', TType.I32, 3)
            oprot.writeI32(self.height_node_id)
            oprot.writeFieldEnd()
        if self.mask_node_id is not None:
            oprot.writeFieldBegin('mask_node_id', TType.I32, 4)
            oprot.writeI32(self.mask_node_id)
            oprot.writeFieldEnd()
        if self.merge_node_id is not None:
            oprot.writeFieldBegin('merge_node_id', TType.I32, 5)
            oprot.writeI32(self.merge_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateHeightFieldInput_Out(object):
    """
    Attributes:
     - result
     - heightfield_node_id
     - height_node_id
     - mask_node_id
     - merge_node_id

    """


    def __init__(self, result=None, heightfield_node_id=None, height_node_id=None, mask_node_id=None, merge_node_id=None,):
        self.result = result
        self.heightfield_node_id = heightfield_node_id
        self.height_node_id = height_node_id
        self.mask_node_id = mask_node_id
        self.merge_node_id = merge_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.heightfield_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.height_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mask_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.merge_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightFieldInput_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.heightfield_node_id is not None:
            oprot.writeFieldBegin('heightfield_node_id', TType.I32, 2)
            oprot.writeI32(self.heightfield_node_id)
            oprot.writeFieldEnd()
        if self.height_node_id is not None:
            oprot.writeFieldBegin('height_node_id', TType.I32, 3)
            oprot.writeI32(self.height_node_id)
            oprot.writeFieldEnd()
        if self.mask_node_id is not None:
            oprot.writeFieldBegin('mask_node_id', TType.I32, 4)
            oprot.writeI32(self.mask_node_id)
            oprot.writeFieldEnd()
        if self.merge_node_id is not None:
            oprot.writeFieldBegin('merge_node_id', TType.I32, 5)
            oprot.writeI32(self.merge_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateHeightfieldInputVolumeNode_Out(object):
    """
    Attributes:
     - result
     - new_node_id

    """


    def __init__(self, result=None, new_node_id=None,):
        self.result = result
        self.new_node_id = new_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.new_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputVolumeNode_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.new_node_id is not None:
            oprot.writeFieldBegin('new_node_id', TType.I32, 2)
            oprot.writeI32(self.new_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryNodeInput_Out(object):
    """
    Attributes:
     - result
     - connected_node_id

    """


    def __init__(self, result=None, connected_node_id=None,):
        self.result = result
        self.connected_node_id = connected_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.connected_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeInput_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.connected_node_id is not None:
            oprot.writeFieldBegin('connected_node_id', TType.I32, 2)
            oprot.writeI32(self.connected_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNodeInputName_Out(object):
    """
    Attributes:
     - result
     - name

    """


    def __init__(self, result=None, name=None,):
        self.result = result
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInputName_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.I32, 2)
            oprot.writeI32(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryNodeOutputConnectedCount_Out(object):
    """
    Attributes:
     - result
     - connected_count

    """


    def __init__(self, result=None, connected_count=None,):
        self.result = result
        self.connected_count = connected_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.connected_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.connected_count is not None:
            oprot.writeFieldBegin('connected_count', TType.I32, 2)
            oprot.writeI32(self.connected_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryNodeOutputConnectedNodes_Out(object):
    """
    Attributes:
     - result
     - connected_node_ids_array

    """


    def __init__(self, result=None, connected_node_ids_array=None,):
        self.result = result
        self.connected_node_ids_array = connected_node_ids_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.connected_node_ids_array = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = iprot.readI32()
                        self.connected_node_ids_array.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedNodes_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.connected_node_ids_array is not None:
            oprot.writeFieldBegin('connected_node_ids_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.connected_node_ids_array))
            for iter181 in self.connected_node_ids_array:
                oprot.writeI32(iter181)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNodeOutputName_Out(object):
    """
    Attributes:
     - result
     - name

    """


    def __init__(self, result=None, name=None,):
        self.result = result
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeOutputName_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.I32, 2)
            oprot.writeI32(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParameters_Out(object):
    """
    Attributes:
     - result
     - parm_infos_array

    """


    def __init__(self, result=None, parm_infos_array=None,):
        self.result = result
        self.parm_infos_array = parm_infos_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.parm_infos_array = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = ParmInfo()
                        _elem187.read(iprot)
                        self.parm_infos_array.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParameters_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_infos_array is not None:
            oprot.writeFieldBegin('parm_infos_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.parm_infos_array))
            for iter188 in self.parm_infos_array:
                iter188.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmInfo_Out(object):
    """
    Attributes:
     - result
     - parm_info

    """


    def __init__(self, result=None, parm_info=None,):
        self.result = result
        self.parm_info = parm_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.parm_info = ParmInfo()
                    self.parm_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_info is not None:
            oprot.writeFieldBegin('parm_info', TType.STRUCT, 2)
            self.parm_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmIdFromName_Out(object):
    """
    Attributes:
     - result
     - parm_id

    """


    def __init__(self, result=None, parm_id=None,):
        self.result = result
        self.parm_id = parm_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIdFromName_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmInfoFromName_Out(object):
    """
    Attributes:
     - result
     - parm_info

    """


    def __init__(self, result=None, parm_info=None,):
        self.result = result
        self.parm_info = parm_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.parm_info = ParmInfo()
                    self.parm_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfoFromName_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_info is not None:
            oprot.writeFieldBegin('parm_info', TType.STRUCT, 2)
            self.parm_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmTagName_Out(object):
    """
    Attributes:
     - result
     - tag_name

    """


    def __init__(self, result=None, tag_name=None,):
        self.result = result
        self.tag_name = tag_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.tag_name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagName_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.tag_name is not None:
            oprot.writeFieldBegin('tag_name', TType.I32, 2)
            oprot.writeI32(self.tag_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmTagValue_Out(object):
    """
    Attributes:
     - result
     - tag_value

    """


    def __init__(self, result=None, tag_value=None,):
        self.result = result
        self.tag_value = tag_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.tag_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagValue_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.tag_value is not None:
            oprot.writeFieldBegin('tag_value', TType.I32, 2)
            oprot.writeI32(self.tag_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParmHasTag_Out(object):
    """
    Attributes:
     - result
     - has_tag

    """


    def __init__(self, result=None, has_tag=None,):
        self.result = result
        self.has_tag = has_tag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_tag = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasTag_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.has_tag is not None:
            oprot.writeFieldBegin('has_tag', TType.BOOL, 2)
            oprot.writeBool(self.has_tag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParmHasExpression_Out(object):
    """
    Attributes:
     - result
     - has_expression

    """


    def __init__(self, result=None, has_expression=None,):
        self.result = result
        self.has_expression = has_expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_expression = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasExpression_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.has_expression is not None:
            oprot.writeFieldBegin('has_expression', TType.BOOL, 2)
            oprot.writeBool(self.has_expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmWithTag_Out(object):
    """
    Attributes:
     - result
     - parm_id

    """


    def __init__(self, result=None, parm_id=None,):
        self.result = result
        self.parm_id = parm_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmWithTag_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmExpression_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmExpression_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmIntValue_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValue_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmIntValues_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype192, _size189) = iprot.readListBegin()
                    for _i193 in range(_size189):
                        _elem194 = iprot.readI32()
                        self.values_array.append(_elem194)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValues_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter195 in self.values_array:
                oprot.writeI32(iter195)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmFloatValue_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValue_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmFloatValues_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype199, _size196) = iprot.readListBegin()
                    for _i200 in range(_size196):
                        _elem201 = iprot.readDouble()
                        self.values_array.append(_elem201)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValues_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter202 in self.values_array:
                oprot.writeDouble(iter202)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmStringValue_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValue_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmStringValues_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = iprot.readI32()
                        self.values_array.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValues_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter209 in self.values_array:
                oprot.writeI32(iter209)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmNodeValue_Out(object):
    """
    Attributes:
     - result
     - value

    """


    def __init__(self, result=None, value=None,):
        self.result = result
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmNodeValue_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetParmChoiceLists_Out(object):
    """
    Attributes:
     - result
     - parm_choices_array

    """


    def __init__(self, result=None, parm_choices_array=None,):
        self.result = result
        self.parm_choices_array = parm_choices_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.parm_choices_array = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = ParmChoiceInfo()
                        _elem215.read(iprot)
                        self.parm_choices_array.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmChoiceLists_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.parm_choices_array is not None:
            oprot.writeFieldBegin('parm_choices_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.parm_choices_array))
            for iter216 in self.parm_choices_array:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetHandleInfo_Out(object):
    """
    Attributes:
     - result
     - handle_infos_array

    """


    def __init__(self, result=None, handle_infos_array=None,):
        self.result = result
        self.handle_infos_array = handle_infos_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.handle_infos_array = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = HandleInfo()
                        _elem222.read(iprot)
                        self.handle_infos_array.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.handle_infos_array is not None:
            oprot.writeFieldBegin('handle_infos_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.handle_infos_array))
            for iter223 in self.handle_infos_array:
                iter223.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetHandleBindingInfo_Out(object):
    """
    Attributes:
     - result
     - handle_binding_infos_array

    """


    def __init__(self, result=None, handle_binding_infos_array=None,):
        self.result = result
        self.handle_binding_infos_array = handle_binding_infos_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.handle_binding_infos_array = []
                    (_etype227, _size224) = iprot.readListBegin()
                    for _i228 in range(_size224):
                        _elem229 = HandleBindingInfo()
                        _elem229.read(iprot)
                        self.handle_binding_infos_array.append(_elem229)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleBindingInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.handle_binding_infos_array is not None:
            oprot.writeFieldBegin('handle_binding_infos_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.handle_binding_infos_array))
            for iter230 in self.handle_binding_infos_array:
                iter230.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPresetBufLength_Out(object):
    """
    Attributes:
     - result
     - buffer_length

    """


    def __init__(self, result=None, buffer_length=None,):
        self.result = result
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPresetBufLength_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 2)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPreset_Out(object):
    """
    Attributes:
     - result
     - buffer

    """


    def __init__(self, result=None, buffer=None,):
        self.result = result
        self.buffer = buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPreset_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetObjectInfo_Out(object):
    """
    Attributes:
     - result
     - object_info

    """


    def __init__(self, result=None, object_info=None,):
        self.result = result
        self.object_info = object_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.object_info = ObjectInfo()
                    self.object_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.object_info is not None:
            oprot.writeFieldBegin('object_info', TType.STRUCT, 2)
            self.object_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetObjectTransform_Out(object):
    """
    Attributes:
     - result
     - transform

    """


    def __init__(self, result=None, transform=None,):
        self.result = result
        self.transform = transform

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.transform = Transform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectTransform_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 2)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ComposeObjectList_Out(object):
    """
    Attributes:
     - result
     - object_count

    """


    def __init__(self, result=None, object_count=None,):
        self.result = result
        self.object_count = object_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.object_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeObjectList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.object_count is not None:
            oprot.writeFieldBegin('object_count', TType.I32, 2)
            oprot.writeI32(self.object_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetComposedObjectList_Out(object):
    """
    Attributes:
     - result
     - object_infos_array

    """


    def __init__(self, result=None, object_infos_array=None,):
        self.result = result
        self.object_infos_array = object_infos_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.object_infos_array = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = ObjectInfo()
                        _elem236.read(iprot)
                        self.object_infos_array.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.object_infos_array is not None:
            oprot.writeFieldBegin('object_infos_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.object_infos_array))
            for iter237 in self.object_infos_array:
                iter237.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetComposedObjectTransforms_Out(object):
    """
    Attributes:
     - result
     - transform_array

    """


    def __init__(self, result=None, transform_array=None,):
        self.result = result
        self.transform_array = transform_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.transform_array = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = Transform()
                        _elem243.read(iprot)
                        self.transform_array.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectTransforms_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transform_array is not None:
            oprot.writeFieldBegin('transform_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.transform_array))
            for iter244 in self.transform_array:
                iter244.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetInstancedObjectIds_Out(object):
    """
    Attributes:
     - result
     - instanced_node_id_array

    """


    def __init__(self, result=None, instanced_node_id_array=None,):
        self.result = result
        self.instanced_node_id_array = instanced_node_id_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.instanced_node_id_array = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readI32()
                        self.instanced_node_id_array.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedObjectIds_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.instanced_node_id_array is not None:
            oprot.writeFieldBegin('instanced_node_id_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.instanced_node_id_array))
            for iter251 in self.instanced_node_id_array:
                oprot.writeI32(iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetInstanceTransforms_Out(object):
    """
    Attributes:
     - result
     - transforms_array

    """


    def __init__(self, result=None, transforms_array=None,):
        self.result = result
        self.transforms_array = transforms_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.transforms_array = []
                    (_etype255, _size252) = iprot.readListBegin()
                    for _i256 in range(_size252):
                        _elem257 = Transform()
                        _elem257.read(iprot)
                        self.transforms_array.append(_elem257)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransforms_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transforms_array is not None:
            oprot.writeFieldBegin('transforms_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.transforms_array))
            for iter258 in self.transforms_array:
                iter258.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetInstanceTransformsOnPart_Out(object):
    """
    Attributes:
     - result
     - transforms_array

    """


    def __init__(self, result=None, transforms_array=None,):
        self.result = result
        self.transforms_array = transforms_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.transforms_array = []
                    (_etype262, _size259) = iprot.readListBegin()
                    for _i263 in range(_size259):
                        _elem264 = Transform()
                        _elem264.read(iprot)
                        self.transforms_array.append(_elem264)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransformsOnPart_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transforms_array is not None:
            oprot.writeFieldBegin('transforms_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.transforms_array))
            for iter265 in self.transforms_array:
                iter265.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetDisplayGeoInfo_Out(object):
    """
    Attributes:
     - result
     - geo_info

    """


    def __init__(self, result=None, geo_info=None,):
        self.result = result
        self.geo_info = geo_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.geo_info = GeoInfo()
                    self.geo_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDisplayGeoInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.geo_info is not None:
            oprot.writeFieldBegin('geo_info', TType.STRUCT, 2)
            self.geo_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGeoInfo_Out(object):
    """
    Attributes:
     - result
     - geo_info

    """


    def __init__(self, result=None, geo_info=None,):
        self.result = result
        self.geo_info = geo_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.geo_info = GeoInfo()
                    self.geo_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.geo_info is not None:
            oprot.writeFieldBegin('geo_info', TType.STRUCT, 2)
            self.geo_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPartInfo_Out(object):
    """
    Attributes:
     - result
     - part_info

    """


    def __init__(self, result=None, part_info=None,):
        self.result = result
        self.part_info = part_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.part_info = PartInfo()
                    self.part_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPartInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.part_info is not None:
            oprot.writeFieldBegin('part_info', TType.STRUCT, 2)
            self.part_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFaceCounts_Out(object):
    """
    Attributes:
     - result
     - face_counts_array

    """


    def __init__(self, result=None, face_counts_array=None,):
        self.result = result
        self.face_counts_array = face_counts_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.face_counts_array = []
                    (_etype269, _size266) = iprot.readListBegin()
                    for _i270 in range(_size266):
                        _elem271 = iprot.readI32()
                        self.face_counts_array.append(_elem271)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFaceCounts_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.face_counts_array is not None:
            oprot.writeFieldBegin('face_counts_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.face_counts_array))
            for iter272 in self.face_counts_array:
                oprot.writeI32(iter272)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVertexList_Out(object):
    """
    Attributes:
     - result
     - vertex_list_array

    """


    def __init__(self, result=None, vertex_list_array=None,):
        self.result = result
        self.vertex_list_array = vertex_list_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vertex_list_array = []
                    (_etype276, _size273) = iprot.readListBegin()
                    for _i277 in range(_size273):
                        _elem278 = iprot.readI32()
                        self.vertex_list_array.append(_elem278)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVertexList_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.vertex_list_array is not None:
            oprot.writeFieldBegin('vertex_list_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.vertex_list_array))
            for iter279 in self.vertex_list_array:
                oprot.writeI32(iter279)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeInfo_Out(object):
    """
    Attributes:
     - result
     - attr_info

    """


    def __init__(self, result=None, attr_info=None,):
        self.result = result
        self.attr_info = attr_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeNames_Out(object):
    """
    Attributes:
     - result
     - attribute_names_array

    """


    def __init__(self, result=None, attribute_names_array=None,):
        self.result = result
        self.attribute_names_array = attribute_names_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.attribute_names_array = []
                    (_etype283, _size280) = iprot.readListBegin()
                    for _i284 in range(_size280):
                        _elem285 = iprot.readI32()
                        self.attribute_names_array.append(_elem285)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeNames_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attribute_names_array is not None:
            oprot.writeFieldBegin('attribute_names_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.attribute_names_array))
            for iter286 in self.attribute_names_array:
                oprot.writeI32(iter286)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeIntData_Out(object):
    """
    Attributes:
     - result
     - attr_info
     - data_array

    """


    def __init__(self, result=None, attr_info=None, data_array=None,):
        self.result = result
        self.attr_info = attr_info
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readI32()
                        self.data_array.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeIntData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.data_array))
            for iter293 in self.data_array:
                oprot.writeI32(iter293)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeInt64Data_Out(object):
    """
    Attributes:
     - result
     - attr_info
     - data_array

    """


    def __init__(self, result=None, attr_info=None, data_array=None,):
        self.result = result
        self.attr_info = attr_info
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype297, _size294) = iprot.readListBegin()
                    for _i298 in range(_size294):
                        _elem299 = iprot.readI64()
                        self.data_array.append(_elem299)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInt64Data_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.data_array))
            for iter300 in self.data_array:
                oprot.writeI64(iter300)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeFloatData_Out(object):
    """
    Attributes:
     - result
     - attr_info
     - data_array

    """


    def __init__(self, result=None, attr_info=None, data_array=None,):
        self.result = result
        self.attr_info = attr_info
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype304, _size301) = iprot.readListBegin()
                    for _i305 in range(_size301):
                        _elem306 = iprot.readDouble()
                        self.data_array.append(_elem306)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloatData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.data_array))
            for iter307 in self.data_array:
                oprot.writeDouble(iter307)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeFloat64Data_Out(object):
    """
    Attributes:
     - result
     - attr_info
     - data_array

    """


    def __init__(self, result=None, attr_info=None, data_array=None,):
        self.result = result
        self.attr_info = attr_info
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype311, _size308) = iprot.readListBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readDouble()
                        self.data_array.append(_elem313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloat64Data_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.data_array))
            for iter314 in self.data_array:
                oprot.writeDouble(iter314)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAttributeStringData_Out(object):
    """
    Attributes:
     - result
     - attr_info
     - data_array

    """


    def __init__(self, result=None, attr_info=None, data_array=None,):
        self.result = result
        self.attr_info = attr_info
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype318, _size315) = iprot.readListBegin()
                    for _i319 in range(_size315):
                        _elem320 = iprot.readI32()
                        self.data_array.append(_elem320)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeStringData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 2)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.data_array))
            for iter321 in self.data_array:
                oprot.writeI32(iter321)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGroupNames_Out(object):
    """
    Attributes:
     - result
     - group_names_array

    """


    def __init__(self, result=None, group_names_array=None,):
        self.result = result
        self.group_names_array = group_names_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names_array = []
                    (_etype325, _size322) = iprot.readListBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readI32()
                        self.group_names_array.append(_elem327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNames_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.group_names_array is not None:
            oprot.writeFieldBegin('group_names_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.group_names_array))
            for iter328 in self.group_names_array:
                oprot.writeI32(iter328)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGroupMembership_Out(object):
    """
    Attributes:
     - result
     - membership_array_all_equal
     - membership_array

    """


    def __init__(self, result=None, membership_array_all_equal=None, membership_array=None,):
        self.result = result
        self.membership_array_all_equal = membership_array_all_equal
        self.membership_array = membership_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.membership_array_all_equal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.membership_array = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = iprot.readI32()
                        self.membership_array.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembership_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.membership_array_all_equal is not None:
            oprot.writeFieldBegin('membership_array_all_equal', TType.BOOL, 2)
            oprot.writeBool(self.membership_array_all_equal)
            oprot.writeFieldEnd()
        if self.membership_array is not None:
            oprot.writeFieldBegin('membership_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.membership_array))
            for iter335 in self.membership_array:
                oprot.writeI32(iter335)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGroupCountOnPackedInstancePart_Out(object):
    """
    Attributes:
     - result
     - pointGroupCount
     - primitiveGroupCount

    """


    def __init__(self, result=None, pointGroupCount=None, primitiveGroupCount=None,):
        self.result = result
        self.pointGroupCount = pointGroupCount
        self.primitiveGroupCount = primitiveGroupCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.pointGroupCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.primitiveGroupCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupCountOnPackedInstancePart_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.pointGroupCount is not None:
            oprot.writeFieldBegin('pointGroupCount', TType.I32, 2)
            oprot.writeI32(self.pointGroupCount)
            oprot.writeFieldEnd()
        if self.primitiveGroupCount is not None:
            oprot.writeFieldBegin('primitiveGroupCount', TType.I32, 3)
            oprot.writeI32(self.primitiveGroupCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGroupNamesOnPackedInstancePart_Out(object):
    """
    Attributes:
     - result
     - group_names_array

    """


    def __init__(self, result=None, group_names_array=None,):
        self.result = result
        self.group_names_array = group_names_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names_array = []
                    (_etype339, _size336) = iprot.readListBegin()
                    for _i340 in range(_size336):
                        _elem341 = iprot.readI32()
                        self.group_names_array.append(_elem341)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNamesOnPackedInstancePart_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.group_names_array is not None:
            oprot.writeFieldBegin('group_names_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.group_names_array))
            for iter342 in self.group_names_array:
                oprot.writeI32(iter342)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGroupMembershipOnPackedInstancePart_Out(object):
    """
    Attributes:
     - result
     - membership_array_all_equal
     - membership_array

    """


    def __init__(self, result=None, membership_array_all_equal=None, membership_array=None,):
        self.result = result
        self.membership_array_all_equal = membership_array_all_equal
        self.membership_array = membership_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.membership_array_all_equal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.membership_array = []
                    (_etype346, _size343) = iprot.readListBegin()
                    for _i347 in range(_size343):
                        _elem348 = iprot.readI32()
                        self.membership_array.append(_elem348)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembershipOnPackedInstancePart_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.membership_array_all_equal is not None:
            oprot.writeFieldBegin('membership_array_all_equal', TType.BOOL, 2)
            oprot.writeBool(self.membership_array_all_equal)
            oprot.writeFieldEnd()
        if self.membership_array is not None:
            oprot.writeFieldBegin('membership_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.membership_array))
            for iter349 in self.membership_array:
                oprot.writeI32(iter349)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetInstancedPartIds_Out(object):
    """
    Attributes:
     - result
     - instanced_parts_array

    """


    def __init__(self, result=None, instanced_parts_array=None,):
        self.result = result
        self.instanced_parts_array = instanced_parts_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.instanced_parts_array = []
                    (_etype353, _size350) = iprot.readListBegin()
                    for _i354 in range(_size350):
                        _elem355 = iprot.readI32()
                        self.instanced_parts_array.append(_elem355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedPartIds_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.instanced_parts_array is not None:
            oprot.writeFieldBegin('instanced_parts_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.instanced_parts_array))
            for iter356 in self.instanced_parts_array:
                oprot.writeI32(iter356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetInstancerPartTransforms_Out(object):
    """
    Attributes:
     - result
     - transforms_array

    """


    def __init__(self, result=None, transforms_array=None,):
        self.result = result
        self.transforms_array = transforms_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.transforms_array = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = Transform()
                        _elem362.read(iprot)
                        self.transforms_array.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancerPartTransforms_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.transforms_array is not None:
            oprot.writeFieldBegin('transforms_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.transforms_array))
            for iter363 in self.transforms_array:
                iter363.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMaterialNodeIdsOnFaces_Out(object):
    """
    Attributes:
     - result
     - are_all_the_same
     - material_ids_array

    """


    def __init__(self, result=None, are_all_the_same=None, material_ids_array=None,):
        self.result = result
        self.are_all_the_same = are_all_the_same
        self.material_ids_array = material_ids_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.are_all_the_same = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.material_ids_array = []
                    (_etype367, _size364) = iprot.readListBegin()
                    for _i368 in range(_size364):
                        _elem369 = iprot.readI32()
                        self.material_ids_array.append(_elem369)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialNodeIdsOnFaces_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.are_all_the_same is not None:
            oprot.writeFieldBegin('are_all_the_same', TType.BOOL, 2)
            oprot.writeBool(self.are_all_the_same)
            oprot.writeFieldEnd()
        if self.material_ids_array is not None:
            oprot.writeFieldBegin('material_ids_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.material_ids_array))
            for iter370 in self.material_ids_array:
                oprot.writeI32(iter370)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetMaterialInfo_Out(object):
    """
    Attributes:
     - result
     - material_info

    """


    def __init__(self, result=None, material_info=None,):
        self.result = result
        self.material_info = material_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.material_info = MaterialInfo()
                    self.material_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.material_info is not None:
            oprot.writeFieldBegin('material_info', TType.STRUCT, 2)
            self.material_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetImageInfo_Out(object):
    """
    Attributes:
     - result
     - image_info

    """


    def __init__(self, result=None, image_info=None,):
        self.result = result
        self.image_info = image_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.image_info = ImageInfo()
                    self.image_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.image_info is not None:
            oprot.writeFieldBegin('image_info', TType.STRUCT, 2)
            self.image_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetImagePlaneCount_Out(object):
    """
    Attributes:
     - result
     - image_plane_count

    """


    def __init__(self, result=None, image_plane_count=None,):
        self.result = result
        self.image_plane_count = image_plane_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.image_plane_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlaneCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.image_plane_count is not None:
            oprot.writeFieldBegin('image_plane_count', TType.I32, 2)
            oprot.writeI32(self.image_plane_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetImagePlanes_Out(object):
    """
    Attributes:
     - result
     - image_planes_array

    """


    def __init__(self, result=None, image_planes_array=None,):
        self.result = result
        self.image_planes_array = image_planes_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.image_planes_array = []
                    (_etype374, _size371) = iprot.readListBegin()
                    for _i375 in range(_size371):
                        _elem376 = iprot.readI32()
                        self.image_planes_array.append(_elem376)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlanes_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.image_planes_array is not None:
            oprot.writeFieldBegin('image_planes_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.image_planes_array))
            for iter377 in self.image_planes_array:
                oprot.writeI32(iter377)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExtractImageToFile_Out(object):
    """
    Attributes:
     - result
     - destination_file_path

    """


    def __init__(self, result=None, destination_file_path=None,):
        self.result = result
        self.destination_file_path = destination_file_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.destination_file_path = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToFile_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.destination_file_path is not None:
            oprot.writeFieldBegin('destination_file_path', TType.I32, 2)
            oprot.writeI32(self.destination_file_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetImageFilePath_Out(object):
    """
    Attributes:
     - result
     - destination_file_path

    """


    def __init__(self, result=None, destination_file_path=None,):
        self.result = result
        self.destination_file_path = destination_file_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.destination_file_path = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageFilePath_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.destination_file_path is not None:
            oprot.writeFieldBegin('destination_file_path', TType.I32, 2)
            oprot.writeI32(self.destination_file_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExtractImageToMemory_Out(object):
    """
    Attributes:
     - result
     - buffer_size

    """


    def __init__(self, result=None, buffer_size=None,):
        self.result = result
        self.buffer_size = buffer_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToMemory_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer_size is not None:
            oprot.writeFieldBegin('buffer_size', TType.I32, 2)
            oprot.writeI32(self.buffer_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetImageMemoryBuffer_Out(object):
    """
    Attributes:
     - result
     - buffer

    """


    def __init__(self, result=None, buffer=None,):
        self.result = result
        self.buffer = buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageMemoryBuffer_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetSupportedImageFileFormatCount_Out(object):
    """
    Attributes:
     - result
     - file_format_count

    """


    def __init__(self, result=None, file_format_count=None,):
        self.result = result
        self.file_format_count = file_format_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.file_format_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormatCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.file_format_count is not None:
            oprot.writeFieldBegin('file_format_count', TType.I32, 2)
            oprot.writeI32(self.file_format_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetSupportedImageFileFormats_Out(object):
    """
    Attributes:
     - result
     - formats_array

    """


    def __init__(self, result=None, formats_array=None,):
        self.result = result
        self.formats_array = formats_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.formats_array = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = ImageFileFormat()
                        _elem383.read(iprot)
                        self.formats_array.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormats_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.formats_array is not None:
            oprot.writeFieldBegin('formats_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.formats_array))
            for iter384 in self.formats_array:
                iter384.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeInfo_Out(object):
    """
    Attributes:
     - result
     - volume_info

    """


    def __init__(self, result=None, volume_info=None,):
        self.result = result
        self.volume_info = volume_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.volume_info = VolumeInfo()
                    self.volume_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.volume_info is not None:
            oprot.writeFieldBegin('volume_info', TType.STRUCT, 2)
            self.volume_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFirstVolumeTile_Out(object):
    """
    Attributes:
     - result
     - tile

    """


    def __init__(self, result=None, tile=None,):
        self.result = result
        self.tile = tile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFirstVolumeTile_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 2)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNextVolumeTile_Out(object):
    """
    Attributes:
     - result
     - tile

    """


    def __init__(self, result=None, tile=None,):
        self.result = result
        self.tile = tile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNextVolumeTile_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 2)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeVoxelFloatData_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype388, _size385) = iprot.readListBegin()
                    for _i389 in range(_size385):
                        _elem390 = iprot.readDouble()
                        self.values_array.append(_elem390)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelFloatData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter391 in self.values_array:
                oprot.writeDouble(iter391)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeTileFloatData_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype395, _size392) = iprot.readListBegin()
                    for _i396 in range(_size392):
                        _elem397 = iprot.readDouble()
                        self.values_array.append(_elem397)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileFloatData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter398 in self.values_array:
                oprot.writeDouble(iter398)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeVoxelIntData_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = iprot.readI32()
                        self.values_array.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelIntData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter405 in self.values_array:
                oprot.writeI32(iter405)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeTileIntData_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = iprot.readI32()
                        self.values_array.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileIntData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter412 in self.values_array:
                oprot.writeI32(iter412)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetHeightFieldData_Out(object):
    """
    Attributes:
     - result
     - values_array

    """


    def __init__(self, result=None, values_array=None,):
        self.result = result
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readDouble()
                        self.values_array.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHeightFieldData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter419 in self.values_array:
                oprot.writeDouble(iter419)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetVolumeBounds_Out(object):
    """
    Attributes:
     - result
     - x_min
     - y_min
     - z_min
     - x_max
     - y_max
     - z_max
     - x_center
     - y_center
     - z_center

    """


    def __init__(self, result=None, x_min=None, y_min=None, z_min=None, x_max=None, y_max=None, z_max=None, x_center=None, y_center=None, z_center=None,):
        self.result = result
        self.x_min = x_min
        self.y_min = y_min
        self.z_min = z_min
        self.x_max = x_max
        self.y_max = y_max
        self.z_max = z_max
        self.x_center = x_center
        self.y_center = y_center
        self.z_center = z_center

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.x_min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.y_min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.z_min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.x_max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.y_max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.z_max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.x_center = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.y_center = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.z_center = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeBounds_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.x_min is not None:
            oprot.writeFieldBegin('x_min', TType.DOUBLE, 2)
            oprot.writeDouble(self.x_min)
            oprot.writeFieldEnd()
        if self.y_min is not None:
            oprot.writeFieldBegin('y_min', TType.DOUBLE, 3)
            oprot.writeDouble(self.y_min)
            oprot.writeFieldEnd()
        if self.z_min is not None:
            oprot.writeFieldBegin('z_min', TType.DOUBLE, 4)
            oprot.writeDouble(self.z_min)
            oprot.writeFieldEnd()
        if self.x_max is not None:
            oprot.writeFieldBegin('x_max', TType.DOUBLE, 5)
            oprot.writeDouble(self.x_max)
            oprot.writeFieldEnd()
        if self.y_max is not None:
            oprot.writeFieldBegin('y_max', TType.DOUBLE, 6)
            oprot.writeDouble(self.y_max)
            oprot.writeFieldEnd()
        if self.z_max is not None:
            oprot.writeFieldBegin('z_max', TType.DOUBLE, 7)
            oprot.writeDouble(self.z_max)
            oprot.writeFieldEnd()
        if self.x_center is not None:
            oprot.writeFieldBegin('x_center', TType.DOUBLE, 8)
            oprot.writeDouble(self.x_center)
            oprot.writeFieldEnd()
        if self.y_center is not None:
            oprot.writeFieldBegin('y_center', TType.DOUBLE, 9)
            oprot.writeDouble(self.y_center)
            oprot.writeFieldEnd()
        if self.z_center is not None:
            oprot.writeFieldBegin('z_center', TType.DOUBLE, 10)
            oprot.writeDouble(self.z_center)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCurveInfo_Out(object):
    """
    Attributes:
     - result
     - info

    """


    def __init__(self, result=None, info=None,):
        self.result = result
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.info = CurveInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 2)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCurveCounts_Out(object):
    """
    Attributes:
     - result
     - counts_array

    """


    def __init__(self, result=None, counts_array=None,):
        self.result = result
        self.counts_array = counts_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.counts_array = []
                    (_etype423, _size420) = iprot.readListBegin()
                    for _i424 in range(_size420):
                        _elem425 = iprot.readI32()
                        self.counts_array.append(_elem425)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveCounts_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.counts_array is not None:
            oprot.writeFieldBegin('counts_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.counts_array))
            for iter426 in self.counts_array:
                oprot.writeI32(iter426)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCurveOrders_Out(object):
    """
    Attributes:
     - result
     - orders_array

    """


    def __init__(self, result=None, orders_array=None,):
        self.result = result
        self.orders_array = orders_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.orders_array = []
                    (_etype430, _size427) = iprot.readListBegin()
                    for _i431 in range(_size427):
                        _elem432 = iprot.readI32()
                        self.orders_array.append(_elem432)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveOrders_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.orders_array is not None:
            oprot.writeFieldBegin('orders_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.orders_array))
            for iter433 in self.orders_array:
                oprot.writeI32(iter433)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCurveKnots_Out(object):
    """
    Attributes:
     - result
     - knots_array

    """


    def __init__(self, result=None, knots_array=None,):
        self.result = result
        self.knots_array = knots_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.knots_array = []
                    (_etype437, _size434) = iprot.readListBegin()
                    for _i438 in range(_size434):
                        _elem439 = iprot.readDouble()
                        self.knots_array.append(_elem439)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveKnots_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.knots_array is not None:
            oprot.writeFieldBegin('knots_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.knots_array))
            for iter440 in self.knots_array:
                oprot.writeDouble(iter440)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetBoxInfo_Out(object):
    """
    Attributes:
     - result
     - box_info

    """


    def __init__(self, result=None, box_info=None,):
        self.result = result
        self.box_info = box_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.box_info = BoxInfo()
                    self.box_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBoxInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.box_info is not None:
            oprot.writeFieldBegin('box_info', TType.STRUCT, 2)
            self.box_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetSphereInfo_Out(object):
    """
    Attributes:
     - result
     - sphere_info

    """


    def __init__(self, result=None, sphere_info=None,):
        self.result = result
        self.sphere_info = sphere_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sphere_info = SphereInfo()
                    self.sphere_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSphereInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.sphere_info is not None:
            oprot.writeFieldBegin('sphere_info', TType.STRUCT, 2)
            self.sphere_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetActiveCacheCount_Out(object):
    """
    Attributes:
     - result
     - active_cache_count

    """


    def __init__(self, result=None, active_cache_count=None,):
        self.result = result
        self.active_cache_count = active_cache_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.active_cache_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.active_cache_count is not None:
            oprot.writeFieldBegin('active_cache_count', TType.I32, 2)
            oprot.writeI32(self.active_cache_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetActiveCacheNames_Out(object):
    """
    Attributes:
     - result
     - cache_names_array

    """


    def __init__(self, result=None, cache_names_array=None,):
        self.result = result
        self.cache_names_array = cache_names_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cache_names_array = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = iprot.readI32()
                        self.cache_names_array.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheNames_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.cache_names_array is not None:
            oprot.writeFieldBegin('cache_names_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.cache_names_array))
            for iter447 in self.cache_names_array:
                oprot.writeI32(iter447)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCacheProperty_Out(object):
    """
    Attributes:
     - result
     - property_value

    """


    def __init__(self, result=None, property_value=None,):
        self.result = result
        self.property_value = property_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.property_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCacheProperty_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.property_value is not None:
            oprot.writeFieldBegin('property_value', TType.I32, 2)
            oprot.writeI32(self.property_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadNodeFromFile_Out(object):
    """
    Attributes:
     - result
     - new_node_id

    """


    def __init__(self, result=None, new_node_id=None,):
        self.result = result
        self.new_node_id = new_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.new_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadNodeFromFile_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.new_node_id is not None:
            oprot.writeFieldBegin('new_node_id', TType.I32, 2)
            oprot.writeI32(self.new_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetGeoSize_Out(object):
    """
    Attributes:
     - result
     - size

    """


    def __init__(self, result=None, size=None,):
        self.result = result
        self.size = size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoSize_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 2)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SaveGeoToMemory_Out(object):
    """
    Attributes:
     - result
     - buffer

    """


    def __init__(self, result=None, buffer=None,):
        self.result = result
        self.buffer = buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveGeoToMemory_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTotalCookCount_Out(object):
    """
    Attributes:
     - result
     - count

    """


    def __init__(self, result=None, count=None,):
        self.result = result
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTotalCookCount_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetViewport_Out(object):
    """
    Attributes:
     - result
     - viewport

    """


    def __init__(self, result=None, viewport=None,):
        self.result = result
        self.viewport = viewport

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.viewport = Viewport()
                    self.viewport.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetViewport_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.viewport is not None:
            oprot.writeFieldBegin('viewport', TType.STRUCT, 2)
            self.viewport.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetSessionSyncInfo_Out(object):
    """
    Attributes:
     - result
     - session_sync_info

    """


    def __init__(self, result=None, session_sync_info=None,):
        self.result = result
        self.session_sync_info = session_sync_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.session_sync_info = SessionSyncInfo()
                    self.session_sync_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionSyncInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.session_sync_info is not None:
            oprot.writeFieldBegin('session_sync_info', TType.STRUCT, 2)
            self.session_sync_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPDGGraphContexts_Out(object):
    """
    Attributes:
     - result
     - num_contexts
     - context_names_array
     - context_id_array

    """


    def __init__(self, result=None, num_contexts=None, context_names_array=None, context_id_array=None,):
        self.result = result
        self.num_contexts = num_contexts
        self.context_names_array = context_names_array
        self.context_id_array = context_id_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_contexts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.context_names_array = []
                    (_etype451, _size448) = iprot.readListBegin()
                    for _i452 in range(_size448):
                        _elem453 = iprot.readI32()
                        self.context_names_array.append(_elem453)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.context_id_array = []
                    (_etype457, _size454) = iprot.readListBegin()
                    for _i458 in range(_size454):
                        _elem459 = iprot.readI32()
                        self.context_id_array.append(_elem459)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContexts_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.num_contexts is not None:
            oprot.writeFieldBegin('num_contexts', TType.I32, 2)
            oprot.writeI32(self.num_contexts)
            oprot.writeFieldEnd()
        if self.context_names_array is not None:
            oprot.writeFieldBegin('context_names_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.context_names_array))
            for iter460 in self.context_names_array:
                oprot.writeI32(iter460)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.context_id_array is not None:
            oprot.writeFieldBegin('context_id_array', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.context_id_array))
            for iter461 in self.context_id_array:
                oprot.writeI32(iter461)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPDGGraphContextId_Out(object):
    """
    Attributes:
     - result
     - context_id

    """


    def __init__(self, result=None, context_id=None,):
        self.result = result
        self.context_id = context_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContextId_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.context_id is not None:
            oprot.writeFieldBegin('context_id', TType.I32, 2)
            oprot.writeI32(self.context_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPDGEvents_Out(object):
    """
    Attributes:
     - result
     - event_array
     - event_count
     - remaining_events

    """


    def __init__(self, result=None, event_array=None, event_count=None, remaining_events=None,):
        self.result = result
        self.event_array = event_array
        self.event_count = event_count
        self.remaining_events = remaining_events

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.event_array = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = PDG_EventInfo()
                        _elem467.read(iprot)
                        self.event_array.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.event_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.remaining_events = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGEvents_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.event_array is not None:
            oprot.writeFieldBegin('event_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.event_array))
            for iter468 in self.event_array:
                iter468.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.event_count is not None:
            oprot.writeFieldBegin('event_count', TType.I32, 3)
            oprot.writeI32(self.event_count)
            oprot.writeFieldEnd()
        if self.remaining_events is not None:
            oprot.writeFieldBegin('remaining_events', TType.I32, 4)
            oprot.writeI32(self.remaining_events)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPDGState_Out(object):
    """
    Attributes:
     - result
     - pdg_state

    """


    def __init__(self, result=None, pdg_state=None,):
        self.result = result
        self.pdg_state = pdg_state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.pdg_state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGState_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.pdg_state is not None:
            oprot.writeFieldBegin('pdg_state', TType.I32, 2)
            oprot.writeI32(self.pdg_state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateWorkitem_Out(object):
    """
    Attributes:
     - result
     - workitem_id

    """


    def __init__(self, result=None, workitem_id=None,):
        self.result = result
        self.workitem_id = workitem_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateWorkitem_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemInfo_Out(object):
    """
    Attributes:
     - result
     - workitem_info

    """


    def __init__(self, result=None, workitem_info=None,):
        self.result = result
        self.workitem_info = workitem_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.workitem_info = PDG_WorkitemInfo()
                    self.workitem_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.workitem_info is not None:
            oprot.writeFieldBegin('workitem_info', TType.STRUCT, 2)
            self.workitem_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetNumWorkitems_Out(object):
    """
    Attributes:
     - result
     - num

    """


    def __init__(self, result=None, num=None,):
        self.result = result
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNumWorkitems_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 2)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitems_Out(object):
    """
    Attributes:
     - result
     - workitem_ids_array

    """


    def __init__(self, result=None, workitem_ids_array=None,):
        self.result = result
        self.workitem_ids_array = workitem_ids_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.workitem_ids_array = []
                    (_etype472, _size469) = iprot.readListBegin()
                    for _i473 in range(_size469):
                        _elem474 = iprot.readI32()
                        self.workitem_ids_array.append(_elem474)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitems_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.workitem_ids_array is not None:
            oprot.writeFieldBegin('workitem_ids_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.workitem_ids_array))
            for iter475 in self.workitem_ids_array:
                oprot.writeI32(iter475)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemDataLength_Out(object):
    """
    Attributes:
     - result
     - length

    """


    def __init__(self, result=None, length=None,):
        self.result = result
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemDataLength_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemIntData_Out(object):
    """
    Attributes:
     - result
     - data_array

    """


    def __init__(self, result=None, data_array=None,):
        self.result = result
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype479, _size476) = iprot.readListBegin()
                    for _i480 in range(_size476):
                        _elem481 = iprot.readI32()
                        self.data_array.append(_elem481)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemIntData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.data_array))
            for iter482 in self.data_array:
                oprot.writeI32(iter482)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemFloatData_Out(object):
    """
    Attributes:
     - result
     - data_array

    """


    def __init__(self, result=None, data_array=None,):
        self.result = result
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype486, _size483) = iprot.readListBegin()
                    for _i487 in range(_size483):
                        _elem488 = iprot.readDouble()
                        self.data_array.append(_elem488)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemFloatData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.data_array))
            for iter489 in self.data_array:
                oprot.writeDouble(iter489)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemStringData_Out(object):
    """
    Attributes:
     - result
     - data_array

    """


    def __init__(self, result=None, data_array=None,):
        self.result = result
        self.data_array = data_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype493, _size490) = iprot.readListBegin()
                    for _i494 in range(_size490):
                        _elem495 = iprot.readI32()
                        self.data_array.append(_elem495)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemStringData_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.data_array))
            for iter496 in self.data_array:
                oprot.writeI32(iter496)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetWorkitemResultInfo_Out(object):
    """
    Attributes:
     - result
     - resultinfo_array

    """


    def __init__(self, result=None, resultinfo_array=None,):
        self.result = result
        self.resultinfo_array = resultinfo_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.resultinfo_array = []
                    (_etype500, _size497) = iprot.readListBegin()
                    for _i501 in range(_size497):
                        _elem502 = PDG_WorkitemResultInfo()
                        _elem502.read(iprot)
                        self.resultinfo_array.append(_elem502)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemResultInfo_Out')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 1)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.resultinfo_array is not None:
            oprot.writeFieldBegin('resultinfo_array', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.resultinfo_array))
            for iter503 in self.resultinfo_array:
                iter503.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Transform)
Transform.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'position', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'rotationQuaternion', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'scale', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'shear', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.I32, 'rstOrder', None, None, ),  # 5
)
all_structs.append(TransformEuler)
TransformEuler.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'position', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'rotationEuler', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'scale', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'shear', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.I32, 'rotationOrder', None, None, ),  # 5
    (6, TType.I32, 'rstOrder', None, None, ),  # 6
)
all_structs.append(ThriftServerOptions)
ThriftServerOptions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'autoClose', None, None, ),  # 1
    (2, TType.DOUBLE, 'timeoutMs', None, None, ),  # 2
)
all_structs.append(TimelineOptions)
TimelineOptions.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'fps', None, None, ),  # 1
    (2, TType.DOUBLE, 'startTime', None, None, ),  # 2
    (3, TType.DOUBLE, 'endTime', None, None, ),  # 3
)
all_structs.append(AssetInfo)
AssetInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nodeId', None, None, ),  # 1
    (2, TType.I32, 'objectNodeId', None, None, ),  # 2
    (3, TType.BOOL, 'hasEverCooked', None, None, ),  # 3
    (4, TType.I32, 'nameSH', None, None, ),  # 4
    (5, TType.I32, 'labelSH', None, None, ),  # 5
    (6, TType.I32, 'filePathSH', None, None, ),  # 6
    (7, TType.I32, 'versionSH', None, None, ),  # 7
    (8, TType.I32, 'fullOpNameSH', None, None, ),  # 8
    (9, TType.I32, 'helpTextSH', None, None, ),  # 9
    (10, TType.I32, 'helpURLSH', None, None, ),  # 10
    (11, TType.I32, 'objectCount', None, None, ),  # 11
    (12, TType.I32, 'handleCount', None, None, ),  # 12
    (13, TType.I32, 'transformInputCount', None, None, ),  # 13
    (14, TType.I32, 'geoInputCount', None, None, ),  # 14
    (15, TType.I32, 'geoOutputCount', None, None, ),  # 15
    (16, TType.BOOL, 'haveObjectsChanged', None, None, ),  # 16
    (17, TType.BOOL, 'haveMaterialsChanged', None, None, ),  # 17
)
all_structs.append(CookOptions)
CookOptions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'splitGeosByGroup', None, None, ),  # 1
    (2, TType.BOOL, 'splitGeosByAttribute', None, None, ),  # 2
    (3, TType.I32, 'splitAttrSH', None, None, ),  # 3
    (4, TType.I32, 'maxVerticesPerPrimitive', None, None, ),  # 4
    (5, TType.BOOL, 'refineCurveToLinear', None, None, ),  # 5
    (6, TType.DOUBLE, 'curveRefineLOD', None, None, ),  # 6
    (7, TType.BOOL, 'clearErrorsAndWarnings', None, None, ),  # 7
    (8, TType.BOOL, 'cookTemplatedGeos', None, None, ),  # 8
    (9, TType.BOOL, 'splitPointsByVertexAttributes', None, None, ),  # 9
    (10, TType.I32, 'packedPrimInstancingMode', None, None, ),  # 10
    (11, TType.BOOL, 'handleBoxPartTypes', None, None, ),  # 11
    (12, TType.BOOL, 'handleSpherePartTypes', None, None, ),  # 12
    (13, TType.BOOL, 'checkPartChanges', None, None, ),  # 13
    (14, TType.I32, 'extraFlags', None, None, ),  # 14
)
all_structs.append(NodeInfo)
NodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.I32, 'parentId', None, None, ),  # 2
    (3, TType.I32, 'nameSH', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.BOOL, 'isValid', None, None, ),  # 5
    (6, TType.I32, 'totalCookCount', None, None, ),  # 6
    (7, TType.I32, 'uniqueHoudiniNodeId', None, None, ),  # 7
    (8, TType.I32, 'internalNodePathSH', None, None, ),  # 8
    (9, TType.I32, 'parmCount', None, None, ),  # 9
    (10, TType.I32, 'parmIntValueCount', None, None, ),  # 10
    (11, TType.I32, 'parmFloatValueCount', None, None, ),  # 11
    (12, TType.I32, 'parmStringValueCount', None, None, ),  # 12
    (13, TType.I32, 'parmChoiceCount', None, None, ),  # 13
    (14, TType.I32, 'childNodeCount', None, None, ),  # 14
    (15, TType.I32, 'inputCount', None, None, ),  # 15
    (16, TType.I32, 'outputCount', None, None, ),  # 16
    (17, TType.BOOL, 'createdPostAssetLoad', None, None, ),  # 17
    (18, TType.BOOL, 'isTimeDependent', None, None, ),  # 18
)
all_structs.append(ParmInfo)
ParmInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.I32, 'parentId', None, None, ),  # 2
    (3, TType.I32, 'childIndex', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.I32, 'scriptType', None, None, ),  # 5
    (6, TType.I32, 'typeInfoSH', None, None, ),  # 6
    (7, TType.I32, 'permissions', None, None, ),  # 7
    (8, TType.I32, 'tagCount', None, None, ),  # 8
    (9, TType.I32, 'size', None, None, ),  # 9
    (10, TType.I32, 'choiceListType', None, None, ),  # 10
    (11, TType.I32, 'choiceCount', None, None, ),  # 11
    (12, TType.I32, 'nameSH', None, None, ),  # 12
    (13, TType.I32, 'labelSH', None, None, ),  # 13
    (14, TType.I32, 'templateNameSH', None, None, ),  # 14
    (15, TType.I32, 'helpSH', None, None, ),  # 15
    (16, TType.BOOL, 'hasMin', None, None, ),  # 16
    (17, TType.BOOL, 'hasMax', None, None, ),  # 17
    (18, TType.BOOL, 'hasUIMin', None, None, ),  # 18
    (19, TType.BOOL, 'hasUIMax', None, None, ),  # 19
    (20, TType.DOUBLE, 'min', None, None, ),  # 20
    (21, TType.DOUBLE, 'max', None, None, ),  # 21
    (22, TType.DOUBLE, 'UIMin', None, None, ),  # 22
    (23, TType.DOUBLE, 'UIMax', None, None, ),  # 23
    (24, TType.BOOL, 'invisible', None, None, ),  # 24
    (25, TType.BOOL, 'disabled', None, None, ),  # 25
    (26, TType.BOOL, 'spare', None, None, ),  # 26
    (27, TType.BOOL, 'joinNext', None, None, ),  # 27
    (28, TType.BOOL, 'labelNone', None, None, ),  # 28
    (29, TType.I32, 'intValuesIndex', None, None, ),  # 29
    (30, TType.I32, 'floatValuesIndex', None, None, ),  # 30
    (31, TType.I32, 'stringValuesIndex', None, None, ),  # 31
    (32, TType.I32, 'choiceIndex', None, None, ),  # 32
    (33, TType.I32, 'inputNodeType', None, None, ),  # 33
    (34, TType.I32, 'inputNodeFlag', None, None, ),  # 34
    (35, TType.BOOL, 'isChildOfMultiParm', None, None, ),  # 35
    (36, TType.I32, 'instanceNum', None, None, ),  # 36
    (37, TType.I32, 'instanceLength', None, None, ),  # 37
    (38, TType.I32, 'instanceCount', None, None, ),  # 38
    (39, TType.I32, 'instanceStartOffset', None, None, ),  # 39
    (40, TType.I32, 'rampType', None, None, ),  # 40
    (41, TType.I32, 'visibilityConditionSH', None, None, ),  # 41
    (42, TType.I32, 'disabledConditionSH', None, None, ),  # 42
)
all_structs.append(ParmChoiceInfo)
ParmChoiceInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parentParmId', None, None, ),  # 1
    (2, TType.I32, 'labelSH', None, None, ),  # 2
    (3, TType.I32, 'valueSH', None, None, ),  # 3
)
all_structs.append(HandleInfo)
HandleInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nameSH', None, None, ),  # 1
    (2, TType.I32, 'typeNameSH', None, None, ),  # 2
    (3, TType.I32, 'bindingsCount', None, None, ),  # 3
)
all_structs.append(HandleBindingInfo)
HandleBindingInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handleParmNameSH', None, None, ),  # 1
    (2, TType.I32, 'assetParmNameSH', None, None, ),  # 2
    (3, TType.I32, 'assetParmId', None, None, ),  # 3
    (4, TType.I32, 'assetParmIndex', None, None, ),  # 4
)
all_structs.append(ObjectInfo)
ObjectInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nameSH', None, None, ),  # 1
    (2, TType.I32, 'objectInstancePathSH', None, None, ),  # 2
    (3, TType.BOOL, 'hasTransformChanged', None, None, ),  # 3
    (4, TType.BOOL, 'haveGeosChanged', None, None, ),  # 4
    (5, TType.BOOL, 'isVisible', None, None, ),  # 5
    (6, TType.BOOL, 'isInstancer', None, None, ),  # 6
    (7, TType.BOOL, 'isInstanced', None, None, ),  # 7
    (8, TType.I32, 'geoCount', None, None, ),  # 8
    (9, TType.I32, 'nodeId', None, None, ),  # 9
    (10, TType.I32, 'objectToInstanceId', None, None, ),  # 10
)
all_structs.append(GeoInfo)
GeoInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'nameSH', None, None, ),  # 2
    (3, TType.I32, 'nodeId', None, None, ),  # 3
    (4, TType.BOOL, 'isEditable', None, None, ),  # 4
    (5, TType.BOOL, 'isTemplated', None, None, ),  # 5
    (6, TType.BOOL, 'isDisplayGeo', None, None, ),  # 6
    (7, TType.BOOL, 'hasGeoChanged', None, None, ),  # 7
    (8, TType.BOOL, 'hasMaterialChanged', None, None, ),  # 8
    (9, TType.I32, 'pointGroupCount', None, None, ),  # 9
    (10, TType.I32, 'primitiveGroupCount', None, None, ),  # 10
    (11, TType.I32, 'partCount', None, None, ),  # 11
)
all_structs.append(PartInfo)
PartInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.I32, 'nameSH', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.I32, 'faceCount', None, None, ),  # 4
    (5, TType.I32, 'vertexCount', None, None, ),  # 5
    (6, TType.I32, 'pointCount', None, None, ),  # 6
    (7, TType.LIST, 'attributeCounts', (TType.I32, None, False), None, ),  # 7
    (8, TType.BOOL, 'isInstanced', None, None, ),  # 8
    (9, TType.I32, 'instancedPartCount', None, None, ),  # 9
    (10, TType.I32, 'instanceCount', None, None, ),  # 10
    (11, TType.BOOL, 'hasChanged', None, None, ),  # 11
)
all_structs.append(AttributeInfo)
AttributeInfo.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'exists', None, None, ),  # 1
    (2, TType.I32, 'owner', None, None, ),  # 2
    (3, TType.I32, 'storage', None, None, ),  # 3
    (4, TType.I32, 'originalOwner', None, None, ),  # 4
    (5, TType.I32, 'count', None, None, ),  # 5
    (6, TType.I32, 'tupleSize', None, None, ),  # 6
    (7, TType.I32, 'typeInfo', None, None, ),  # 7
)
all_structs.append(MaterialInfo)
MaterialInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nodeId', None, None, ),  # 1
    (2, TType.BOOL, 'exists', None, None, ),  # 2
    (3, TType.BOOL, 'hasChanged', None, None, ),  # 3
)
all_structs.append(ImageFileFormat)
ImageFileFormat.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nameSH', None, None, ),  # 1
    (2, TType.I32, 'descriptionSH', None, None, ),  # 2
    (3, TType.I32, 'defaultExtensionSH', None, None, ),  # 3
)
all_structs.append(ImageInfo)
ImageInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'imageFileFormatNameSH', None, None, ),  # 1
    (2, TType.I32, 'xRes', None, None, ),  # 2
    (3, TType.I32, 'yRes', None, None, ),  # 3
    (4, TType.I32, 'dataFormat', None, None, ),  # 4
    (5, TType.BOOL, 'interleaved', None, None, ),  # 5
    (6, TType.I32, 'packing', None, None, ),  # 6
    (7, TType.DOUBLE, 'gamma', None, None, ),  # 7
)
all_structs.append(Keyframe)
Keyframe.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'time', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
    (3, TType.DOUBLE, 'inTangent', None, None, ),  # 3
    (4, TType.DOUBLE, 'outTangent', None, None, ),  # 4
)
all_structs.append(VolumeInfo)
VolumeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nameSH', None, None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I32, 'xLength', None, None, ),  # 3
    (4, TType.I32, 'yLength', None, None, ),  # 4
    (5, TType.I32, 'zLength', None, None, ),  # 5
    (6, TType.I32, 'minX', None, None, ),  # 6
    (7, TType.I32, 'minY', None, None, ),  # 7
    (8, TType.I32, 'minZ', None, None, ),  # 8
    (9, TType.I32, 'tupleSize', None, None, ),  # 9
    (10, TType.I32, 'storage', None, None, ),  # 10
    (11, TType.I32, 'tileSize', None, None, ),  # 11
    (12, TType.STRUCT, 'transform', [Transform, None], None, ),  # 12
    (13, TType.BOOL, 'hasTaper', None, None, ),  # 13
    (14, TType.DOUBLE, 'xTaper', None, None, ),  # 14
    (15, TType.DOUBLE, 'yTaper', None, None, ),  # 15
)
all_structs.append(VolumeTileInfo)
VolumeTileInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'minX', None, None, ),  # 1
    (2, TType.I32, 'minY', None, None, ),  # 2
    (3, TType.I32, 'minZ', None, None, ),  # 3
    (4, TType.BOOL, 'isValid', None, None, ),  # 4
)
all_structs.append(CurveInfo)
CurveInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'curveType', None, None, ),  # 1
    (2, TType.I32, 'curveCount', None, None, ),  # 2
    (3, TType.I32, 'vertexCount', None, None, ),  # 3
    (4, TType.I32, 'knotCount', None, None, ),  # 4
    (5, TType.BOOL, 'isPeriodic', None, None, ),  # 5
    (6, TType.BOOL, 'isRational', None, None, ),  # 6
    (7, TType.I32, 'order', None, None, ),  # 7
    (8, TType.BOOL, 'hasKnots', None, None, ),  # 8
)
all_structs.append(BoxInfo)
BoxInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'center', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'size', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'rotation', (TType.DOUBLE, None, False), None, ),  # 3
)
all_structs.append(SphereInfo)
SphereInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'center', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'radius', None, None, ),  # 2
)
all_structs.append(PDG_EventInfo)
PDG_EventInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'nodeId', None, None, ),  # 1
    (2, TType.I32, 'workitemId', None, None, ),  # 2
    (3, TType.I32, 'dependencyId', None, None, ),  # 3
    (4, TType.I32, 'currentState', None, None, ),  # 4
    (5, TType.I32, 'lastState', None, None, ),  # 5
    (6, TType.I32, 'eventType', None, None, ),  # 6
    (7, TType.I32, 'msgSH', None, None, ),  # 7
)
all_structs.append(PDG_WorkitemInfo)
PDG_WorkitemInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
    (2, TType.I32, 'numResults', None, None, ),  # 2
    (3, TType.I32, 'nameSH', None, None, ),  # 3
)
all_structs.append(PDG_WorkitemResultInfo)
PDG_WorkitemResultInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'resultSH', None, None, ),  # 1
    (2, TType.I32, 'resultTagSH', None, None, ),  # 2
    (3, TType.I64, 'resultHash', None, None, ),  # 3
)
all_structs.append(Viewport)
Viewport.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'position', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'rotationQuaternion', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'offset', None, None, ),  # 3
)
all_structs.append(SessionSyncInfo)
SessionSyncInfo.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'cookUsingHoudiniTime', None, None, ),  # 1
    (2, TType.BOOL, 'syncViewport', None, None, ),  # 2
)
all_structs.append(GetSessionEnvInt_Out)
GetSessionEnvInt_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetServerEnvInt_Out)
GetServerEnvInt_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetServerEnvString_Out)
GetServerEnvString_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetServerEnvVarCount_Out)
GetServerEnvVarCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'env_count', None, None, ),  # 2
)
all_structs.append(GetServerEnvVarList_Out)
GetServerEnvVarList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetStatus_Out)
GetStatus_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
)
all_structs.append(GetStatusStringBufLength_Out)
GetStatusStringBufLength_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'buffer_length', None, None, ),  # 2
)
all_structs.append(GetStatusString_Out)
GetStatusString_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'string_value', 'UTF8', None, ),  # 2
)
all_structs.append(ComposeNodeCookResult_Out)
ComposeNodeCookResult_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'buffer_length', None, None, ),  # 2
)
all_structs.append(GetComposedNodeCookResult_Out)
GetComposedNodeCookResult_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'string_value', 'UTF8', None, ),  # 2
)
all_structs.append(CheckForSpecificErrors_Out)
CheckForSpecificErrors_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'errors_found', None, None, ),  # 2
)
all_structs.append(GetCookingTotalCount_Out)
GetCookingTotalCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(GetCookingCurrentCount_Out)
GetCookingCurrentCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(ConvertTransform_Out)
ConvertTransform_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'transform_out', [TransformEuler, None], None, ),  # 2
)
all_structs.append(ConvertMatrixToQuat_Out)
ConvertMatrixToQuat_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'transform_out', [Transform, None], None, ),  # 2
)
all_structs.append(ConvertMatrixToEuler_Out)
ConvertMatrixToEuler_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'transform_out', [TransformEuler, None], None, ),  # 2
)
all_structs.append(ConvertTransformQuatToMatrix_Out)
ConvertTransformQuatToMatrix_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'matrix', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(ConvertTransformEulerToMatrix_Out)
ConvertTransformEulerToMatrix_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'matrix', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetStringBufLength_Out)
GetStringBufLength_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'buffer_length', None, None, ),  # 2
)
all_structs.append(GetString_Out)
GetString_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'string_value', 'UTF8', None, ),  # 2
)
all_structs.append(SetCustomString_Out)
SetCustomString_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'handle_value', None, None, ),  # 2
)
all_structs.append(GetStringBatchSize_Out)
GetStringBatchSize_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'string_buffer_size', None, None, ),  # 2
)
all_structs.append(GetStringBatch_Out)
GetStringBatch_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'char_buffer', 'BINARY', None, ),  # 2
)
all_structs.append(GetTime_Out)
GetTime_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.DOUBLE, 'time', None, None, ),  # 2
)
all_structs.append(GetUseHoudiniTime_Out)
GetUseHoudiniTime_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'enabled', None, None, ),  # 2
)
all_structs.append(GetTimelineOptions_Out)
GetTimelineOptions_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'timeline_options', [TimelineOptions, None], None, ),  # 2
)
all_structs.append(LoadAssetLibraryFromFile_Out)
LoadAssetLibraryFromFile_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'library_id', None, None, ),  # 2
)
all_structs.append(LoadAssetLibraryFromMemory_Out)
LoadAssetLibraryFromMemory_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'library_id', None, None, ),  # 2
)
all_structs.append(GetAvailableAssetCount_Out)
GetAvailableAssetCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'asset_count', None, None, ),  # 2
)
all_structs.append(GetAvailableAssets_Out)
GetAvailableAssets_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'asset_names_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetAssetInfo_Out)
GetAssetInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'asset_info', [AssetInfo, None], None, ),  # 2
)
all_structs.append(GetAssetDefinitionParmCounts_Out)
GetAssetDefinitionParmCounts_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'parm_count', None, None, ),  # 2
    (3, TType.I32, 'int_value_count', None, None, ),  # 3
    (4, TType.I32, 'float_value_count', None, None, ),  # 4
    (5, TType.I32, 'string_value_count', None, None, ),  # 5
    (6, TType.I32, 'choice_value_count', None, None, ),  # 6
)
all_structs.append(GetAssetDefinitionParmInfos_Out)
GetAssetDefinitionParmInfos_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'parm_infos_array', (TType.STRUCT, [ParmInfo, None], False), None, ),  # 2
)
all_structs.append(GetAssetDefinitionParmValues_Out)
GetAssetDefinitionParmValues_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'int_values_array', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'float_values_array', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'string_values_array', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'choice_values_array', (TType.STRUCT, [ParmChoiceInfo, None], False), None, ),  # 5
)
all_structs.append(IsNodeValid_Out)
IsNodeValid_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'answer', None, None, ),  # 2
)
all_structs.append(GetNodeInfo_Out)
GetNodeInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'node_info', [NodeInfo, None], None, ),  # 2
)
all_structs.append(GetNodePath_Out)
GetNodePath_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'path', None, None, ),  # 2
)
all_structs.append(GetManagerNodeId_Out)
GetManagerNodeId_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
)
all_structs.append(ComposeChildNodeList_Out)
ComposeChildNodeList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(GetComposedChildNodeList_Out)
GetComposedChildNodeList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'child_node_ids_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(CreateNode_Out)
CreateNode_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'new_node_id', None, None, ),  # 2
)
all_structs.append(CreateInputNode_Out)
CreateInputNode_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
)
all_structs.append(CreateHeightfieldInputNode_Out)
CreateHeightfieldInputNode_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'heightfield_node_id', None, None, ),  # 2
    (3, TType.I32, 'height_node_id', None, None, ),  # 3
    (4, TType.I32, 'mask_node_id', None, None, ),  # 4
    (5, TType.I32, 'merge_node_id', None, None, ),  # 5
)
all_structs.append(CreateHeightFieldInput_Out)
CreateHeightFieldInput_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'heightfield_node_id', None, None, ),  # 2
    (3, TType.I32, 'height_node_id', None, None, ),  # 3
    (4, TType.I32, 'mask_node_id', None, None, ),  # 4
    (5, TType.I32, 'merge_node_id', None, None, ),  # 5
)
all_structs.append(CreateHeightfieldInputVolumeNode_Out)
CreateHeightfieldInputVolumeNode_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'new_node_id', None, None, ),  # 2
)
all_structs.append(QueryNodeInput_Out)
QueryNodeInput_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'connected_node_id', None, None, ),  # 2
)
all_structs.append(GetNodeInputName_Out)
GetNodeInputName_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'name', None, None, ),  # 2
)
all_structs.append(QueryNodeOutputConnectedCount_Out)
QueryNodeOutputConnectedCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'connected_count', None, None, ),  # 2
)
all_structs.append(QueryNodeOutputConnectedNodes_Out)
QueryNodeOutputConnectedNodes_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'connected_node_ids_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetNodeOutputName_Out)
GetNodeOutputName_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'name', None, None, ),  # 2
)
all_structs.append(GetParameters_Out)
GetParameters_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'parm_infos_array', (TType.STRUCT, [ParmInfo, None], False), None, ),  # 2
)
all_structs.append(GetParmInfo_Out)
GetParmInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'parm_info', [ParmInfo, None], None, ),  # 2
)
all_structs.append(GetParmIdFromName_Out)
GetParmIdFromName_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
)
all_structs.append(GetParmInfoFromName_Out)
GetParmInfoFromName_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'parm_info', [ParmInfo, None], None, ),  # 2
)
all_structs.append(GetParmTagName_Out)
GetParmTagName_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'tag_name', None, None, ),  # 2
)
all_structs.append(GetParmTagValue_Out)
GetParmTagValue_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'tag_value', None, None, ),  # 2
)
all_structs.append(ParmHasTag_Out)
ParmHasTag_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'has_tag', None, None, ),  # 2
)
all_structs.append(ParmHasExpression_Out)
ParmHasExpression_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'has_expression', None, None, ),  # 2
)
all_structs.append(GetParmWithTag_Out)
GetParmWithTag_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
)
all_structs.append(GetParmExpression_Out)
GetParmExpression_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetParmIntValue_Out)
GetParmIntValue_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetParmIntValues_Out)
GetParmIntValues_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetParmFloatValue_Out)
GetParmFloatValue_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
)
all_structs.append(GetParmFloatValues_Out)
GetParmFloatValues_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetParmStringValue_Out)
GetParmStringValue_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetParmStringValues_Out)
GetParmStringValues_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetParmNodeValue_Out)
GetParmNodeValue_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(GetParmChoiceLists_Out)
GetParmChoiceLists_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'parm_choices_array', (TType.STRUCT, [ParmChoiceInfo, None], False), None, ),  # 2
)
all_structs.append(GetHandleInfo_Out)
GetHandleInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'handle_infos_array', (TType.STRUCT, [HandleInfo, None], False), None, ),  # 2
)
all_structs.append(GetHandleBindingInfo_Out)
GetHandleBindingInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'handle_binding_infos_array', (TType.STRUCT, [HandleBindingInfo, None], False), None, ),  # 2
)
all_structs.append(GetPresetBufLength_Out)
GetPresetBufLength_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'buffer_length', None, None, ),  # 2
)
all_structs.append(GetPreset_Out)
GetPreset_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
)
all_structs.append(GetObjectInfo_Out)
GetObjectInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'object_info', [ObjectInfo, None], None, ),  # 2
)
all_structs.append(GetObjectTransform_Out)
GetObjectTransform_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'transform', [Transform, None], None, ),  # 2
)
all_structs.append(ComposeObjectList_Out)
ComposeObjectList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'object_count', None, None, ),  # 2
)
all_structs.append(GetComposedObjectList_Out)
GetComposedObjectList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'object_infos_array', (TType.STRUCT, [ObjectInfo, None], False), None, ),  # 2
)
all_structs.append(GetComposedObjectTransforms_Out)
GetComposedObjectTransforms_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'transform_array', (TType.STRUCT, [Transform, None], False), None, ),  # 2
)
all_structs.append(GetInstancedObjectIds_Out)
GetInstancedObjectIds_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'instanced_node_id_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetInstanceTransforms_Out)
GetInstanceTransforms_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'transforms_array', (TType.STRUCT, [Transform, None], False), None, ),  # 2
)
all_structs.append(GetInstanceTransformsOnPart_Out)
GetInstanceTransformsOnPart_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'transforms_array', (TType.STRUCT, [Transform, None], False), None, ),  # 2
)
all_structs.append(GetDisplayGeoInfo_Out)
GetDisplayGeoInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'geo_info', [GeoInfo, None], None, ),  # 2
)
all_structs.append(GetGeoInfo_Out)
GetGeoInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'geo_info', [GeoInfo, None], None, ),  # 2
)
all_structs.append(GetPartInfo_Out)
GetPartInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'part_info', [PartInfo, None], None, ),  # 2
)
all_structs.append(GetFaceCounts_Out)
GetFaceCounts_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'face_counts_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetVertexList_Out)
GetVertexList_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'vertex_list_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetAttributeInfo_Out)
GetAttributeInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
)
all_structs.append(GetAttributeNames_Out)
GetAttributeNames_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'attribute_names_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetAttributeIntData_Out)
GetAttributeIntData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
    (3, TType.LIST, 'data_array', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(GetAttributeInt64Data_Out)
GetAttributeInt64Data_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
    (3, TType.LIST, 'data_array', (TType.I64, None, False), None, ),  # 3
)
all_structs.append(GetAttributeFloatData_Out)
GetAttributeFloatData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
    (3, TType.LIST, 'data_array', (TType.DOUBLE, None, False), None, ),  # 3
)
all_structs.append(GetAttributeFloat64Data_Out)
GetAttributeFloat64Data_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
    (3, TType.LIST, 'data_array', (TType.DOUBLE, None, False), None, ),  # 3
)
all_structs.append(GetAttributeStringData_Out)
GetAttributeStringData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 2
    (3, TType.LIST, 'data_array', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(GetGroupNames_Out)
GetGroupNames_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'group_names_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetGroupMembership_Out)
GetGroupMembership_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'membership_array_all_equal', None, None, ),  # 2
    (3, TType.LIST, 'membership_array', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(GetGroupCountOnPackedInstancePart_Out)
GetGroupCountOnPackedInstancePart_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'pointGroupCount', None, None, ),  # 2
    (3, TType.I32, 'primitiveGroupCount', None, None, ),  # 3
)
all_structs.append(GetGroupNamesOnPackedInstancePart_Out)
GetGroupNamesOnPackedInstancePart_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'group_names_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetGroupMembershipOnPackedInstancePart_Out)
GetGroupMembershipOnPackedInstancePart_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'membership_array_all_equal', None, None, ),  # 2
    (3, TType.LIST, 'membership_array', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(GetInstancedPartIds_Out)
GetInstancedPartIds_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'instanced_parts_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetInstancerPartTransforms_Out)
GetInstancerPartTransforms_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'transforms_array', (TType.STRUCT, [Transform, None], False), None, ),  # 2
)
all_structs.append(GetMaterialNodeIdsOnFaces_Out)
GetMaterialNodeIdsOnFaces_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.BOOL, 'are_all_the_same', None, None, ),  # 2
    (3, TType.LIST, 'material_ids_array', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(GetMaterialInfo_Out)
GetMaterialInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'material_info', [MaterialInfo, None], None, ),  # 2
)
all_structs.append(GetImageInfo_Out)
GetImageInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'image_info', [ImageInfo, None], None, ),  # 2
)
all_structs.append(GetImagePlaneCount_Out)
GetImagePlaneCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'image_plane_count', None, None, ),  # 2
)
all_structs.append(GetImagePlanes_Out)
GetImagePlanes_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'image_planes_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(ExtractImageToFile_Out)
ExtractImageToFile_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'destination_file_path', None, None, ),  # 2
)
all_structs.append(GetImageFilePath_Out)
GetImageFilePath_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'destination_file_path', None, None, ),  # 2
)
all_structs.append(ExtractImageToMemory_Out)
ExtractImageToMemory_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'buffer_size', None, None, ),  # 2
)
all_structs.append(GetImageMemoryBuffer_Out)
GetImageMemoryBuffer_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
)
all_structs.append(GetSupportedImageFileFormatCount_Out)
GetSupportedImageFileFormatCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'file_format_count', None, None, ),  # 2
)
all_structs.append(GetSupportedImageFileFormats_Out)
GetSupportedImageFileFormats_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'formats_array', (TType.STRUCT, [ImageFileFormat, None], False), None, ),  # 2
)
all_structs.append(GetVolumeInfo_Out)
GetVolumeInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'volume_info', [VolumeInfo, None], None, ),  # 2
)
all_structs.append(GetFirstVolumeTile_Out)
GetFirstVolumeTile_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 2
)
all_structs.append(GetNextVolumeTile_Out)
GetNextVolumeTile_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 2
)
all_structs.append(GetVolumeVoxelFloatData_Out)
GetVolumeVoxelFloatData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetVolumeTileFloatData_Out)
GetVolumeTileFloatData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetVolumeVoxelIntData_Out)
GetVolumeVoxelIntData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetVolumeTileIntData_Out)
GetVolumeTileIntData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetHeightFieldData_Out)
GetHeightFieldData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetVolumeBounds_Out)
GetVolumeBounds_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.DOUBLE, 'x_min', None, None, ),  # 2
    (3, TType.DOUBLE, 'y_min', None, None, ),  # 3
    (4, TType.DOUBLE, 'z_min', None, None, ),  # 4
    (5, TType.DOUBLE, 'x_max', None, None, ),  # 5
    (6, TType.DOUBLE, 'y_max', None, None, ),  # 6
    (7, TType.DOUBLE, 'z_max', None, None, ),  # 7
    (8, TType.DOUBLE, 'x_center', None, None, ),  # 8
    (9, TType.DOUBLE, 'y_center', None, None, ),  # 9
    (10, TType.DOUBLE, 'z_center', None, None, ),  # 10
)
all_structs.append(GetCurveInfo_Out)
GetCurveInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'info', [CurveInfo, None], None, ),  # 2
)
all_structs.append(GetCurveCounts_Out)
GetCurveCounts_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'counts_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetCurveOrders_Out)
GetCurveOrders_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'orders_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetCurveKnots_Out)
GetCurveKnots_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'knots_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetBoxInfo_Out)
GetBoxInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'box_info', [BoxInfo, None], None, ),  # 2
)
all_structs.append(GetSphereInfo_Out)
GetSphereInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'sphere_info', [SphereInfo, None], None, ),  # 2
)
all_structs.append(GetActiveCacheCount_Out)
GetActiveCacheCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'active_cache_count', None, None, ),  # 2
)
all_structs.append(GetActiveCacheNames_Out)
GetActiveCacheNames_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'cache_names_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetCacheProperty_Out)
GetCacheProperty_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'property_value', None, None, ),  # 2
)
all_structs.append(LoadNodeFromFile_Out)
LoadNodeFromFile_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'new_node_id', None, None, ),  # 2
)
all_structs.append(GetGeoSize_Out)
GetGeoSize_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'size', None, None, ),  # 2
)
all_structs.append(SaveGeoToMemory_Out)
SaveGeoToMemory_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
)
all_structs.append(GetTotalCookCount_Out)
GetTotalCookCount_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(GetViewport_Out)
GetViewport_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'viewport', [Viewport, None], None, ),  # 2
)
all_structs.append(GetSessionSyncInfo_Out)
GetSessionSyncInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'session_sync_info', [SessionSyncInfo, None], None, ),  # 2
)
all_structs.append(GetPDGGraphContexts_Out)
GetPDGGraphContexts_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'num_contexts', None, None, ),  # 2
    (3, TType.LIST, 'context_names_array', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'context_id_array', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(GetPDGGraphContextId_Out)
GetPDGGraphContextId_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'context_id', None, None, ),  # 2
)
all_structs.append(GetPDGEvents_Out)
GetPDGEvents_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'event_array', (TType.STRUCT, [PDG_EventInfo, None], False), None, ),  # 2
    (3, TType.I32, 'event_count', None, None, ),  # 3
    (4, TType.I32, 'remaining_events', None, None, ),  # 4
)
all_structs.append(GetPDGState_Out)
GetPDGState_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'pdg_state', None, None, ),  # 2
)
all_structs.append(CreateWorkitem_Out)
CreateWorkitem_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
)
all_structs.append(GetWorkitemInfo_Out)
GetWorkitemInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.STRUCT, 'workitem_info', [PDG_WorkitemInfo, None], None, ),  # 2
)
all_structs.append(GetNumWorkitems_Out)
GetNumWorkitems_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'num', None, None, ),  # 2
)
all_structs.append(GetWorkitems_Out)
GetWorkitems_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'workitem_ids_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetWorkitemDataLength_Out)
GetWorkitemDataLength_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)
all_structs.append(GetWorkitemIntData_Out)
GetWorkitemIntData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'data_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetWorkitemFloatData_Out)
GetWorkitemFloatData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'data_array', (TType.DOUBLE, None, False), None, ),  # 2
)
all_structs.append(GetWorkitemStringData_Out)
GetWorkitemStringData_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'data_array', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetWorkitemResultInfo_Out)
GetWorkitemResultInfo_Out.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result', None, None, ),  # 1
    (2, TType.LIST, 'resultinfo_array', (TType.STRUCT, [PDG_WorkitemResultInfo, None], False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
