#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def IsInitialized(self):
        pass

    def Initialize(self, cook_options, use_cooking_thread, cooking_thread_stack_size, houdini_environment_files, otl_search_path, dso_search_path, image_dso_search_path, audio_dso_search_path):
        """
        Parameters:
         - cook_options
         - use_cooking_thread
         - cooking_thread_stack_size
         - houdini_environment_files
         - otl_search_path
         - dso_search_path
         - image_dso_search_path
         - audio_dso_search_path

        """
        pass

    def Cleanup(self):
        pass

    def GetSessionEnvInt(self, int_type):
        """
        Parameters:
         - int_type

        """
        pass

    def GetServerEnvInt(self, variable_name):
        """
        Parameters:
         - variable_name

        """
        pass

    def GetServerEnvString(self, variable_name):
        """
        Parameters:
         - variable_name

        """
        pass

    def GetServerEnvVarCount(self):
        pass

    def GetServerEnvVarList(self, start, length):
        """
        Parameters:
         - start
         - length

        """
        pass

    def SetServerEnvInt(self, variable_name, value):
        """
        Parameters:
         - variable_name
         - value

        """
        pass

    def SetServerEnvString(self, variable_name, value):
        """
        Parameters:
         - variable_name
         - value

        """
        pass

    def GetStatus(self, status_type):
        """
        Parameters:
         - status_type

        """
        pass

    def GetStatusStringBufLength(self, status_type, verbosity):
        """
        Parameters:
         - status_type
         - verbosity

        """
        pass

    def GetStatusString(self, status_type, length):
        """
        Parameters:
         - status_type
         - length

        """
        pass

    def ComposeNodeCookResult(self, node_id, verbosity):
        """
        Parameters:
         - node_id
         - verbosity

        """
        pass

    def GetComposedNodeCookResult(self, length):
        """
        Parameters:
         - length

        """
        pass

    def CheckForSpecificErrors(self, node_id, errors_to_look_for):
        """
        Parameters:
         - node_id
         - errors_to_look_for

        """
        pass

    def GetCookingTotalCount(self):
        pass

    def GetCookingCurrentCount(self):
        pass

    def ConvertTransform(self, transform_in, rst_order, rot_order):
        """
        Parameters:
         - transform_in
         - rst_order
         - rot_order

        """
        pass

    def ConvertMatrixToQuat(self, matrix, rst_order):
        """
        Parameters:
         - matrix
         - rst_order

        """
        pass

    def ConvertMatrixToEuler(self, matrix, rst_order, rot_order):
        """
        Parameters:
         - matrix
         - rst_order
         - rot_order

        """
        pass

    def ConvertTransformQuatToMatrix(self, transform):
        """
        Parameters:
         - transform

        """
        pass

    def ConvertTransformEulerToMatrix(self, transform):
        """
        Parameters:
         - transform

        """
        pass

    def PythonThreadInterpreterLock(self, locked):
        """
        Parameters:
         - locked

        """
        pass

    def GetStringBufLength(self, string_handle):
        """
        Parameters:
         - string_handle

        """
        pass

    def GetString(self, string_handle, length):
        """
        Parameters:
         - string_handle
         - length

        """
        pass

    def SetCustomString(self, string_value):
        """
        Parameters:
         - string_value

        """
        pass

    def RemoveCustomString(self, string_handle):
        """
        Parameters:
         - string_handle

        """
        pass

    def GetStringBatchSize(self, string_handle_array):
        """
        Parameters:
         - string_handle_array

        """
        pass

    def GetStringBatch(self, char_array_length):
        """
        Parameters:
         - char_array_length

        """
        pass

    def GetTime(self):
        pass

    def SetTime(self, time):
        """
        Parameters:
         - time

        """
        pass

    def GetUseHoudiniTime(self):
        pass

    def SetUseHoudiniTime(self, enabled):
        """
        Parameters:
         - enabled

        """
        pass

    def GetTimelineOptions(self):
        pass

    def SetTimelineOptions(self, timeline_options):
        """
        Parameters:
         - timeline_options

        """
        pass

    def LoadAssetLibraryFromFile(self, file_path, allow_overwrite):
        """
        Parameters:
         - file_path
         - allow_overwrite

        """
        pass

    def LoadAssetLibraryFromMemory(self, library_buffer, library_buffer_length, allow_overwrite):
        """
        Parameters:
         - library_buffer
         - library_buffer_length
         - allow_overwrite

        """
        pass

    def GetAvailableAssetCount(self, library_id):
        """
        Parameters:
         - library_id

        """
        pass

    def GetAvailableAssets(self, library_id, asset_count):
        """
        Parameters:
         - library_id
         - asset_count

        """
        pass

    def GetAssetInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetAssetDefinitionParmCounts(self, library_id, asset_name):
        """
        Parameters:
         - library_id
         - asset_name

        """
        pass

    def GetAssetDefinitionParmInfos(self, library_id, asset_name, start, length):
        """
        Parameters:
         - library_id
         - asset_name
         - start
         - length

        """
        pass

    def GetAssetDefinitionParmValues(self, library_id, asset_name, int_start, int_length, float_start, float_length, string_evaluate, string_start, string_length, choice_start, choice_length):
        """
        Parameters:
         - library_id
         - asset_name
         - int_start
         - int_length
         - float_start
         - float_length
         - string_evaluate
         - string_start
         - string_length
         - choice_start
         - choice_length

        """
        pass

    def Interrupt(self):
        pass

    def LoadHIPFile(self, file_name, cook_on_load):
        """
        Parameters:
         - file_name
         - cook_on_load

        """
        pass

    def SaveHIPFile(self, file_path, lock_nodes):
        """
        Parameters:
         - file_path
         - lock_nodes

        """
        pass

    def IsNodeValid(self, node_id, unique_node_id):
        """
        Parameters:
         - node_id
         - unique_node_id

        """
        pass

    def GetNodeInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetNodePath(self, node_id, relative_to_node_id):
        """
        Parameters:
         - node_id
         - relative_to_node_id

        """
        pass

    def GetManagerNodeId(self, node_type):
        """
        Parameters:
         - node_type

        """
        pass

    def ComposeChildNodeList(self, parent_node_id, node_type_filter, node_flags_filter, recursive):
        """
        Parameters:
         - parent_node_id
         - node_type_filter
         - node_flags_filter
         - recursive

        """
        pass

    def GetComposedChildNodeList(self, parent_node_id, count):
        """
        Parameters:
         - parent_node_id
         - count

        """
        pass

    def CreateNode(self, parent_node_id, operator_name, node_label, cook_on_creation):
        """
        Parameters:
         - parent_node_id
         - operator_name
         - node_label
         - cook_on_creation

        """
        pass

    def CreateInputNode(self, name):
        """
        Parameters:
         - name

        """
        pass

    def CreateHeightfieldInputNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize

        """
        pass

    def CreateHeightFieldInput(self, parent_node_id, name, xsize, ysize, voxelsize, sampling):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize
         - sampling

        """
        pass

    def CreateHeightfieldInputVolumeNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize

        """
        pass

    def CookNode(self, node_id, cook_options):
        """
        Parameters:
         - node_id
         - cook_options

        """
        pass

    def DeleteNode(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def RenameNode(self, node_id, new_name):
        """
        Parameters:
         - node_id
         - new_name

        """
        pass

    def ConnectNodeInput(self, node_id, input_index, node_id_to_connect, output_index):
        """
        Parameters:
         - node_id
         - input_index
         - node_id_to_connect
         - output_index

        """
        pass

    def DisconnectNodeInput(self, node_id, input_index):
        """
        Parameters:
         - node_id
         - input_index

        """
        pass

    def QueryNodeInput(self, node_to_query, input_index):
        """
        Parameters:
         - node_to_query
         - input_index

        """
        pass

    def GetNodeInputName(self, node_id, input_idx):
        """
        Parameters:
         - node_id
         - input_idx

        """
        pass

    def DisconnectNodeOutputsAt(self, node_id, output_index):
        """
        Parameters:
         - node_id
         - output_index

        """
        pass

    def QueryNodeOutputConnectedCount(self, node_id, output_idx, into_subnets, through_dots):
        """
        Parameters:
         - node_id
         - output_idx
         - into_subnets
         - through_dots

        """
        pass

    def QueryNodeOutputConnectedNodes(self, node_id, output_idx, into_subnets, through_dots, start, length):
        """
        Parameters:
         - node_id
         - output_idx
         - into_subnets
         - through_dots
         - start
         - length

        """
        pass

    def GetNodeOutputName(self, node_id, output_idx):
        """
        Parameters:
         - node_id
         - output_idx

        """
        pass

    def GetParameters(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        pass

    def GetParmInfo(self, node_id, parm_id):
        """
        Parameters:
         - node_id
         - parm_id

        """
        pass

    def GetParmIdFromName(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        pass

    def GetParmInfoFromName(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        pass

    def GetParmTagName(self, node_id, parm_id, tag_index):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_index

        """
        pass

    def GetParmTagValue(self, node_id, parm_id, tag_name):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_name

        """
        pass

    def ParmHasTag(self, node_id, parm_id, tag_name):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_name

        """
        pass

    def ParmHasExpression(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        pass

    def GetParmWithTag(self, node_id, tag_name):
        """
        Parameters:
         - node_id
         - tag_name

        """
        pass

    def GetParmExpression(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        pass

    def RevertParmToDefault(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        pass

    def RevertParmToDefaults(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        pass

    def SetParmExpression(self, node_id, value, parm_id, index):
        """
        Parameters:
         - node_id
         - value
         - parm_id
         - index

        """
        pass

    def RemoveParmExpression(self, node_id, parm_id, index):
        """
        Parameters:
         - node_id
         - parm_id
         - index

        """
        pass

    def GetParmIntValue(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        pass

    def GetParmIntValues(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        pass

    def GetParmFloatValue(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        pass

    def GetParmFloatValues(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        pass

    def GetParmStringValue(self, node_id, parm_name, index, evaluate):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - evaluate

        """
        pass

    def GetParmStringValues(self, node_id, evaluate, start, length):
        """
        Parameters:
         - node_id
         - evaluate
         - start
         - length

        """
        pass

    def GetParmNodeValue(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        pass

    def GetParmFile(self, node_id, parm_name, destination_directory, destination_file_name):
        """
        Parameters:
         - node_id
         - parm_name
         - destination_directory
         - destination_file_name

        """
        pass

    def GetParmChoiceLists(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        pass

    def SetParmIntValue(self, node_id, parm_name, index, value):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - value

        """
        pass

    def SetParmIntValues(self, node_id, values_array, start):
        """
        Parameters:
         - node_id
         - values_array
         - start

        """
        pass

    def SetParmFloatValue(self, node_id, parm_name, index, value):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - value

        """
        pass

    def SetParmFloatValues(self, node_id, values_array, start):
        """
        Parameters:
         - node_id
         - values_array
         - start

        """
        pass

    def SetParmStringValue(self, node_id, value, parm_id, index):
        """
        Parameters:
         - node_id
         - value
         - parm_id
         - index

        """
        pass

    def SetParmNodeValue(self, node_id, parm_name, value):
        """
        Parameters:
         - node_id
         - parm_name
         - value

        """
        pass

    def InsertMultiparmInstance(self, node_id, parm_id, instance_position):
        """
        Parameters:
         - node_id
         - parm_id
         - instance_position

        """
        pass

    def RemoveMultiparmInstance(self, node_id, parm_id, instance_position):
        """
        Parameters:
         - node_id
         - parm_id
         - instance_position

        """
        pass

    def GetHandleInfo(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        pass

    def GetHandleBindingInfo(self, node_id, handle_index, start, length):
        """
        Parameters:
         - node_id
         - handle_index
         - start
         - length

        """
        pass

    def GetPresetBufLength(self, node_id, preset_type, preset_name):
        """
        Parameters:
         - node_id
         - preset_type
         - preset_name

        """
        pass

    def GetPreset(self, node_id, buffer_length):
        """
        Parameters:
         - node_id
         - buffer_length

        """
        pass

    def SetPreset(self, node_id, preset_type, preset_name, buffer, buffer_length):
        """
        Parameters:
         - node_id
         - preset_type
         - preset_name
         - buffer
         - buffer_length

        """
        pass

    def GetObjectInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetObjectTransform(self, node_id, relative_to_node_id, rst_order):
        """
        Parameters:
         - node_id
         - relative_to_node_id
         - rst_order

        """
        pass

    def ComposeObjectList(self, parent_node_id, categories):
        """
        Parameters:
         - parent_node_id
         - categories

        """
        pass

    def GetComposedObjectList(self, parent_node_id, start, length):
        """
        Parameters:
         - parent_node_id
         - start
         - length

        """
        pass

    def GetComposedObjectTransforms(self, parent_node_id, rst_order, start, length):
        """
        Parameters:
         - parent_node_id
         - rst_order
         - start
         - length

        """
        pass

    def GetInstancedObjectIds(self, object_node_id, start, length):
        """
        Parameters:
         - object_node_id
         - start
         - length

        """
        pass

    def GetInstanceTransforms(self, object_node_id, rst_order, start, length):
        """
        Parameters:
         - object_node_id
         - rst_order
         - start
         - length

        """
        pass

    def GetInstanceTransformsOnPart(self, node_id, part_id, rst_order, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - rst_order
         - start
         - length

        """
        pass

    def SetObjectTransform(self, node_id, trans):
        """
        Parameters:
         - node_id
         - trans

        """
        pass

    def GetDisplayGeoInfo(self, object_node_id):
        """
        Parameters:
         - object_node_id

        """
        pass

    def GetGeoInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetPartInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetFaceCounts(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def GetVertexList(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def GetAttributeInfo(self, node_id, part_id, name, owner):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - owner

        """
        pass

    def GetAttributeNames(self, node_id, part_id, owner, count):
        """
        Parameters:
         - node_id
         - part_id
         - owner
         - count

        """
        pass

    def GetAttributeIntData(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        pass

    def GetAttributeInt64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        pass

    def GetAttributeFloatData(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        pass

    def GetAttributeFloat64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        pass

    def GetAttributeStringData(self, node_id, part_id, name, attr_info, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - start
         - length

        """
        pass

    def GetGroupNames(self, node_id, group_type, group_count):
        """
        Parameters:
         - node_id
         - group_type
         - group_count

        """
        pass

    def GetGroupMembership(self, node_id, part_id, group_type, group_name, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - start
         - length

        """
        pass

    def GetGroupCountOnPackedInstancePart(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetGroupNamesOnPackedInstancePart(self, node_id, part_id, group_type, group_count):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_count

        """
        pass

    def GetGroupMembershipOnPackedInstancePart(self, node_id, part_id, group_type, group_name, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - start
         - length

        """
        pass

    def GetInstancedPartIds(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def GetInstancerPartTransforms(self, node_id, part_id, rst_order, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - rst_order
         - start
         - length

        """
        pass

    def SetPartInfo(self, node_id, part_id, part_info):
        """
        Parameters:
         - node_id
         - part_id
         - part_info

        """
        pass

    def SetFaceCounts(self, node_id, part_id, face_counts_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - face_counts_array
         - start

        """
        pass

    def SetVertexList(self, node_id, part_id, vertex_list_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - vertex_list_array
         - start

        """
        pass

    def AddAttribute(self, node_id, part_id, name, attr_info):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info

        """
        pass

    def DeleteAttribute(self, node_id, part_id, name, attr_info):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info

        """
        pass

    def SetAttributeIntData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        pass

    def SetAttributeInt64Data(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        pass

    def SetAttributeFloatData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        pass

    def SetAttributeFloat64Data(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        pass

    def SetAttributeStringData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        pass

    def AddGroup(self, node_id, part_id, group_type, group_name):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name

        """
        pass

    def DeleteGroup(self, node_id, part_id, group_type, group_name):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name

        """
        pass

    def SetGroupMembership(self, node_id, part_id, group_type, group_name, membership_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - membership_array
         - start

        """
        pass

    def CommitGeo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def RevertGeo(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetMaterialNodeIdsOnFaces(self, geometry_node_id, part_id, start, length):
        """
        Parameters:
         - geometry_node_id
         - part_id
         - start
         - length

        """
        pass

    def GetMaterialInfo(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        pass

    def RenderCOPToImage(self, cop_node_id):
        """
        Parameters:
         - cop_node_id

        """
        pass

    def RenderTextureToImage(self, material_node_id, parm_id):
        """
        Parameters:
         - material_node_id
         - parm_id

        """
        pass

    def GetImageInfo(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        pass

    def SetImageInfo(self, material_node_id, image_info):
        """
        Parameters:
         - material_node_id
         - image_info

        """
        pass

    def GetImagePlaneCount(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        pass

    def GetImagePlanes(self, material_node_id, image_plane_count):
        """
        Parameters:
         - material_node_id
         - image_plane_count

        """
        pass

    def ExtractImageToFile(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes
         - destination_folder_path
         - destination_file_name

        """
        pass

    def GetImageFilePath(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name, texture_parm_id):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes
         - destination_folder_path
         - destination_file_name
         - texture_parm_id

        """
        pass

    def ExtractImageToMemory(self, material_node_id, image_file_format_name, image_planes):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes

        """
        pass

    def GetImageMemoryBuffer(self, material_node_id, length):
        """
        Parameters:
         - material_node_id
         - length

        """
        pass

    def GetSupportedImageFileFormatCount(self):
        pass

    def GetSupportedImageFileFormats(self, file_format_count):
        """
        Parameters:
         - file_format_count

        """
        pass

    def SetAnimCurve(self, node_id, parm_id, parm_index, curve_keyframes_array):
        """
        Parameters:
         - node_id
         - parm_id
         - parm_index
         - curve_keyframes_array

        """
        pass

    def SetTransformAnimCurve(self, node_id, trans_comp, curve_keyframes_array):
        """
        Parameters:
         - node_id
         - trans_comp
         - curve_keyframes_array

        """
        pass

    def ResetSimulation(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetVolumeInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetFirstVolumeTile(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetNextVolumeTile(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - value_count

        """
        pass

    def GetVolumeTileFloatData(self, node_id, part_id, fill_value, tile, length):
        """
        Parameters:
         - node_id
         - part_id
         - fill_value
         - tile
         - length

        """
        pass

    def GetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - value_count

        """
        pass

    def GetVolumeTileIntData(self, node_id, part_id, fill_value, tile, length):
        """
        Parameters:
         - node_id
         - part_id
         - fill_value
         - tile
         - length

        """
        pass

    def GetHeightFieldData(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def SetVolumeInfo(self, node_id, part_id, volume_info):
        """
        Parameters:
         - node_id
         - part_id
         - volume_info

        """
        pass

    def SetVolumeTileFloatData(self, node_id, part_id, tile, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - tile
         - values_array

        """
        pass

    def SetVolumeTileIntData(self, node_id, part_id, tile, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - tile
         - values_array

        """
        pass

    def SetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - values_array

        """
        pass

    def SetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - values_array

        """
        pass

    def GetVolumeBounds(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def SetHeightFieldData(self, node_id, part_id, name, values_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - values_array
         - start

        """
        pass

    def GetCurveInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        pass

    def GetCurveCounts(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def GetCurveOrders(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def GetCurveKnots(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        pass

    def SetCurveInfo(self, node_id, part_id, info):
        """
        Parameters:
         - node_id
         - part_id
         - info

        """
        pass

    def SetCurveCounts(self, node_id, part_id, counts_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - counts_array
         - start

        """
        pass

    def SetCurveOrders(self, node_id, part_id, orders_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - orders_array
         - start

        """
        pass

    def SetCurveKnots(self, node_id, part_id, knots_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - knots_array
         - start

        """
        pass

    def GetBoxInfo(self, geo_node_id, part_id):
        """
        Parameters:
         - geo_node_id
         - part_id

        """
        pass

    def GetSphereInfo(self, geo_node_id, part_id):
        """
        Parameters:
         - geo_node_id
         - part_id

        """
        pass

    def GetActiveCacheCount(self):
        pass

    def GetActiveCacheNames(self, active_cache_count):
        """
        Parameters:
         - active_cache_count

        """
        pass

    def GetCacheProperty(self, cache_name, cache_property):
        """
        Parameters:
         - cache_name
         - cache_property

        """
        pass

    def SetCacheProperty(self, cache_name, cache_property, property_value):
        """
        Parameters:
         - cache_name
         - cache_property
         - property_value

        """
        pass

    def SaveGeoToFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        pass

    def LoadGeoFromFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        pass

    def SaveNodeToFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        pass

    def LoadNodeFromFile(self, file_name, parent_node_id, node_label, cook_on_load):
        """
        Parameters:
         - file_name
         - parent_node_id
         - node_label
         - cook_on_load

        """
        pass

    def GetGeoSize(self, node_id, format):
        """
        Parameters:
         - node_id
         - format

        """
        pass

    def SaveGeoToMemory(self, node_id, length):
        """
        Parameters:
         - node_id
         - length

        """
        pass

    def LoadGeoFromMemory(self, node_id, format, buffer, length):
        """
        Parameters:
         - node_id
         - format
         - buffer
         - length

        """
        pass

    def SetNodeDisplay(self, node_id, onOff):
        """
        Parameters:
         - node_id
         - onOff

        """
        pass

    def GetTotalCookCount(self, node_id, node_type_filter, node_flags_filter, recursive):
        """
        Parameters:
         - node_id
         - node_type_filter
         - node_flags_filter
         - recursive

        """
        pass

    def SetSessionSync(self, enable):
        """
        Parameters:
         - enable

        """
        pass

    def GetViewport(self):
        pass

    def SetViewport(self, viewport):
        """
        Parameters:
         - viewport

        """
        pass

    def GetSessionSyncInfo(self):
        pass

    def SetSessionSyncInfo(self, session_sync_info):
        """
        Parameters:
         - session_sync_info

        """
        pass

    def GetPDGGraphContexts(self, count):
        """
        Parameters:
         - count

        """
        pass

    def GetPDGGraphContextId(self, top_node_id):
        """
        Parameters:
         - top_node_id

        """
        pass

    def CookPDG(self, cook_node_id, generate_only, blocking):
        """
        Parameters:
         - cook_node_id
         - generate_only
         - blocking

        """
        pass

    def GetPDGEvents(self, graph_context_id, length):
        """
        Parameters:
         - graph_context_id
         - length

        """
        pass

    def GetPDGState(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        pass

    def CreateWorkitem(self, node_id, name, index):
        """
        Parameters:
         - node_id
         - name
         - index

        """
        pass

    def GetWorkitemInfo(self, graph_context_id, workitem_id):
        """
        Parameters:
         - graph_context_id
         - workitem_id

        """
        pass

    def SetWorkitemIntData(self, node_id, workitem_id, data_name, values_array):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - values_array

        """
        pass

    def SetWorkitemFloatData(self, node_id, workitem_id, data_name, values_array):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - values_array

        """
        pass

    def SetWorkitemStringData(self, node_id, workitem_id, data_name, data_index, value):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - data_index
         - value

        """
        pass

    def CommitWorkitems(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetNumWorkitems(self, node_id):
        """
        Parameters:
         - node_id

        """
        pass

    def GetWorkitems(self, node_id, length):
        """
        Parameters:
         - node_id
         - length

        """
        pass

    def GetWorkitemDataLength(self, node_id, workitem_id, data_name):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name

        """
        pass

    def GetWorkitemIntData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        pass

    def GetWorkitemFloatData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        pass

    def GetWorkitemStringData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        pass

    def GetWorkitemResultInfo(self, node_id, workitem_id, resultinfo_count):
        """
        Parameters:
         - node_id
         - workitem_id
         - resultinfo_count

        """
        pass

    def DirtyPDGNode(self, node_id, clean_results):
        """
        Parameters:
         - node_id
         - clean_results

        """
        pass

    def PausePDGCook(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        pass

    def CancelPDGCook(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def IsInitialized(self):
        self.send_IsInitialized()
        return self.recv_IsInitialized()

    def send_IsInitialized(self):
        self._oprot.writeMessageBegin('IsInitialized', TMessageType.CALL, self._seqid)
        args = IsInitialized_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_IsInitialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = IsInitialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "IsInitialized failed: unknown result")

    def Initialize(self, cook_options, use_cooking_thread, cooking_thread_stack_size, houdini_environment_files, otl_search_path, dso_search_path, image_dso_search_path, audio_dso_search_path):
        """
        Parameters:
         - cook_options
         - use_cooking_thread
         - cooking_thread_stack_size
         - houdini_environment_files
         - otl_search_path
         - dso_search_path
         - image_dso_search_path
         - audio_dso_search_path

        """
        self.send_Initialize(cook_options, use_cooking_thread, cooking_thread_stack_size, houdini_environment_files, otl_search_path, dso_search_path, image_dso_search_path, audio_dso_search_path)
        return self.recv_Initialize()

    def send_Initialize(self, cook_options, use_cooking_thread, cooking_thread_stack_size, houdini_environment_files, otl_search_path, dso_search_path, image_dso_search_path, audio_dso_search_path):
        self._oprot.writeMessageBegin('Initialize', TMessageType.CALL, self._seqid)
        args = Initialize_args()
        args.cook_options = cook_options
        args.use_cooking_thread = use_cooking_thread
        args.cooking_thread_stack_size = cooking_thread_stack_size
        args.houdini_environment_files = houdini_environment_files
        args.otl_search_path = otl_search_path
        args.dso_search_path = dso_search_path
        args.image_dso_search_path = image_dso_search_path
        args.audio_dso_search_path = audio_dso_search_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Initialize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Initialize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Initialize failed: unknown result")

    def Cleanup(self):
        self.send_Cleanup()
        return self.recv_Cleanup()

    def send_Cleanup(self):
        self._oprot.writeMessageBegin('Cleanup', TMessageType.CALL, self._seqid)
        args = Cleanup_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Cleanup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Cleanup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Cleanup failed: unknown result")

    def GetSessionEnvInt(self, int_type):
        """
        Parameters:
         - int_type

        """
        self.send_GetSessionEnvInt(int_type)
        return self.recv_GetSessionEnvInt()

    def send_GetSessionEnvInt(self, int_type):
        self._oprot.writeMessageBegin('GetSessionEnvInt', TMessageType.CALL, self._seqid)
        args = GetSessionEnvInt_args()
        args.int_type = int_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSessionEnvInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSessionEnvInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSessionEnvInt failed: unknown result")

    def GetServerEnvInt(self, variable_name):
        """
        Parameters:
         - variable_name

        """
        self.send_GetServerEnvInt(variable_name)
        return self.recv_GetServerEnvInt()

    def send_GetServerEnvInt(self, variable_name):
        self._oprot.writeMessageBegin('GetServerEnvInt', TMessageType.CALL, self._seqid)
        args = GetServerEnvInt_args()
        args.variable_name = variable_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetServerEnvInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetServerEnvInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetServerEnvInt failed: unknown result")

    def GetServerEnvString(self, variable_name):
        """
        Parameters:
         - variable_name

        """
        self.send_GetServerEnvString(variable_name)
        return self.recv_GetServerEnvString()

    def send_GetServerEnvString(self, variable_name):
        self._oprot.writeMessageBegin('GetServerEnvString', TMessageType.CALL, self._seqid)
        args = GetServerEnvString_args()
        args.variable_name = variable_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetServerEnvString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetServerEnvString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetServerEnvString failed: unknown result")

    def GetServerEnvVarCount(self):
        self.send_GetServerEnvVarCount()
        return self.recv_GetServerEnvVarCount()

    def send_GetServerEnvVarCount(self):
        self._oprot.writeMessageBegin('GetServerEnvVarCount', TMessageType.CALL, self._seqid)
        args = GetServerEnvVarCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetServerEnvVarCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetServerEnvVarCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetServerEnvVarCount failed: unknown result")

    def GetServerEnvVarList(self, start, length):
        """
        Parameters:
         - start
         - length

        """
        self.send_GetServerEnvVarList(start, length)
        return self.recv_GetServerEnvVarList()

    def send_GetServerEnvVarList(self, start, length):
        self._oprot.writeMessageBegin('GetServerEnvVarList', TMessageType.CALL, self._seqid)
        args = GetServerEnvVarList_args()
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetServerEnvVarList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetServerEnvVarList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetServerEnvVarList failed: unknown result")

    def SetServerEnvInt(self, variable_name, value):
        """
        Parameters:
         - variable_name
         - value

        """
        self.send_SetServerEnvInt(variable_name, value)
        return self.recv_SetServerEnvInt()

    def send_SetServerEnvInt(self, variable_name, value):
        self._oprot.writeMessageBegin('SetServerEnvInt', TMessageType.CALL, self._seqid)
        args = SetServerEnvInt_args()
        args.variable_name = variable_name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetServerEnvInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetServerEnvInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetServerEnvInt failed: unknown result")

    def SetServerEnvString(self, variable_name, value):
        """
        Parameters:
         - variable_name
         - value

        """
        self.send_SetServerEnvString(variable_name, value)
        return self.recv_SetServerEnvString()

    def send_SetServerEnvString(self, variable_name, value):
        self._oprot.writeMessageBegin('SetServerEnvString', TMessageType.CALL, self._seqid)
        args = SetServerEnvString_args()
        args.variable_name = variable_name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetServerEnvString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetServerEnvString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetServerEnvString failed: unknown result")

    def GetStatus(self, status_type):
        """
        Parameters:
         - status_type

        """
        self.send_GetStatus(status_type)
        return self.recv_GetStatus()

    def send_GetStatus(self, status_type):
        self._oprot.writeMessageBegin('GetStatus', TMessageType.CALL, self._seqid)
        args = GetStatus_args()
        args.status_type = status_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStatus failed: unknown result")

    def GetStatusStringBufLength(self, status_type, verbosity):
        """
        Parameters:
         - status_type
         - verbosity

        """
        self.send_GetStatusStringBufLength(status_type, verbosity)
        return self.recv_GetStatusStringBufLength()

    def send_GetStatusStringBufLength(self, status_type, verbosity):
        self._oprot.writeMessageBegin('GetStatusStringBufLength', TMessageType.CALL, self._seqid)
        args = GetStatusStringBufLength_args()
        args.status_type = status_type
        args.verbosity = verbosity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStatusStringBufLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStatusStringBufLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStatusStringBufLength failed: unknown result")

    def GetStatusString(self, status_type, length):
        """
        Parameters:
         - status_type
         - length

        """
        self.send_GetStatusString(status_type, length)
        return self.recv_GetStatusString()

    def send_GetStatusString(self, status_type, length):
        self._oprot.writeMessageBegin('GetStatusString', TMessageType.CALL, self._seqid)
        args = GetStatusString_args()
        args.status_type = status_type
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStatusString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStatusString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStatusString failed: unknown result")

    def ComposeNodeCookResult(self, node_id, verbosity):
        """
        Parameters:
         - node_id
         - verbosity

        """
        self.send_ComposeNodeCookResult(node_id, verbosity)
        return self.recv_ComposeNodeCookResult()

    def send_ComposeNodeCookResult(self, node_id, verbosity):
        self._oprot.writeMessageBegin('ComposeNodeCookResult', TMessageType.CALL, self._seqid)
        args = ComposeNodeCookResult_args()
        args.node_id = node_id
        args.verbosity = verbosity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ComposeNodeCookResult(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ComposeNodeCookResult_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ComposeNodeCookResult failed: unknown result")

    def GetComposedNodeCookResult(self, length):
        """
        Parameters:
         - length

        """
        self.send_GetComposedNodeCookResult(length)
        return self.recv_GetComposedNodeCookResult()

    def send_GetComposedNodeCookResult(self, length):
        self._oprot.writeMessageBegin('GetComposedNodeCookResult', TMessageType.CALL, self._seqid)
        args = GetComposedNodeCookResult_args()
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetComposedNodeCookResult(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetComposedNodeCookResult_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetComposedNodeCookResult failed: unknown result")

    def CheckForSpecificErrors(self, node_id, errors_to_look_for):
        """
        Parameters:
         - node_id
         - errors_to_look_for

        """
        self.send_CheckForSpecificErrors(node_id, errors_to_look_for)
        return self.recv_CheckForSpecificErrors()

    def send_CheckForSpecificErrors(self, node_id, errors_to_look_for):
        self._oprot.writeMessageBegin('CheckForSpecificErrors', TMessageType.CALL, self._seqid)
        args = CheckForSpecificErrors_args()
        args.node_id = node_id
        args.errors_to_look_for = errors_to_look_for
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CheckForSpecificErrors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CheckForSpecificErrors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckForSpecificErrors failed: unknown result")

    def GetCookingTotalCount(self):
        self.send_GetCookingTotalCount()
        return self.recv_GetCookingTotalCount()

    def send_GetCookingTotalCount(self):
        self._oprot.writeMessageBegin('GetCookingTotalCount', TMessageType.CALL, self._seqid)
        args = GetCookingTotalCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCookingTotalCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCookingTotalCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCookingTotalCount failed: unknown result")

    def GetCookingCurrentCount(self):
        self.send_GetCookingCurrentCount()
        return self.recv_GetCookingCurrentCount()

    def send_GetCookingCurrentCount(self):
        self._oprot.writeMessageBegin('GetCookingCurrentCount', TMessageType.CALL, self._seqid)
        args = GetCookingCurrentCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCookingCurrentCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCookingCurrentCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCookingCurrentCount failed: unknown result")

    def ConvertTransform(self, transform_in, rst_order, rot_order):
        """
        Parameters:
         - transform_in
         - rst_order
         - rot_order

        """
        self.send_ConvertTransform(transform_in, rst_order, rot_order)
        return self.recv_ConvertTransform()

    def send_ConvertTransform(self, transform_in, rst_order, rot_order):
        self._oprot.writeMessageBegin('ConvertTransform', TMessageType.CALL, self._seqid)
        args = ConvertTransform_args()
        args.transform_in = transform_in
        args.rst_order = rst_order
        args.rot_order = rot_order
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConvertTransform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConvertTransform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConvertTransform failed: unknown result")

    def ConvertMatrixToQuat(self, matrix, rst_order):
        """
        Parameters:
         - matrix
         - rst_order

        """
        self.send_ConvertMatrixToQuat(matrix, rst_order)
        return self.recv_ConvertMatrixToQuat()

    def send_ConvertMatrixToQuat(self, matrix, rst_order):
        self._oprot.writeMessageBegin('ConvertMatrixToQuat', TMessageType.CALL, self._seqid)
        args = ConvertMatrixToQuat_args()
        args.matrix = matrix
        args.rst_order = rst_order
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConvertMatrixToQuat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConvertMatrixToQuat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConvertMatrixToQuat failed: unknown result")

    def ConvertMatrixToEuler(self, matrix, rst_order, rot_order):
        """
        Parameters:
         - matrix
         - rst_order
         - rot_order

        """
        self.send_ConvertMatrixToEuler(matrix, rst_order, rot_order)
        return self.recv_ConvertMatrixToEuler()

    def send_ConvertMatrixToEuler(self, matrix, rst_order, rot_order):
        self._oprot.writeMessageBegin('ConvertMatrixToEuler', TMessageType.CALL, self._seqid)
        args = ConvertMatrixToEuler_args()
        args.matrix = matrix
        args.rst_order = rst_order
        args.rot_order = rot_order
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConvertMatrixToEuler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConvertMatrixToEuler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConvertMatrixToEuler failed: unknown result")

    def ConvertTransformQuatToMatrix(self, transform):
        """
        Parameters:
         - transform

        """
        self.send_ConvertTransformQuatToMatrix(transform)
        return self.recv_ConvertTransformQuatToMatrix()

    def send_ConvertTransformQuatToMatrix(self, transform):
        self._oprot.writeMessageBegin('ConvertTransformQuatToMatrix', TMessageType.CALL, self._seqid)
        args = ConvertTransformQuatToMatrix_args()
        args.transform = transform
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConvertTransformQuatToMatrix(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConvertTransformQuatToMatrix_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConvertTransformQuatToMatrix failed: unknown result")

    def ConvertTransformEulerToMatrix(self, transform):
        """
        Parameters:
         - transform

        """
        self.send_ConvertTransformEulerToMatrix(transform)
        return self.recv_ConvertTransformEulerToMatrix()

    def send_ConvertTransformEulerToMatrix(self, transform):
        self._oprot.writeMessageBegin('ConvertTransformEulerToMatrix', TMessageType.CALL, self._seqid)
        args = ConvertTransformEulerToMatrix_args()
        args.transform = transform
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConvertTransformEulerToMatrix(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConvertTransformEulerToMatrix_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConvertTransformEulerToMatrix failed: unknown result")

    def PythonThreadInterpreterLock(self, locked):
        """
        Parameters:
         - locked

        """
        self.send_PythonThreadInterpreterLock(locked)
        return self.recv_PythonThreadInterpreterLock()

    def send_PythonThreadInterpreterLock(self, locked):
        self._oprot.writeMessageBegin('PythonThreadInterpreterLock', TMessageType.CALL, self._seqid)
        args = PythonThreadInterpreterLock_args()
        args.locked = locked
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_PythonThreadInterpreterLock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = PythonThreadInterpreterLock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "PythonThreadInterpreterLock failed: unknown result")

    def GetStringBufLength(self, string_handle):
        """
        Parameters:
         - string_handle

        """
        self.send_GetStringBufLength(string_handle)
        return self.recv_GetStringBufLength()

    def send_GetStringBufLength(self, string_handle):
        self._oprot.writeMessageBegin('GetStringBufLength', TMessageType.CALL, self._seqid)
        args = GetStringBufLength_args()
        args.string_handle = string_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStringBufLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStringBufLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStringBufLength failed: unknown result")

    def GetString(self, string_handle, length):
        """
        Parameters:
         - string_handle
         - length

        """
        self.send_GetString(string_handle, length)
        return self.recv_GetString()

    def send_GetString(self, string_handle, length):
        self._oprot.writeMessageBegin('GetString', TMessageType.CALL, self._seqid)
        args = GetString_args()
        args.string_handle = string_handle
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetString failed: unknown result")

    def SetCustomString(self, string_value):
        """
        Parameters:
         - string_value

        """
        self.send_SetCustomString(string_value)
        return self.recv_SetCustomString()

    def send_SetCustomString(self, string_value):
        self._oprot.writeMessageBegin('SetCustomString', TMessageType.CALL, self._seqid)
        args = SetCustomString_args()
        args.string_value = string_value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCustomString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCustomString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCustomString failed: unknown result")

    def RemoveCustomString(self, string_handle):
        """
        Parameters:
         - string_handle

        """
        self.send_RemoveCustomString(string_handle)
        return self.recv_RemoveCustomString()

    def send_RemoveCustomString(self, string_handle):
        self._oprot.writeMessageBegin('RemoveCustomString', TMessageType.CALL, self._seqid)
        args = RemoveCustomString_args()
        args.string_handle = string_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RemoveCustomString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RemoveCustomString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveCustomString failed: unknown result")

    def GetStringBatchSize(self, string_handle_array):
        """
        Parameters:
         - string_handle_array

        """
        self.send_GetStringBatchSize(string_handle_array)
        return self.recv_GetStringBatchSize()

    def send_GetStringBatchSize(self, string_handle_array):
        self._oprot.writeMessageBegin('GetStringBatchSize', TMessageType.CALL, self._seqid)
        args = GetStringBatchSize_args()
        args.string_handle_array = string_handle_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStringBatchSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStringBatchSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStringBatchSize failed: unknown result")

    def GetStringBatch(self, char_array_length):
        """
        Parameters:
         - char_array_length

        """
        self.send_GetStringBatch(char_array_length)
        return self.recv_GetStringBatch()

    def send_GetStringBatch(self, char_array_length):
        self._oprot.writeMessageBegin('GetStringBatch', TMessageType.CALL, self._seqid)
        args = GetStringBatch_args()
        args.char_array_length = char_array_length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStringBatch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStringBatch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStringBatch failed: unknown result")

    def GetTime(self):
        self.send_GetTime()
        return self.recv_GetTime()

    def send_GetTime(self):
        self._oprot.writeMessageBegin('GetTime', TMessageType.CALL, self._seqid)
        args = GetTime_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTime failed: unknown result")

    def SetTime(self, time):
        """
        Parameters:
         - time

        """
        self.send_SetTime(time)
        return self.recv_SetTime()

    def send_SetTime(self, time):
        self._oprot.writeMessageBegin('SetTime', TMessageType.CALL, self._seqid)
        args = SetTime_args()
        args.time = time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetTime failed: unknown result")

    def GetUseHoudiniTime(self):
        self.send_GetUseHoudiniTime()
        return self.recv_GetUseHoudiniTime()

    def send_GetUseHoudiniTime(self):
        self._oprot.writeMessageBegin('GetUseHoudiniTime', TMessageType.CALL, self._seqid)
        args = GetUseHoudiniTime_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetUseHoudiniTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetUseHoudiniTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetUseHoudiniTime failed: unknown result")

    def SetUseHoudiniTime(self, enabled):
        """
        Parameters:
         - enabled

        """
        self.send_SetUseHoudiniTime(enabled)
        return self.recv_SetUseHoudiniTime()

    def send_SetUseHoudiniTime(self, enabled):
        self._oprot.writeMessageBegin('SetUseHoudiniTime', TMessageType.CALL, self._seqid)
        args = SetUseHoudiniTime_args()
        args.enabled = enabled
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetUseHoudiniTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetUseHoudiniTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetUseHoudiniTime failed: unknown result")

    def GetTimelineOptions(self):
        self.send_GetTimelineOptions()
        return self.recv_GetTimelineOptions()

    def send_GetTimelineOptions(self):
        self._oprot.writeMessageBegin('GetTimelineOptions', TMessageType.CALL, self._seqid)
        args = GetTimelineOptions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetTimelineOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetTimelineOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTimelineOptions failed: unknown result")

    def SetTimelineOptions(self, timeline_options):
        """
        Parameters:
         - timeline_options

        """
        self.send_SetTimelineOptions(timeline_options)
        return self.recv_SetTimelineOptions()

    def send_SetTimelineOptions(self, timeline_options):
        self._oprot.writeMessageBegin('SetTimelineOptions', TMessageType.CALL, self._seqid)
        args = SetTimelineOptions_args()
        args.timeline_options = timeline_options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetTimelineOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetTimelineOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetTimelineOptions failed: unknown result")

    def LoadAssetLibraryFromFile(self, file_path, allow_overwrite):
        """
        Parameters:
         - file_path
         - allow_overwrite

        """
        self.send_LoadAssetLibraryFromFile(file_path, allow_overwrite)
        return self.recv_LoadAssetLibraryFromFile()

    def send_LoadAssetLibraryFromFile(self, file_path, allow_overwrite):
        self._oprot.writeMessageBegin('LoadAssetLibraryFromFile', TMessageType.CALL, self._seqid)
        args = LoadAssetLibraryFromFile_args()
        args.file_path = file_path
        args.allow_overwrite = allow_overwrite
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadAssetLibraryFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadAssetLibraryFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadAssetLibraryFromFile failed: unknown result")

    def LoadAssetLibraryFromMemory(self, library_buffer, library_buffer_length, allow_overwrite):
        """
        Parameters:
         - library_buffer
         - library_buffer_length
         - allow_overwrite

        """
        self.send_LoadAssetLibraryFromMemory(library_buffer, library_buffer_length, allow_overwrite)
        return self.recv_LoadAssetLibraryFromMemory()

    def send_LoadAssetLibraryFromMemory(self, library_buffer, library_buffer_length, allow_overwrite):
        self._oprot.writeMessageBegin('LoadAssetLibraryFromMemory', TMessageType.CALL, self._seqid)
        args = LoadAssetLibraryFromMemory_args()
        args.library_buffer = library_buffer
        args.library_buffer_length = library_buffer_length
        args.allow_overwrite = allow_overwrite
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadAssetLibraryFromMemory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadAssetLibraryFromMemory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadAssetLibraryFromMemory failed: unknown result")

    def GetAvailableAssetCount(self, library_id):
        """
        Parameters:
         - library_id

        """
        self.send_GetAvailableAssetCount(library_id)
        return self.recv_GetAvailableAssetCount()

    def send_GetAvailableAssetCount(self, library_id):
        self._oprot.writeMessageBegin('GetAvailableAssetCount', TMessageType.CALL, self._seqid)
        args = GetAvailableAssetCount_args()
        args.library_id = library_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAvailableAssetCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAvailableAssetCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAvailableAssetCount failed: unknown result")

    def GetAvailableAssets(self, library_id, asset_count):
        """
        Parameters:
         - library_id
         - asset_count

        """
        self.send_GetAvailableAssets(library_id, asset_count)
        return self.recv_GetAvailableAssets()

    def send_GetAvailableAssets(self, library_id, asset_count):
        self._oprot.writeMessageBegin('GetAvailableAssets', TMessageType.CALL, self._seqid)
        args = GetAvailableAssets_args()
        args.library_id = library_id
        args.asset_count = asset_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAvailableAssets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAvailableAssets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAvailableAssets failed: unknown result")

    def GetAssetInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_GetAssetInfo(node_id)
        return self.recv_GetAssetInfo()

    def send_GetAssetInfo(self, node_id):
        self._oprot.writeMessageBegin('GetAssetInfo', TMessageType.CALL, self._seqid)
        args = GetAssetInfo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAssetInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAssetInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssetInfo failed: unknown result")

    def GetAssetDefinitionParmCounts(self, library_id, asset_name):
        """
        Parameters:
         - library_id
         - asset_name

        """
        self.send_GetAssetDefinitionParmCounts(library_id, asset_name)
        return self.recv_GetAssetDefinitionParmCounts()

    def send_GetAssetDefinitionParmCounts(self, library_id, asset_name):
        self._oprot.writeMessageBegin('GetAssetDefinitionParmCounts', TMessageType.CALL, self._seqid)
        args = GetAssetDefinitionParmCounts_args()
        args.library_id = library_id
        args.asset_name = asset_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAssetDefinitionParmCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAssetDefinitionParmCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssetDefinitionParmCounts failed: unknown result")

    def GetAssetDefinitionParmInfos(self, library_id, asset_name, start, length):
        """
        Parameters:
         - library_id
         - asset_name
         - start
         - length

        """
        self.send_GetAssetDefinitionParmInfos(library_id, asset_name, start, length)
        return self.recv_GetAssetDefinitionParmInfos()

    def send_GetAssetDefinitionParmInfos(self, library_id, asset_name, start, length):
        self._oprot.writeMessageBegin('GetAssetDefinitionParmInfos', TMessageType.CALL, self._seqid)
        args = GetAssetDefinitionParmInfos_args()
        args.library_id = library_id
        args.asset_name = asset_name
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAssetDefinitionParmInfos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAssetDefinitionParmInfos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssetDefinitionParmInfos failed: unknown result")

    def GetAssetDefinitionParmValues(self, library_id, asset_name, int_start, int_length, float_start, float_length, string_evaluate, string_start, string_length, choice_start, choice_length):
        """
        Parameters:
         - library_id
         - asset_name
         - int_start
         - int_length
         - float_start
         - float_length
         - string_evaluate
         - string_start
         - string_length
         - choice_start
         - choice_length

        """
        self.send_GetAssetDefinitionParmValues(library_id, asset_name, int_start, int_length, float_start, float_length, string_evaluate, string_start, string_length, choice_start, choice_length)
        return self.recv_GetAssetDefinitionParmValues()

    def send_GetAssetDefinitionParmValues(self, library_id, asset_name, int_start, int_length, float_start, float_length, string_evaluate, string_start, string_length, choice_start, choice_length):
        self._oprot.writeMessageBegin('GetAssetDefinitionParmValues', TMessageType.CALL, self._seqid)
        args = GetAssetDefinitionParmValues_args()
        args.library_id = library_id
        args.asset_name = asset_name
        args.int_start = int_start
        args.int_length = int_length
        args.float_start = float_start
        args.float_length = float_length
        args.string_evaluate = string_evaluate
        args.string_start = string_start
        args.string_length = string_length
        args.choice_start = choice_start
        args.choice_length = choice_length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAssetDefinitionParmValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAssetDefinitionParmValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAssetDefinitionParmValues failed: unknown result")

    def Interrupt(self):
        self.send_Interrupt()
        return self.recv_Interrupt()

    def send_Interrupt(self):
        self._oprot.writeMessageBegin('Interrupt', TMessageType.CALL, self._seqid)
        args = Interrupt_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Interrupt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Interrupt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Interrupt failed: unknown result")

    def LoadHIPFile(self, file_name, cook_on_load):
        """
        Parameters:
         - file_name
         - cook_on_load

        """
        self.send_LoadHIPFile(file_name, cook_on_load)
        return self.recv_LoadHIPFile()

    def send_LoadHIPFile(self, file_name, cook_on_load):
        self._oprot.writeMessageBegin('LoadHIPFile', TMessageType.CALL, self._seqid)
        args = LoadHIPFile_args()
        args.file_name = file_name
        args.cook_on_load = cook_on_load
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadHIPFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadHIPFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadHIPFile failed: unknown result")

    def SaveHIPFile(self, file_path, lock_nodes):
        """
        Parameters:
         - file_path
         - lock_nodes

        """
        self.send_SaveHIPFile(file_path, lock_nodes)
        return self.recv_SaveHIPFile()

    def send_SaveHIPFile(self, file_path, lock_nodes):
        self._oprot.writeMessageBegin('SaveHIPFile', TMessageType.CALL, self._seqid)
        args = SaveHIPFile_args()
        args.file_path = file_path
        args.lock_nodes = lock_nodes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SaveHIPFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SaveHIPFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SaveHIPFile failed: unknown result")

    def IsNodeValid(self, node_id, unique_node_id):
        """
        Parameters:
         - node_id
         - unique_node_id

        """
        self.send_IsNodeValid(node_id, unique_node_id)
        return self.recv_IsNodeValid()

    def send_IsNodeValid(self, node_id, unique_node_id):
        self._oprot.writeMessageBegin('IsNodeValid', TMessageType.CALL, self._seqid)
        args = IsNodeValid_args()
        args.node_id = node_id
        args.unique_node_id = unique_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_IsNodeValid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = IsNodeValid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "IsNodeValid failed: unknown result")

    def GetNodeInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_GetNodeInfo(node_id)
        return self.recv_GetNodeInfo()

    def send_GetNodeInfo(self, node_id):
        self._oprot.writeMessageBegin('GetNodeInfo', TMessageType.CALL, self._seqid)
        args = GetNodeInfo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNodeInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNodeInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeInfo failed: unknown result")

    def GetNodePath(self, node_id, relative_to_node_id):
        """
        Parameters:
         - node_id
         - relative_to_node_id

        """
        self.send_GetNodePath(node_id, relative_to_node_id)
        return self.recv_GetNodePath()

    def send_GetNodePath(self, node_id, relative_to_node_id):
        self._oprot.writeMessageBegin('GetNodePath', TMessageType.CALL, self._seqid)
        args = GetNodePath_args()
        args.node_id = node_id
        args.relative_to_node_id = relative_to_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNodePath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNodePath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodePath failed: unknown result")

    def GetManagerNodeId(self, node_type):
        """
        Parameters:
         - node_type

        """
        self.send_GetManagerNodeId(node_type)
        return self.recv_GetManagerNodeId()

    def send_GetManagerNodeId(self, node_type):
        self._oprot.writeMessageBegin('GetManagerNodeId', TMessageType.CALL, self._seqid)
        args = GetManagerNodeId_args()
        args.node_type = node_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetManagerNodeId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetManagerNodeId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetManagerNodeId failed: unknown result")

    def ComposeChildNodeList(self, parent_node_id, node_type_filter, node_flags_filter, recursive):
        """
        Parameters:
         - parent_node_id
         - node_type_filter
         - node_flags_filter
         - recursive

        """
        self.send_ComposeChildNodeList(parent_node_id, node_type_filter, node_flags_filter, recursive)
        return self.recv_ComposeChildNodeList()

    def send_ComposeChildNodeList(self, parent_node_id, node_type_filter, node_flags_filter, recursive):
        self._oprot.writeMessageBegin('ComposeChildNodeList', TMessageType.CALL, self._seqid)
        args = ComposeChildNodeList_args()
        args.parent_node_id = parent_node_id
        args.node_type_filter = node_type_filter
        args.node_flags_filter = node_flags_filter
        args.recursive = recursive
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ComposeChildNodeList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ComposeChildNodeList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ComposeChildNodeList failed: unknown result")

    def GetComposedChildNodeList(self, parent_node_id, count):
        """
        Parameters:
         - parent_node_id
         - count

        """
        self.send_GetComposedChildNodeList(parent_node_id, count)
        return self.recv_GetComposedChildNodeList()

    def send_GetComposedChildNodeList(self, parent_node_id, count):
        self._oprot.writeMessageBegin('GetComposedChildNodeList', TMessageType.CALL, self._seqid)
        args = GetComposedChildNodeList_args()
        args.parent_node_id = parent_node_id
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetComposedChildNodeList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetComposedChildNodeList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetComposedChildNodeList failed: unknown result")

    def CreateNode(self, parent_node_id, operator_name, node_label, cook_on_creation):
        """
        Parameters:
         - parent_node_id
         - operator_name
         - node_label
         - cook_on_creation

        """
        self.send_CreateNode(parent_node_id, operator_name, node_label, cook_on_creation)
        return self.recv_CreateNode()

    def send_CreateNode(self, parent_node_id, operator_name, node_label, cook_on_creation):
        self._oprot.writeMessageBegin('CreateNode', TMessageType.CALL, self._seqid)
        args = CreateNode_args()
        args.parent_node_id = parent_node_id
        args.operator_name = operator_name
        args.node_label = node_label
        args.cook_on_creation = cook_on_creation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateNode failed: unknown result")

    def CreateInputNode(self, name):
        """
        Parameters:
         - name

        """
        self.send_CreateInputNode(name)
        return self.recv_CreateInputNode()

    def send_CreateInputNode(self, name):
        self._oprot.writeMessageBegin('CreateInputNode', TMessageType.CALL, self._seqid)
        args = CreateInputNode_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateInputNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateInputNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateInputNode failed: unknown result")

    def CreateHeightfieldInputNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize

        """
        self.send_CreateHeightfieldInputNode(parent_node_id, name, xsize, ysize, voxelsize)
        return self.recv_CreateHeightfieldInputNode()

    def send_CreateHeightfieldInputNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        self._oprot.writeMessageBegin('CreateHeightfieldInputNode', TMessageType.CALL, self._seqid)
        args = CreateHeightfieldInputNode_args()
        args.parent_node_id = parent_node_id
        args.name = name
        args.xsize = xsize
        args.ysize = ysize
        args.voxelsize = voxelsize
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateHeightfieldInputNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateHeightfieldInputNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateHeightfieldInputNode failed: unknown result")

    def CreateHeightFieldInput(self, parent_node_id, name, xsize, ysize, voxelsize, sampling):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize
         - sampling

        """
        self.send_CreateHeightFieldInput(parent_node_id, name, xsize, ysize, voxelsize, sampling)
        return self.recv_CreateHeightFieldInput()

    def send_CreateHeightFieldInput(self, parent_node_id, name, xsize, ysize, voxelsize, sampling):
        self._oprot.writeMessageBegin('CreateHeightFieldInput', TMessageType.CALL, self._seqid)
        args = CreateHeightFieldInput_args()
        args.parent_node_id = parent_node_id
        args.name = name
        args.xsize = xsize
        args.ysize = ysize
        args.voxelsize = voxelsize
        args.sampling = sampling
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateHeightFieldInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateHeightFieldInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateHeightFieldInput failed: unknown result")

    def CreateHeightfieldInputVolumeNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        """
        Parameters:
         - parent_node_id
         - name
         - xsize
         - ysize
         - voxelsize

        """
        self.send_CreateHeightfieldInputVolumeNode(parent_node_id, name, xsize, ysize, voxelsize)
        return self.recv_CreateHeightfieldInputVolumeNode()

    def send_CreateHeightfieldInputVolumeNode(self, parent_node_id, name, xsize, ysize, voxelsize):
        self._oprot.writeMessageBegin('CreateHeightfieldInputVolumeNode', TMessageType.CALL, self._seqid)
        args = CreateHeightfieldInputVolumeNode_args()
        args.parent_node_id = parent_node_id
        args.name = name
        args.xsize = xsize
        args.ysize = ysize
        args.voxelsize = voxelsize
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateHeightfieldInputVolumeNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateHeightfieldInputVolumeNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateHeightfieldInputVolumeNode failed: unknown result")

    def CookNode(self, node_id, cook_options):
        """
        Parameters:
         - node_id
         - cook_options

        """
        self.send_CookNode(node_id, cook_options)
        return self.recv_CookNode()

    def send_CookNode(self, node_id, cook_options):
        self._oprot.writeMessageBegin('CookNode', TMessageType.CALL, self._seqid)
        args = CookNode_args()
        args.node_id = node_id
        args.cook_options = cook_options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CookNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CookNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CookNode failed: unknown result")

    def DeleteNode(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_DeleteNode(node_id)
        return self.recv_DeleteNode()

    def send_DeleteNode(self, node_id):
        self._oprot.writeMessageBegin('DeleteNode', TMessageType.CALL, self._seqid)
        args = DeleteNode_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteNode failed: unknown result")

    def RenameNode(self, node_id, new_name):
        """
        Parameters:
         - node_id
         - new_name

        """
        self.send_RenameNode(node_id, new_name)
        return self.recv_RenameNode()

    def send_RenameNode(self, node_id, new_name):
        self._oprot.writeMessageBegin('RenameNode', TMessageType.CALL, self._seqid)
        args = RenameNode_args()
        args.node_id = node_id
        args.new_name = new_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RenameNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RenameNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RenameNode failed: unknown result")

    def ConnectNodeInput(self, node_id, input_index, node_id_to_connect, output_index):
        """
        Parameters:
         - node_id
         - input_index
         - node_id_to_connect
         - output_index

        """
        self.send_ConnectNodeInput(node_id, input_index, node_id_to_connect, output_index)
        return self.recv_ConnectNodeInput()

    def send_ConnectNodeInput(self, node_id, input_index, node_id_to_connect, output_index):
        self._oprot.writeMessageBegin('ConnectNodeInput', TMessageType.CALL, self._seqid)
        args = ConnectNodeInput_args()
        args.node_id = node_id
        args.input_index = input_index
        args.node_id_to_connect = node_id_to_connect
        args.output_index = output_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ConnectNodeInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ConnectNodeInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ConnectNodeInput failed: unknown result")

    def DisconnectNodeInput(self, node_id, input_index):
        """
        Parameters:
         - node_id
         - input_index

        """
        self.send_DisconnectNodeInput(node_id, input_index)
        return self.recv_DisconnectNodeInput()

    def send_DisconnectNodeInput(self, node_id, input_index):
        self._oprot.writeMessageBegin('DisconnectNodeInput', TMessageType.CALL, self._seqid)
        args = DisconnectNodeInput_args()
        args.node_id = node_id
        args.input_index = input_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DisconnectNodeInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DisconnectNodeInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DisconnectNodeInput failed: unknown result")

    def QueryNodeInput(self, node_to_query, input_index):
        """
        Parameters:
         - node_to_query
         - input_index

        """
        self.send_QueryNodeInput(node_to_query, input_index)
        return self.recv_QueryNodeInput()

    def send_QueryNodeInput(self, node_to_query, input_index):
        self._oprot.writeMessageBegin('QueryNodeInput', TMessageType.CALL, self._seqid)
        args = QueryNodeInput_args()
        args.node_to_query = node_to_query
        args.input_index = input_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QueryNodeInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QueryNodeInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QueryNodeInput failed: unknown result")

    def GetNodeInputName(self, node_id, input_idx):
        """
        Parameters:
         - node_id
         - input_idx

        """
        self.send_GetNodeInputName(node_id, input_idx)
        return self.recv_GetNodeInputName()

    def send_GetNodeInputName(self, node_id, input_idx):
        self._oprot.writeMessageBegin('GetNodeInputName', TMessageType.CALL, self._seqid)
        args = GetNodeInputName_args()
        args.node_id = node_id
        args.input_idx = input_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNodeInputName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNodeInputName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeInputName failed: unknown result")

    def DisconnectNodeOutputsAt(self, node_id, output_index):
        """
        Parameters:
         - node_id
         - output_index

        """
        self.send_DisconnectNodeOutputsAt(node_id, output_index)
        return self.recv_DisconnectNodeOutputsAt()

    def send_DisconnectNodeOutputsAt(self, node_id, output_index):
        self._oprot.writeMessageBegin('DisconnectNodeOutputsAt', TMessageType.CALL, self._seqid)
        args = DisconnectNodeOutputsAt_args()
        args.node_id = node_id
        args.output_index = output_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DisconnectNodeOutputsAt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DisconnectNodeOutputsAt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DisconnectNodeOutputsAt failed: unknown result")

    def QueryNodeOutputConnectedCount(self, node_id, output_idx, into_subnets, through_dots):
        """
        Parameters:
         - node_id
         - output_idx
         - into_subnets
         - through_dots

        """
        self.send_QueryNodeOutputConnectedCount(node_id, output_idx, into_subnets, through_dots)
        return self.recv_QueryNodeOutputConnectedCount()

    def send_QueryNodeOutputConnectedCount(self, node_id, output_idx, into_subnets, through_dots):
        self._oprot.writeMessageBegin('QueryNodeOutputConnectedCount', TMessageType.CALL, self._seqid)
        args = QueryNodeOutputConnectedCount_args()
        args.node_id = node_id
        args.output_idx = output_idx
        args.into_subnets = into_subnets
        args.through_dots = through_dots
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QueryNodeOutputConnectedCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QueryNodeOutputConnectedCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QueryNodeOutputConnectedCount failed: unknown result")

    def QueryNodeOutputConnectedNodes(self, node_id, output_idx, into_subnets, through_dots, start, length):
        """
        Parameters:
         - node_id
         - output_idx
         - into_subnets
         - through_dots
         - start
         - length

        """
        self.send_QueryNodeOutputConnectedNodes(node_id, output_idx, into_subnets, through_dots, start, length)
        return self.recv_QueryNodeOutputConnectedNodes()

    def send_QueryNodeOutputConnectedNodes(self, node_id, output_idx, into_subnets, through_dots, start, length):
        self._oprot.writeMessageBegin('QueryNodeOutputConnectedNodes', TMessageType.CALL, self._seqid)
        args = QueryNodeOutputConnectedNodes_args()
        args.node_id = node_id
        args.output_idx = output_idx
        args.into_subnets = into_subnets
        args.through_dots = through_dots
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_QueryNodeOutputConnectedNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = QueryNodeOutputConnectedNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "QueryNodeOutputConnectedNodes failed: unknown result")

    def GetNodeOutputName(self, node_id, output_idx):
        """
        Parameters:
         - node_id
         - output_idx

        """
        self.send_GetNodeOutputName(node_id, output_idx)
        return self.recv_GetNodeOutputName()

    def send_GetNodeOutputName(self, node_id, output_idx):
        self._oprot.writeMessageBegin('GetNodeOutputName', TMessageType.CALL, self._seqid)
        args = GetNodeOutputName_args()
        args.node_id = node_id
        args.output_idx = output_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNodeOutputName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNodeOutputName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNodeOutputName failed: unknown result")

    def GetParameters(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        self.send_GetParameters(node_id, start, length)
        return self.recv_GetParameters()

    def send_GetParameters(self, node_id, start, length):
        self._oprot.writeMessageBegin('GetParameters', TMessageType.CALL, self._seqid)
        args = GetParameters_args()
        args.node_id = node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParameters failed: unknown result")

    def GetParmInfo(self, node_id, parm_id):
        """
        Parameters:
         - node_id
         - parm_id

        """
        self.send_GetParmInfo(node_id, parm_id)
        return self.recv_GetParmInfo()

    def send_GetParmInfo(self, node_id, parm_id):
        self._oprot.writeMessageBegin('GetParmInfo', TMessageType.CALL, self._seqid)
        args = GetParmInfo_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmInfo failed: unknown result")

    def GetParmIdFromName(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        self.send_GetParmIdFromName(node_id, parm_name)
        return self.recv_GetParmIdFromName()

    def send_GetParmIdFromName(self, node_id, parm_name):
        self._oprot.writeMessageBegin('GetParmIdFromName', TMessageType.CALL, self._seqid)
        args = GetParmIdFromName_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmIdFromName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmIdFromName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmIdFromName failed: unknown result")

    def GetParmInfoFromName(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        self.send_GetParmInfoFromName(node_id, parm_name)
        return self.recv_GetParmInfoFromName()

    def send_GetParmInfoFromName(self, node_id, parm_name):
        self._oprot.writeMessageBegin('GetParmInfoFromName', TMessageType.CALL, self._seqid)
        args = GetParmInfoFromName_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmInfoFromName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmInfoFromName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmInfoFromName failed: unknown result")

    def GetParmTagName(self, node_id, parm_id, tag_index):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_index

        """
        self.send_GetParmTagName(node_id, parm_id, tag_index)
        return self.recv_GetParmTagName()

    def send_GetParmTagName(self, node_id, parm_id, tag_index):
        self._oprot.writeMessageBegin('GetParmTagName', TMessageType.CALL, self._seqid)
        args = GetParmTagName_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.tag_index = tag_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmTagName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmTagName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmTagName failed: unknown result")

    def GetParmTagValue(self, node_id, parm_id, tag_name):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_name

        """
        self.send_GetParmTagValue(node_id, parm_id, tag_name)
        return self.recv_GetParmTagValue()

    def send_GetParmTagValue(self, node_id, parm_id, tag_name):
        self._oprot.writeMessageBegin('GetParmTagValue', TMessageType.CALL, self._seqid)
        args = GetParmTagValue_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.tag_name = tag_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmTagValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmTagValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmTagValue failed: unknown result")

    def ParmHasTag(self, node_id, parm_id, tag_name):
        """
        Parameters:
         - node_id
         - parm_id
         - tag_name

        """
        self.send_ParmHasTag(node_id, parm_id, tag_name)
        return self.recv_ParmHasTag()

    def send_ParmHasTag(self, node_id, parm_id, tag_name):
        self._oprot.writeMessageBegin('ParmHasTag', TMessageType.CALL, self._seqid)
        args = ParmHasTag_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.tag_name = tag_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ParmHasTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ParmHasTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ParmHasTag failed: unknown result")

    def ParmHasExpression(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        self.send_ParmHasExpression(node_id, parm_name, index)
        return self.recv_ParmHasExpression()

    def send_ParmHasExpression(self, node_id, parm_name, index):
        self._oprot.writeMessageBegin('ParmHasExpression', TMessageType.CALL, self._seqid)
        args = ParmHasExpression_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ParmHasExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ParmHasExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ParmHasExpression failed: unknown result")

    def GetParmWithTag(self, node_id, tag_name):
        """
        Parameters:
         - node_id
         - tag_name

        """
        self.send_GetParmWithTag(node_id, tag_name)
        return self.recv_GetParmWithTag()

    def send_GetParmWithTag(self, node_id, tag_name):
        self._oprot.writeMessageBegin('GetParmWithTag', TMessageType.CALL, self._seqid)
        args = GetParmWithTag_args()
        args.node_id = node_id
        args.tag_name = tag_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmWithTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmWithTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmWithTag failed: unknown result")

    def GetParmExpression(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        self.send_GetParmExpression(node_id, parm_name, index)
        return self.recv_GetParmExpression()

    def send_GetParmExpression(self, node_id, parm_name, index):
        self._oprot.writeMessageBegin('GetParmExpression', TMessageType.CALL, self._seqid)
        args = GetParmExpression_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmExpression failed: unknown result")

    def RevertParmToDefault(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        self.send_RevertParmToDefault(node_id, parm_name, index)
        return self.recv_RevertParmToDefault()

    def send_RevertParmToDefault(self, node_id, parm_name, index):
        self._oprot.writeMessageBegin('RevertParmToDefault', TMessageType.CALL, self._seqid)
        args = RevertParmToDefault_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RevertParmToDefault(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RevertParmToDefault_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RevertParmToDefault failed: unknown result")

    def RevertParmToDefaults(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        self.send_RevertParmToDefaults(node_id, parm_name)
        return self.recv_RevertParmToDefaults()

    def send_RevertParmToDefaults(self, node_id, parm_name):
        self._oprot.writeMessageBegin('RevertParmToDefaults', TMessageType.CALL, self._seqid)
        args = RevertParmToDefaults_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RevertParmToDefaults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RevertParmToDefaults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RevertParmToDefaults failed: unknown result")

    def SetParmExpression(self, node_id, value, parm_id, index):
        """
        Parameters:
         - node_id
         - value
         - parm_id
         - index

        """
        self.send_SetParmExpression(node_id, value, parm_id, index)
        return self.recv_SetParmExpression()

    def send_SetParmExpression(self, node_id, value, parm_id, index):
        self._oprot.writeMessageBegin('SetParmExpression', TMessageType.CALL, self._seqid)
        args = SetParmExpression_args()
        args.node_id = node_id
        args.value = value
        args.parm_id = parm_id
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmExpression failed: unknown result")

    def RemoveParmExpression(self, node_id, parm_id, index):
        """
        Parameters:
         - node_id
         - parm_id
         - index

        """
        self.send_RemoveParmExpression(node_id, parm_id, index)
        return self.recv_RemoveParmExpression()

    def send_RemoveParmExpression(self, node_id, parm_id, index):
        self._oprot.writeMessageBegin('RemoveParmExpression', TMessageType.CALL, self._seqid)
        args = RemoveParmExpression_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RemoveParmExpression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RemoveParmExpression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveParmExpression failed: unknown result")

    def GetParmIntValue(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        self.send_GetParmIntValue(node_id, parm_name, index)
        return self.recv_GetParmIntValue()

    def send_GetParmIntValue(self, node_id, parm_name, index):
        self._oprot.writeMessageBegin('GetParmIntValue', TMessageType.CALL, self._seqid)
        args = GetParmIntValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmIntValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmIntValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmIntValue failed: unknown result")

    def GetParmIntValues(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        self.send_GetParmIntValues(node_id, start, length)
        return self.recv_GetParmIntValues()

    def send_GetParmIntValues(self, node_id, start, length):
        self._oprot.writeMessageBegin('GetParmIntValues', TMessageType.CALL, self._seqid)
        args = GetParmIntValues_args()
        args.node_id = node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmIntValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmIntValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmIntValues failed: unknown result")

    def GetParmFloatValue(self, node_id, parm_name, index):
        """
        Parameters:
         - node_id
         - parm_name
         - index

        """
        self.send_GetParmFloatValue(node_id, parm_name, index)
        return self.recv_GetParmFloatValue()

    def send_GetParmFloatValue(self, node_id, parm_name, index):
        self._oprot.writeMessageBegin('GetParmFloatValue', TMessageType.CALL, self._seqid)
        args = GetParmFloatValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmFloatValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmFloatValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmFloatValue failed: unknown result")

    def GetParmFloatValues(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        self.send_GetParmFloatValues(node_id, start, length)
        return self.recv_GetParmFloatValues()

    def send_GetParmFloatValues(self, node_id, start, length):
        self._oprot.writeMessageBegin('GetParmFloatValues', TMessageType.CALL, self._seqid)
        args = GetParmFloatValues_args()
        args.node_id = node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmFloatValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmFloatValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmFloatValues failed: unknown result")

    def GetParmStringValue(self, node_id, parm_name, index, evaluate):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - evaluate

        """
        self.send_GetParmStringValue(node_id, parm_name, index, evaluate)
        return self.recv_GetParmStringValue()

    def send_GetParmStringValue(self, node_id, parm_name, index, evaluate):
        self._oprot.writeMessageBegin('GetParmStringValue', TMessageType.CALL, self._seqid)
        args = GetParmStringValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.evaluate = evaluate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmStringValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmStringValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmStringValue failed: unknown result")

    def GetParmStringValues(self, node_id, evaluate, start, length):
        """
        Parameters:
         - node_id
         - evaluate
         - start
         - length

        """
        self.send_GetParmStringValues(node_id, evaluate, start, length)
        return self.recv_GetParmStringValues()

    def send_GetParmStringValues(self, node_id, evaluate, start, length):
        self._oprot.writeMessageBegin('GetParmStringValues', TMessageType.CALL, self._seqid)
        args = GetParmStringValues_args()
        args.node_id = node_id
        args.evaluate = evaluate
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmStringValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmStringValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmStringValues failed: unknown result")

    def GetParmNodeValue(self, node_id, parm_name):
        """
        Parameters:
         - node_id
         - parm_name

        """
        self.send_GetParmNodeValue(node_id, parm_name)
        return self.recv_GetParmNodeValue()

    def send_GetParmNodeValue(self, node_id, parm_name):
        self._oprot.writeMessageBegin('GetParmNodeValue', TMessageType.CALL, self._seqid)
        args = GetParmNodeValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmNodeValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmNodeValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmNodeValue failed: unknown result")

    def GetParmFile(self, node_id, parm_name, destination_directory, destination_file_name):
        """
        Parameters:
         - node_id
         - parm_name
         - destination_directory
         - destination_file_name

        """
        self.send_GetParmFile(node_id, parm_name, destination_directory, destination_file_name)
        return self.recv_GetParmFile()

    def send_GetParmFile(self, node_id, parm_name, destination_directory, destination_file_name):
        self._oprot.writeMessageBegin('GetParmFile', TMessageType.CALL, self._seqid)
        args = GetParmFile_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.destination_directory = destination_directory
        args.destination_file_name = destination_file_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmFile failed: unknown result")

    def GetParmChoiceLists(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        self.send_GetParmChoiceLists(node_id, start, length)
        return self.recv_GetParmChoiceLists()

    def send_GetParmChoiceLists(self, node_id, start, length):
        self._oprot.writeMessageBegin('GetParmChoiceLists', TMessageType.CALL, self._seqid)
        args = GetParmChoiceLists_args()
        args.node_id = node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetParmChoiceLists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetParmChoiceLists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetParmChoiceLists failed: unknown result")

    def SetParmIntValue(self, node_id, parm_name, index, value):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - value

        """
        self.send_SetParmIntValue(node_id, parm_name, index, value)
        return self.recv_SetParmIntValue()

    def send_SetParmIntValue(self, node_id, parm_name, index, value):
        self._oprot.writeMessageBegin('SetParmIntValue', TMessageType.CALL, self._seqid)
        args = SetParmIntValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmIntValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmIntValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmIntValue failed: unknown result")

    def SetParmIntValues(self, node_id, values_array, start):
        """
        Parameters:
         - node_id
         - values_array
         - start

        """
        self.send_SetParmIntValues(node_id, values_array, start)
        return self.recv_SetParmIntValues()

    def send_SetParmIntValues(self, node_id, values_array, start):
        self._oprot.writeMessageBegin('SetParmIntValues', TMessageType.CALL, self._seqid)
        args = SetParmIntValues_args()
        args.node_id = node_id
        args.values_array = values_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmIntValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmIntValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmIntValues failed: unknown result")

    def SetParmFloatValue(self, node_id, parm_name, index, value):
        """
        Parameters:
         - node_id
         - parm_name
         - index
         - value

        """
        self.send_SetParmFloatValue(node_id, parm_name, index, value)
        return self.recv_SetParmFloatValue()

    def send_SetParmFloatValue(self, node_id, parm_name, index, value):
        self._oprot.writeMessageBegin('SetParmFloatValue', TMessageType.CALL, self._seqid)
        args = SetParmFloatValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmFloatValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmFloatValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmFloatValue failed: unknown result")

    def SetParmFloatValues(self, node_id, values_array, start):
        """
        Parameters:
         - node_id
         - values_array
         - start

        """
        self.send_SetParmFloatValues(node_id, values_array, start)
        return self.recv_SetParmFloatValues()

    def send_SetParmFloatValues(self, node_id, values_array, start):
        self._oprot.writeMessageBegin('SetParmFloatValues', TMessageType.CALL, self._seqid)
        args = SetParmFloatValues_args()
        args.node_id = node_id
        args.values_array = values_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmFloatValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmFloatValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmFloatValues failed: unknown result")

    def SetParmStringValue(self, node_id, value, parm_id, index):
        """
        Parameters:
         - node_id
         - value
         - parm_id
         - index

        """
        self.send_SetParmStringValue(node_id, value, parm_id, index)
        return self.recv_SetParmStringValue()

    def send_SetParmStringValue(self, node_id, value, parm_id, index):
        self._oprot.writeMessageBegin('SetParmStringValue', TMessageType.CALL, self._seqid)
        args = SetParmStringValue_args()
        args.node_id = node_id
        args.value = value
        args.parm_id = parm_id
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmStringValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmStringValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmStringValue failed: unknown result")

    def SetParmNodeValue(self, node_id, parm_name, value):
        """
        Parameters:
         - node_id
         - parm_name
         - value

        """
        self.send_SetParmNodeValue(node_id, parm_name, value)
        return self.recv_SetParmNodeValue()

    def send_SetParmNodeValue(self, node_id, parm_name, value):
        self._oprot.writeMessageBegin('SetParmNodeValue', TMessageType.CALL, self._seqid)
        args = SetParmNodeValue_args()
        args.node_id = node_id
        args.parm_name = parm_name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetParmNodeValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetParmNodeValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetParmNodeValue failed: unknown result")

    def InsertMultiparmInstance(self, node_id, parm_id, instance_position):
        """
        Parameters:
         - node_id
         - parm_id
         - instance_position

        """
        self.send_InsertMultiparmInstance(node_id, parm_id, instance_position)
        return self.recv_InsertMultiparmInstance()

    def send_InsertMultiparmInstance(self, node_id, parm_id, instance_position):
        self._oprot.writeMessageBegin('InsertMultiparmInstance', TMessageType.CALL, self._seqid)
        args = InsertMultiparmInstance_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.instance_position = instance_position
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_InsertMultiparmInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = InsertMultiparmInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "InsertMultiparmInstance failed: unknown result")

    def RemoveMultiparmInstance(self, node_id, parm_id, instance_position):
        """
        Parameters:
         - node_id
         - parm_id
         - instance_position

        """
        self.send_RemoveMultiparmInstance(node_id, parm_id, instance_position)
        return self.recv_RemoveMultiparmInstance()

    def send_RemoveMultiparmInstance(self, node_id, parm_id, instance_position):
        self._oprot.writeMessageBegin('RemoveMultiparmInstance', TMessageType.CALL, self._seqid)
        args = RemoveMultiparmInstance_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.instance_position = instance_position
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RemoveMultiparmInstance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RemoveMultiparmInstance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RemoveMultiparmInstance failed: unknown result")

    def GetHandleInfo(self, node_id, start, length):
        """
        Parameters:
         - node_id
         - start
         - length

        """
        self.send_GetHandleInfo(node_id, start, length)
        return self.recv_GetHandleInfo()

    def send_GetHandleInfo(self, node_id, start, length):
        self._oprot.writeMessageBegin('GetHandleInfo', TMessageType.CALL, self._seqid)
        args = GetHandleInfo_args()
        args.node_id = node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHandleInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHandleInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHandleInfo failed: unknown result")

    def GetHandleBindingInfo(self, node_id, handle_index, start, length):
        """
        Parameters:
         - node_id
         - handle_index
         - start
         - length

        """
        self.send_GetHandleBindingInfo(node_id, handle_index, start, length)
        return self.recv_GetHandleBindingInfo()

    def send_GetHandleBindingInfo(self, node_id, handle_index, start, length):
        self._oprot.writeMessageBegin('GetHandleBindingInfo', TMessageType.CALL, self._seqid)
        args = GetHandleBindingInfo_args()
        args.node_id = node_id
        args.handle_index = handle_index
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHandleBindingInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHandleBindingInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHandleBindingInfo failed: unknown result")

    def GetPresetBufLength(self, node_id, preset_type, preset_name):
        """
        Parameters:
         - node_id
         - preset_type
         - preset_name

        """
        self.send_GetPresetBufLength(node_id, preset_type, preset_name)
        return self.recv_GetPresetBufLength()

    def send_GetPresetBufLength(self, node_id, preset_type, preset_name):
        self._oprot.writeMessageBegin('GetPresetBufLength', TMessageType.CALL, self._seqid)
        args = GetPresetBufLength_args()
        args.node_id = node_id
        args.preset_type = preset_type
        args.preset_name = preset_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPresetBufLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPresetBufLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPresetBufLength failed: unknown result")

    def GetPreset(self, node_id, buffer_length):
        """
        Parameters:
         - node_id
         - buffer_length

        """
        self.send_GetPreset(node_id, buffer_length)
        return self.recv_GetPreset()

    def send_GetPreset(self, node_id, buffer_length):
        self._oprot.writeMessageBegin('GetPreset', TMessageType.CALL, self._seqid)
        args = GetPreset_args()
        args.node_id = node_id
        args.buffer_length = buffer_length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPreset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPreset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPreset failed: unknown result")

    def SetPreset(self, node_id, preset_type, preset_name, buffer, buffer_length):
        """
        Parameters:
         - node_id
         - preset_type
         - preset_name
         - buffer
         - buffer_length

        """
        self.send_SetPreset(node_id, preset_type, preset_name, buffer, buffer_length)
        return self.recv_SetPreset()

    def send_SetPreset(self, node_id, preset_type, preset_name, buffer, buffer_length):
        self._oprot.writeMessageBegin('SetPreset', TMessageType.CALL, self._seqid)
        args = SetPreset_args()
        args.node_id = node_id
        args.preset_type = preset_type
        args.preset_name = preset_name
        args.buffer = buffer
        args.buffer_length = buffer_length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetPreset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetPreset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetPreset failed: unknown result")

    def GetObjectInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_GetObjectInfo(node_id)
        return self.recv_GetObjectInfo()

    def send_GetObjectInfo(self, node_id):
        self._oprot.writeMessageBegin('GetObjectInfo', TMessageType.CALL, self._seqid)
        args = GetObjectInfo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetObjectInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetObjectInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetObjectInfo failed: unknown result")

    def GetObjectTransform(self, node_id, relative_to_node_id, rst_order):
        """
        Parameters:
         - node_id
         - relative_to_node_id
         - rst_order

        """
        self.send_GetObjectTransform(node_id, relative_to_node_id, rst_order)
        return self.recv_GetObjectTransform()

    def send_GetObjectTransform(self, node_id, relative_to_node_id, rst_order):
        self._oprot.writeMessageBegin('GetObjectTransform', TMessageType.CALL, self._seqid)
        args = GetObjectTransform_args()
        args.node_id = node_id
        args.relative_to_node_id = relative_to_node_id
        args.rst_order = rst_order
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetObjectTransform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetObjectTransform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetObjectTransform failed: unknown result")

    def ComposeObjectList(self, parent_node_id, categories):
        """
        Parameters:
         - parent_node_id
         - categories

        """
        self.send_ComposeObjectList(parent_node_id, categories)
        return self.recv_ComposeObjectList()

    def send_ComposeObjectList(self, parent_node_id, categories):
        self._oprot.writeMessageBegin('ComposeObjectList', TMessageType.CALL, self._seqid)
        args = ComposeObjectList_args()
        args.parent_node_id = parent_node_id
        args.categories = categories
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ComposeObjectList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ComposeObjectList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ComposeObjectList failed: unknown result")

    def GetComposedObjectList(self, parent_node_id, start, length):
        """
        Parameters:
         - parent_node_id
         - start
         - length

        """
        self.send_GetComposedObjectList(parent_node_id, start, length)
        return self.recv_GetComposedObjectList()

    def send_GetComposedObjectList(self, parent_node_id, start, length):
        self._oprot.writeMessageBegin('GetComposedObjectList', TMessageType.CALL, self._seqid)
        args = GetComposedObjectList_args()
        args.parent_node_id = parent_node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetComposedObjectList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetComposedObjectList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetComposedObjectList failed: unknown result")

    def GetComposedObjectTransforms(self, parent_node_id, rst_order, start, length):
        """
        Parameters:
         - parent_node_id
         - rst_order
         - start
         - length

        """
        self.send_GetComposedObjectTransforms(parent_node_id, rst_order, start, length)
        return self.recv_GetComposedObjectTransforms()

    def send_GetComposedObjectTransforms(self, parent_node_id, rst_order, start, length):
        self._oprot.writeMessageBegin('GetComposedObjectTransforms', TMessageType.CALL, self._seqid)
        args = GetComposedObjectTransforms_args()
        args.parent_node_id = parent_node_id
        args.rst_order = rst_order
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetComposedObjectTransforms(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetComposedObjectTransforms_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetComposedObjectTransforms failed: unknown result")

    def GetInstancedObjectIds(self, object_node_id, start, length):
        """
        Parameters:
         - object_node_id
         - start
         - length

        """
        self.send_GetInstancedObjectIds(object_node_id, start, length)
        return self.recv_GetInstancedObjectIds()

    def send_GetInstancedObjectIds(self, object_node_id, start, length):
        self._oprot.writeMessageBegin('GetInstancedObjectIds', TMessageType.CALL, self._seqid)
        args = GetInstancedObjectIds_args()
        args.object_node_id = object_node_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetInstancedObjectIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetInstancedObjectIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetInstancedObjectIds failed: unknown result")

    def GetInstanceTransforms(self, object_node_id, rst_order, start, length):
        """
        Parameters:
         - object_node_id
         - rst_order
         - start
         - length

        """
        self.send_GetInstanceTransforms(object_node_id, rst_order, start, length)
        return self.recv_GetInstanceTransforms()

    def send_GetInstanceTransforms(self, object_node_id, rst_order, start, length):
        self._oprot.writeMessageBegin('GetInstanceTransforms', TMessageType.CALL, self._seqid)
        args = GetInstanceTransforms_args()
        args.object_node_id = object_node_id
        args.rst_order = rst_order
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetInstanceTransforms(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetInstanceTransforms_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetInstanceTransforms failed: unknown result")

    def GetInstanceTransformsOnPart(self, node_id, part_id, rst_order, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - rst_order
         - start
         - length

        """
        self.send_GetInstanceTransformsOnPart(node_id, part_id, rst_order, start, length)
        return self.recv_GetInstanceTransformsOnPart()

    def send_GetInstanceTransformsOnPart(self, node_id, part_id, rst_order, start, length):
        self._oprot.writeMessageBegin('GetInstanceTransformsOnPart', TMessageType.CALL, self._seqid)
        args = GetInstanceTransformsOnPart_args()
        args.node_id = node_id
        args.part_id = part_id
        args.rst_order = rst_order
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetInstanceTransformsOnPart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetInstanceTransformsOnPart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetInstanceTransformsOnPart failed: unknown result")

    def SetObjectTransform(self, node_id, trans):
        """
        Parameters:
         - node_id
         - trans

        """
        self.send_SetObjectTransform(node_id, trans)
        return self.recv_SetObjectTransform()

    def send_SetObjectTransform(self, node_id, trans):
        self._oprot.writeMessageBegin('SetObjectTransform', TMessageType.CALL, self._seqid)
        args = SetObjectTransform_args()
        args.node_id = node_id
        args.trans = trans
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetObjectTransform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetObjectTransform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetObjectTransform failed: unknown result")

    def GetDisplayGeoInfo(self, object_node_id):
        """
        Parameters:
         - object_node_id

        """
        self.send_GetDisplayGeoInfo(object_node_id)
        return self.recv_GetDisplayGeoInfo()

    def send_GetDisplayGeoInfo(self, object_node_id):
        self._oprot.writeMessageBegin('GetDisplayGeoInfo', TMessageType.CALL, self._seqid)
        args = GetDisplayGeoInfo_args()
        args.object_node_id = object_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetDisplayGeoInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetDisplayGeoInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDisplayGeoInfo failed: unknown result")

    def GetGeoInfo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_GetGeoInfo(node_id)
        return self.recv_GetGeoInfo()

    def send_GetGeoInfo(self, node_id):
        self._oprot.writeMessageBegin('GetGeoInfo', TMessageType.CALL, self._seqid)
        args = GetGeoInfo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGeoInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGeoInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGeoInfo failed: unknown result")

    def GetPartInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetPartInfo(node_id, part_id)
        return self.recv_GetPartInfo()

    def send_GetPartInfo(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetPartInfo', TMessageType.CALL, self._seqid)
        args = GetPartInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPartInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPartInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPartInfo failed: unknown result")

    def GetFaceCounts(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetFaceCounts(node_id, part_id, start, length)
        return self.recv_GetFaceCounts()

    def send_GetFaceCounts(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetFaceCounts', TMessageType.CALL, self._seqid)
        args = GetFaceCounts_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetFaceCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetFaceCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFaceCounts failed: unknown result")

    def GetVertexList(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetVertexList(node_id, part_id, start, length)
        return self.recv_GetVertexList()

    def send_GetVertexList(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetVertexList', TMessageType.CALL, self._seqid)
        args = GetVertexList_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVertexList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVertexList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVertexList failed: unknown result")

    def GetAttributeInfo(self, node_id, part_id, name, owner):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - owner

        """
        self.send_GetAttributeInfo(node_id, part_id, name, owner)
        return self.recv_GetAttributeInfo()

    def send_GetAttributeInfo(self, node_id, part_id, name, owner):
        self._oprot.writeMessageBegin('GetAttributeInfo', TMessageType.CALL, self._seqid)
        args = GetAttributeInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.owner = owner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeInfo failed: unknown result")

    def GetAttributeNames(self, node_id, part_id, owner, count):
        """
        Parameters:
         - node_id
         - part_id
         - owner
         - count

        """
        self.send_GetAttributeNames(node_id, part_id, owner, count)
        return self.recv_GetAttributeNames()

    def send_GetAttributeNames(self, node_id, part_id, owner, count):
        self._oprot.writeMessageBegin('GetAttributeNames', TMessageType.CALL, self._seqid)
        args = GetAttributeNames_args()
        args.node_id = node_id
        args.part_id = part_id
        args.owner = owner
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeNames failed: unknown result")

    def GetAttributeIntData(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        self.send_GetAttributeIntData(node_id, part_id, name, attr_info, stride, start, length)
        return self.recv_GetAttributeIntData()

    def send_GetAttributeIntData(self, node_id, part_id, name, attr_info, stride, start, length):
        self._oprot.writeMessageBegin('GetAttributeIntData', TMessageType.CALL, self._seqid)
        args = GetAttributeIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.stride = stride
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeIntData failed: unknown result")

    def GetAttributeInt64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        self.send_GetAttributeInt64Data(node_id, part_id, name, attr_info, stride, start, length)
        return self.recv_GetAttributeInt64Data()

    def send_GetAttributeInt64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        self._oprot.writeMessageBegin('GetAttributeInt64Data', TMessageType.CALL, self._seqid)
        args = GetAttributeInt64Data_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.stride = stride
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeInt64Data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeInt64Data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeInt64Data failed: unknown result")

    def GetAttributeFloatData(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        self.send_GetAttributeFloatData(node_id, part_id, name, attr_info, stride, start, length)
        return self.recv_GetAttributeFloatData()

    def send_GetAttributeFloatData(self, node_id, part_id, name, attr_info, stride, start, length):
        self._oprot.writeMessageBegin('GetAttributeFloatData', TMessageType.CALL, self._seqid)
        args = GetAttributeFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.stride = stride
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeFloatData failed: unknown result")

    def GetAttributeFloat64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - stride
         - start
         - length

        """
        self.send_GetAttributeFloat64Data(node_id, part_id, name, attr_info, stride, start, length)
        return self.recv_GetAttributeFloat64Data()

    def send_GetAttributeFloat64Data(self, node_id, part_id, name, attr_info, stride, start, length):
        self._oprot.writeMessageBegin('GetAttributeFloat64Data', TMessageType.CALL, self._seqid)
        args = GetAttributeFloat64Data_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.stride = stride
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeFloat64Data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeFloat64Data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeFloat64Data failed: unknown result")

    def GetAttributeStringData(self, node_id, part_id, name, attr_info, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - start
         - length

        """
        self.send_GetAttributeStringData(node_id, part_id, name, attr_info, start, length)
        return self.recv_GetAttributeStringData()

    def send_GetAttributeStringData(self, node_id, part_id, name, attr_info, start, length):
        self._oprot.writeMessageBegin('GetAttributeStringData', TMessageType.CALL, self._seqid)
        args = GetAttributeStringData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAttributeStringData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAttributeStringData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAttributeStringData failed: unknown result")

    def GetGroupNames(self, node_id, group_type, group_count):
        """
        Parameters:
         - node_id
         - group_type
         - group_count

        """
        self.send_GetGroupNames(node_id, group_type, group_count)
        return self.recv_GetGroupNames()

    def send_GetGroupNames(self, node_id, group_type, group_count):
        self._oprot.writeMessageBegin('GetGroupNames', TMessageType.CALL, self._seqid)
        args = GetGroupNames_args()
        args.node_id = node_id
        args.group_type = group_type
        args.group_count = group_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGroupNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGroupNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupNames failed: unknown result")

    def GetGroupMembership(self, node_id, part_id, group_type, group_name, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - start
         - length

        """
        self.send_GetGroupMembership(node_id, part_id, group_type, group_name, start, length)
        return self.recv_GetGroupMembership()

    def send_GetGroupMembership(self, node_id, part_id, group_type, group_name, start, length):
        self._oprot.writeMessageBegin('GetGroupMembership', TMessageType.CALL, self._seqid)
        args = GetGroupMembership_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_name = group_name
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGroupMembership(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGroupMembership_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupMembership failed: unknown result")

    def GetGroupCountOnPackedInstancePart(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetGroupCountOnPackedInstancePart(node_id, part_id)
        return self.recv_GetGroupCountOnPackedInstancePart()

    def send_GetGroupCountOnPackedInstancePart(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetGroupCountOnPackedInstancePart', TMessageType.CALL, self._seqid)
        args = GetGroupCountOnPackedInstancePart_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGroupCountOnPackedInstancePart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGroupCountOnPackedInstancePart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupCountOnPackedInstancePart failed: unknown result")

    def GetGroupNamesOnPackedInstancePart(self, node_id, part_id, group_type, group_count):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_count

        """
        self.send_GetGroupNamesOnPackedInstancePart(node_id, part_id, group_type, group_count)
        return self.recv_GetGroupNamesOnPackedInstancePart()

    def send_GetGroupNamesOnPackedInstancePart(self, node_id, part_id, group_type, group_count):
        self._oprot.writeMessageBegin('GetGroupNamesOnPackedInstancePart', TMessageType.CALL, self._seqid)
        args = GetGroupNamesOnPackedInstancePart_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_count = group_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGroupNamesOnPackedInstancePart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGroupNamesOnPackedInstancePart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupNamesOnPackedInstancePart failed: unknown result")

    def GetGroupMembershipOnPackedInstancePart(self, node_id, part_id, group_type, group_name, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - start
         - length

        """
        self.send_GetGroupMembershipOnPackedInstancePart(node_id, part_id, group_type, group_name, start, length)
        return self.recv_GetGroupMembershipOnPackedInstancePart()

    def send_GetGroupMembershipOnPackedInstancePart(self, node_id, part_id, group_type, group_name, start, length):
        self._oprot.writeMessageBegin('GetGroupMembershipOnPackedInstancePart', TMessageType.CALL, self._seqid)
        args = GetGroupMembershipOnPackedInstancePart_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_name = group_name
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGroupMembershipOnPackedInstancePart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGroupMembershipOnPackedInstancePart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGroupMembershipOnPackedInstancePart failed: unknown result")

    def GetInstancedPartIds(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetInstancedPartIds(node_id, part_id, start, length)
        return self.recv_GetInstancedPartIds()

    def send_GetInstancedPartIds(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetInstancedPartIds', TMessageType.CALL, self._seqid)
        args = GetInstancedPartIds_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetInstancedPartIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetInstancedPartIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetInstancedPartIds failed: unknown result")

    def GetInstancerPartTransforms(self, node_id, part_id, rst_order, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - rst_order
         - start
         - length

        """
        self.send_GetInstancerPartTransforms(node_id, part_id, rst_order, start, length)
        return self.recv_GetInstancerPartTransforms()

    def send_GetInstancerPartTransforms(self, node_id, part_id, rst_order, start, length):
        self._oprot.writeMessageBegin('GetInstancerPartTransforms', TMessageType.CALL, self._seqid)
        args = GetInstancerPartTransforms_args()
        args.node_id = node_id
        args.part_id = part_id
        args.rst_order = rst_order
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetInstancerPartTransforms(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetInstancerPartTransforms_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetInstancerPartTransforms failed: unknown result")

    def SetPartInfo(self, node_id, part_id, part_info):
        """
        Parameters:
         - node_id
         - part_id
         - part_info

        """
        self.send_SetPartInfo(node_id, part_id, part_info)
        return self.recv_SetPartInfo()

    def send_SetPartInfo(self, node_id, part_id, part_info):
        self._oprot.writeMessageBegin('SetPartInfo', TMessageType.CALL, self._seqid)
        args = SetPartInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.part_info = part_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetPartInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetPartInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetPartInfo failed: unknown result")

    def SetFaceCounts(self, node_id, part_id, face_counts_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - face_counts_array
         - start

        """
        self.send_SetFaceCounts(node_id, part_id, face_counts_array, start)
        return self.recv_SetFaceCounts()

    def send_SetFaceCounts(self, node_id, part_id, face_counts_array, start):
        self._oprot.writeMessageBegin('SetFaceCounts', TMessageType.CALL, self._seqid)
        args = SetFaceCounts_args()
        args.node_id = node_id
        args.part_id = part_id
        args.face_counts_array = face_counts_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetFaceCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetFaceCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetFaceCounts failed: unknown result")

    def SetVertexList(self, node_id, part_id, vertex_list_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - vertex_list_array
         - start

        """
        self.send_SetVertexList(node_id, part_id, vertex_list_array, start)
        return self.recv_SetVertexList()

    def send_SetVertexList(self, node_id, part_id, vertex_list_array, start):
        self._oprot.writeMessageBegin('SetVertexList', TMessageType.CALL, self._seqid)
        args = SetVertexList_args()
        args.node_id = node_id
        args.part_id = part_id
        args.vertex_list_array = vertex_list_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVertexList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVertexList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVertexList failed: unknown result")

    def AddAttribute(self, node_id, part_id, name, attr_info):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info

        """
        self.send_AddAttribute(node_id, part_id, name, attr_info)
        return self.recv_AddAttribute()

    def send_AddAttribute(self, node_id, part_id, name, attr_info):
        self._oprot.writeMessageBegin('AddAttribute', TMessageType.CALL, self._seqid)
        args = AddAttribute_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_AddAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = AddAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "AddAttribute failed: unknown result")

    def DeleteAttribute(self, node_id, part_id, name, attr_info):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info

        """
        self.send_DeleteAttribute(node_id, part_id, name, attr_info)
        return self.recv_DeleteAttribute()

    def send_DeleteAttribute(self, node_id, part_id, name, attr_info):
        self._oprot.writeMessageBegin('DeleteAttribute', TMessageType.CALL, self._seqid)
        args = DeleteAttribute_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteAttribute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteAttribute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteAttribute failed: unknown result")

    def SetAttributeIntData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        self.send_SetAttributeIntData(node_id, part_id, name, attr_info, data_array, start)
        return self.recv_SetAttributeIntData()

    def send_SetAttributeIntData(self, node_id, part_id, name, attr_info, data_array, start):
        self._oprot.writeMessageBegin('SetAttributeIntData', TMessageType.CALL, self._seqid)
        args = SetAttributeIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.data_array = data_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAttributeIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAttributeIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAttributeIntData failed: unknown result")

    def SetAttributeInt64Data(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        self.send_SetAttributeInt64Data(node_id, part_id, name, attr_info, data_array, start)
        return self.recv_SetAttributeInt64Data()

    def send_SetAttributeInt64Data(self, node_id, part_id, name, attr_info, data_array, start):
        self._oprot.writeMessageBegin('SetAttributeInt64Data', TMessageType.CALL, self._seqid)
        args = SetAttributeInt64Data_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.data_array = data_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAttributeInt64Data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAttributeInt64Data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAttributeInt64Data failed: unknown result")

    def SetAttributeFloatData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        self.send_SetAttributeFloatData(node_id, part_id, name, attr_info, data_array, start)
        return self.recv_SetAttributeFloatData()

    def send_SetAttributeFloatData(self, node_id, part_id, name, attr_info, data_array, start):
        self._oprot.writeMessageBegin('SetAttributeFloatData', TMessageType.CALL, self._seqid)
        args = SetAttributeFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.data_array = data_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAttributeFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAttributeFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAttributeFloatData failed: unknown result")

    def SetAttributeFloat64Data(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        self.send_SetAttributeFloat64Data(node_id, part_id, name, attr_info, data_array, start)
        return self.recv_SetAttributeFloat64Data()

    def send_SetAttributeFloat64Data(self, node_id, part_id, name, attr_info, data_array, start):
        self._oprot.writeMessageBegin('SetAttributeFloat64Data', TMessageType.CALL, self._seqid)
        args = SetAttributeFloat64Data_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.data_array = data_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAttributeFloat64Data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAttributeFloat64Data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAttributeFloat64Data failed: unknown result")

    def SetAttributeStringData(self, node_id, part_id, name, attr_info, data_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - attr_info
         - data_array
         - start

        """
        self.send_SetAttributeStringData(node_id, part_id, name, attr_info, data_array, start)
        return self.recv_SetAttributeStringData()

    def send_SetAttributeStringData(self, node_id, part_id, name, attr_info, data_array, start):
        self._oprot.writeMessageBegin('SetAttributeStringData', TMessageType.CALL, self._seqid)
        args = SetAttributeStringData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.attr_info = attr_info
        args.data_array = data_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAttributeStringData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAttributeStringData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAttributeStringData failed: unknown result")

    def AddGroup(self, node_id, part_id, group_type, group_name):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name

        """
        self.send_AddGroup(node_id, part_id, group_type, group_name)
        return self.recv_AddGroup()

    def send_AddGroup(self, node_id, part_id, group_type, group_name):
        self._oprot.writeMessageBegin('AddGroup', TMessageType.CALL, self._seqid)
        args = AddGroup_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_name = group_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_AddGroup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = AddGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "AddGroup failed: unknown result")

    def DeleteGroup(self, node_id, part_id, group_type, group_name):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name

        """
        self.send_DeleteGroup(node_id, part_id, group_type, group_name)
        return self.recv_DeleteGroup()

    def send_DeleteGroup(self, node_id, part_id, group_type, group_name):
        self._oprot.writeMessageBegin('DeleteGroup', TMessageType.CALL, self._seqid)
        args = DeleteGroup_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_name = group_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteGroup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteGroup failed: unknown result")

    def SetGroupMembership(self, node_id, part_id, group_type, group_name, membership_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - group_type
         - group_name
         - membership_array
         - start

        """
        self.send_SetGroupMembership(node_id, part_id, group_type, group_name, membership_array, start)
        return self.recv_SetGroupMembership()

    def send_SetGroupMembership(self, node_id, part_id, group_type, group_name, membership_array, start):
        self._oprot.writeMessageBegin('SetGroupMembership', TMessageType.CALL, self._seqid)
        args = SetGroupMembership_args()
        args.node_id = node_id
        args.part_id = part_id
        args.group_type = group_type
        args.group_name = group_name
        args.membership_array = membership_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetGroupMembership(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetGroupMembership_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetGroupMembership failed: unknown result")

    def CommitGeo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_CommitGeo(node_id)
        return self.recv_CommitGeo()

    def send_CommitGeo(self, node_id):
        self._oprot.writeMessageBegin('CommitGeo', TMessageType.CALL, self._seqid)
        args = CommitGeo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CommitGeo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CommitGeo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CommitGeo failed: unknown result")

    def RevertGeo(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_RevertGeo(node_id)
        return self.recv_RevertGeo()

    def send_RevertGeo(self, node_id):
        self._oprot.writeMessageBegin('RevertGeo', TMessageType.CALL, self._seqid)
        args = RevertGeo_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RevertGeo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RevertGeo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RevertGeo failed: unknown result")

    def GetMaterialNodeIdsOnFaces(self, geometry_node_id, part_id, start, length):
        """
        Parameters:
         - geometry_node_id
         - part_id
         - start
         - length

        """
        self.send_GetMaterialNodeIdsOnFaces(geometry_node_id, part_id, start, length)
        return self.recv_GetMaterialNodeIdsOnFaces()

    def send_GetMaterialNodeIdsOnFaces(self, geometry_node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetMaterialNodeIdsOnFaces', TMessageType.CALL, self._seqid)
        args = GetMaterialNodeIdsOnFaces_args()
        args.geometry_node_id = geometry_node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetMaterialNodeIdsOnFaces(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetMaterialNodeIdsOnFaces_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaterialNodeIdsOnFaces failed: unknown result")

    def GetMaterialInfo(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        self.send_GetMaterialInfo(material_node_id)
        return self.recv_GetMaterialInfo()

    def send_GetMaterialInfo(self, material_node_id):
        self._oprot.writeMessageBegin('GetMaterialInfo', TMessageType.CALL, self._seqid)
        args = GetMaterialInfo_args()
        args.material_node_id = material_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetMaterialInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetMaterialInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaterialInfo failed: unknown result")

    def RenderCOPToImage(self, cop_node_id):
        """
        Parameters:
         - cop_node_id

        """
        self.send_RenderCOPToImage(cop_node_id)
        return self.recv_RenderCOPToImage()

    def send_RenderCOPToImage(self, cop_node_id):
        self._oprot.writeMessageBegin('RenderCOPToImage', TMessageType.CALL, self._seqid)
        args = RenderCOPToImage_args()
        args.cop_node_id = cop_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RenderCOPToImage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RenderCOPToImage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RenderCOPToImage failed: unknown result")

    def RenderTextureToImage(self, material_node_id, parm_id):
        """
        Parameters:
         - material_node_id
         - parm_id

        """
        self.send_RenderTextureToImage(material_node_id, parm_id)
        return self.recv_RenderTextureToImage()

    def send_RenderTextureToImage(self, material_node_id, parm_id):
        self._oprot.writeMessageBegin('RenderTextureToImage', TMessageType.CALL, self._seqid)
        args = RenderTextureToImage_args()
        args.material_node_id = material_node_id
        args.parm_id = parm_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RenderTextureToImage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RenderTextureToImage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RenderTextureToImage failed: unknown result")

    def GetImageInfo(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        self.send_GetImageInfo(material_node_id)
        return self.recv_GetImageInfo()

    def send_GetImageInfo(self, material_node_id):
        self._oprot.writeMessageBegin('GetImageInfo', TMessageType.CALL, self._seqid)
        args = GetImageInfo_args()
        args.material_node_id = material_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetImageInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetImageInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImageInfo failed: unknown result")

    def SetImageInfo(self, material_node_id, image_info):
        """
        Parameters:
         - material_node_id
         - image_info

        """
        self.send_SetImageInfo(material_node_id, image_info)
        return self.recv_SetImageInfo()

    def send_SetImageInfo(self, material_node_id, image_info):
        self._oprot.writeMessageBegin('SetImageInfo', TMessageType.CALL, self._seqid)
        args = SetImageInfo_args()
        args.material_node_id = material_node_id
        args.image_info = image_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetImageInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetImageInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetImageInfo failed: unknown result")

    def GetImagePlaneCount(self, material_node_id):
        """
        Parameters:
         - material_node_id

        """
        self.send_GetImagePlaneCount(material_node_id)
        return self.recv_GetImagePlaneCount()

    def send_GetImagePlaneCount(self, material_node_id):
        self._oprot.writeMessageBegin('GetImagePlaneCount', TMessageType.CALL, self._seqid)
        args = GetImagePlaneCount_args()
        args.material_node_id = material_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetImagePlaneCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetImagePlaneCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImagePlaneCount failed: unknown result")

    def GetImagePlanes(self, material_node_id, image_plane_count):
        """
        Parameters:
         - material_node_id
         - image_plane_count

        """
        self.send_GetImagePlanes(material_node_id, image_plane_count)
        return self.recv_GetImagePlanes()

    def send_GetImagePlanes(self, material_node_id, image_plane_count):
        self._oprot.writeMessageBegin('GetImagePlanes', TMessageType.CALL, self._seqid)
        args = GetImagePlanes_args()
        args.material_node_id = material_node_id
        args.image_plane_count = image_plane_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetImagePlanes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetImagePlanes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImagePlanes failed: unknown result")

    def ExtractImageToFile(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes
         - destination_folder_path
         - destination_file_name

        """
        self.send_ExtractImageToFile(material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name)
        return self.recv_ExtractImageToFile()

    def send_ExtractImageToFile(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name):
        self._oprot.writeMessageBegin('ExtractImageToFile', TMessageType.CALL, self._seqid)
        args = ExtractImageToFile_args()
        args.material_node_id = material_node_id
        args.image_file_format_name = image_file_format_name
        args.image_planes = image_planes
        args.destination_folder_path = destination_folder_path
        args.destination_file_name = destination_file_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExtractImageToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExtractImageToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ExtractImageToFile failed: unknown result")

    def GetImageFilePath(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name, texture_parm_id):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes
         - destination_folder_path
         - destination_file_name
         - texture_parm_id

        """
        self.send_GetImageFilePath(material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name, texture_parm_id)
        return self.recv_GetImageFilePath()

    def send_GetImageFilePath(self, material_node_id, image_file_format_name, image_planes, destination_folder_path, destination_file_name, texture_parm_id):
        self._oprot.writeMessageBegin('GetImageFilePath', TMessageType.CALL, self._seqid)
        args = GetImageFilePath_args()
        args.material_node_id = material_node_id
        args.image_file_format_name = image_file_format_name
        args.image_planes = image_planes
        args.destination_folder_path = destination_folder_path
        args.destination_file_name = destination_file_name
        args.texture_parm_id = texture_parm_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetImageFilePath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetImageFilePath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImageFilePath failed: unknown result")

    def ExtractImageToMemory(self, material_node_id, image_file_format_name, image_planes):
        """
        Parameters:
         - material_node_id
         - image_file_format_name
         - image_planes

        """
        self.send_ExtractImageToMemory(material_node_id, image_file_format_name, image_planes)
        return self.recv_ExtractImageToMemory()

    def send_ExtractImageToMemory(self, material_node_id, image_file_format_name, image_planes):
        self._oprot.writeMessageBegin('ExtractImageToMemory', TMessageType.CALL, self._seqid)
        args = ExtractImageToMemory_args()
        args.material_node_id = material_node_id
        args.image_file_format_name = image_file_format_name
        args.image_planes = image_planes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExtractImageToMemory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExtractImageToMemory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ExtractImageToMemory failed: unknown result")

    def GetImageMemoryBuffer(self, material_node_id, length):
        """
        Parameters:
         - material_node_id
         - length

        """
        self.send_GetImageMemoryBuffer(material_node_id, length)
        return self.recv_GetImageMemoryBuffer()

    def send_GetImageMemoryBuffer(self, material_node_id, length):
        self._oprot.writeMessageBegin('GetImageMemoryBuffer', TMessageType.CALL, self._seqid)
        args = GetImageMemoryBuffer_args()
        args.material_node_id = material_node_id
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetImageMemoryBuffer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetImageMemoryBuffer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImageMemoryBuffer failed: unknown result")

    def GetSupportedImageFileFormatCount(self):
        self.send_GetSupportedImageFileFormatCount()
        return self.recv_GetSupportedImageFileFormatCount()

    def send_GetSupportedImageFileFormatCount(self):
        self._oprot.writeMessageBegin('GetSupportedImageFileFormatCount', TMessageType.CALL, self._seqid)
        args = GetSupportedImageFileFormatCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSupportedImageFileFormatCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSupportedImageFileFormatCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSupportedImageFileFormatCount failed: unknown result")

    def GetSupportedImageFileFormats(self, file_format_count):
        """
        Parameters:
         - file_format_count

        """
        self.send_GetSupportedImageFileFormats(file_format_count)
        return self.recv_GetSupportedImageFileFormats()

    def send_GetSupportedImageFileFormats(self, file_format_count):
        self._oprot.writeMessageBegin('GetSupportedImageFileFormats', TMessageType.CALL, self._seqid)
        args = GetSupportedImageFileFormats_args()
        args.file_format_count = file_format_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSupportedImageFileFormats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSupportedImageFileFormats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSupportedImageFileFormats failed: unknown result")

    def SetAnimCurve(self, node_id, parm_id, parm_index, curve_keyframes_array):
        """
        Parameters:
         - node_id
         - parm_id
         - parm_index
         - curve_keyframes_array

        """
        self.send_SetAnimCurve(node_id, parm_id, parm_index, curve_keyframes_array)
        return self.recv_SetAnimCurve()

    def send_SetAnimCurve(self, node_id, parm_id, parm_index, curve_keyframes_array):
        self._oprot.writeMessageBegin('SetAnimCurve', TMessageType.CALL, self._seqid)
        args = SetAnimCurve_args()
        args.node_id = node_id
        args.parm_id = parm_id
        args.parm_index = parm_index
        args.curve_keyframes_array = curve_keyframes_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetAnimCurve(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetAnimCurve_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetAnimCurve failed: unknown result")

    def SetTransformAnimCurve(self, node_id, trans_comp, curve_keyframes_array):
        """
        Parameters:
         - node_id
         - trans_comp
         - curve_keyframes_array

        """
        self.send_SetTransformAnimCurve(node_id, trans_comp, curve_keyframes_array)
        return self.recv_SetTransformAnimCurve()

    def send_SetTransformAnimCurve(self, node_id, trans_comp, curve_keyframes_array):
        self._oprot.writeMessageBegin('SetTransformAnimCurve', TMessageType.CALL, self._seqid)
        args = SetTransformAnimCurve_args()
        args.node_id = node_id
        args.trans_comp = trans_comp
        args.curve_keyframes_array = curve_keyframes_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetTransformAnimCurve(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetTransformAnimCurve_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetTransformAnimCurve failed: unknown result")

    def ResetSimulation(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_ResetSimulation(node_id)
        return self.recv_ResetSimulation()

    def send_ResetSimulation(self, node_id):
        self._oprot.writeMessageBegin('ResetSimulation', TMessageType.CALL, self._seqid)
        args = ResetSimulation_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ResetSimulation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ResetSimulation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ResetSimulation failed: unknown result")

    def GetVolumeInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetVolumeInfo(node_id, part_id)
        return self.recv_GetVolumeInfo()

    def send_GetVolumeInfo(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetVolumeInfo', TMessageType.CALL, self._seqid)
        args = GetVolumeInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeInfo failed: unknown result")

    def GetFirstVolumeTile(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetFirstVolumeTile(node_id, part_id)
        return self.recv_GetFirstVolumeTile()

    def send_GetFirstVolumeTile(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetFirstVolumeTile', TMessageType.CALL, self._seqid)
        args = GetFirstVolumeTile_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetFirstVolumeTile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetFirstVolumeTile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFirstVolumeTile failed: unknown result")

    def GetNextVolumeTile(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetNextVolumeTile(node_id, part_id)
        return self.recv_GetNextVolumeTile()

    def send_GetNextVolumeTile(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetNextVolumeTile', TMessageType.CALL, self._seqid)
        args = GetNextVolumeTile_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNextVolumeTile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNextVolumeTile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNextVolumeTile failed: unknown result")

    def GetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - value_count

        """
        self.send_GetVolumeVoxelFloatData(node_id, part_id, x_index, y_index, z_index, value_count)
        return self.recv_GetVolumeVoxelFloatData()

    def send_GetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        self._oprot.writeMessageBegin('GetVolumeVoxelFloatData', TMessageType.CALL, self._seqid)
        args = GetVolumeVoxelFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.x_index = x_index
        args.y_index = y_index
        args.z_index = z_index
        args.value_count = value_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeVoxelFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeVoxelFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeVoxelFloatData failed: unknown result")

    def GetVolumeTileFloatData(self, node_id, part_id, fill_value, tile, length):
        """
        Parameters:
         - node_id
         - part_id
         - fill_value
         - tile
         - length

        """
        self.send_GetVolumeTileFloatData(node_id, part_id, fill_value, tile, length)
        return self.recv_GetVolumeTileFloatData()

    def send_GetVolumeTileFloatData(self, node_id, part_id, fill_value, tile, length):
        self._oprot.writeMessageBegin('GetVolumeTileFloatData', TMessageType.CALL, self._seqid)
        args = GetVolumeTileFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.fill_value = fill_value
        args.tile = tile
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeTileFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeTileFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeTileFloatData failed: unknown result")

    def GetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - value_count

        """
        self.send_GetVolumeVoxelIntData(node_id, part_id, x_index, y_index, z_index, value_count)
        return self.recv_GetVolumeVoxelIntData()

    def send_GetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, value_count):
        self._oprot.writeMessageBegin('GetVolumeVoxelIntData', TMessageType.CALL, self._seqid)
        args = GetVolumeVoxelIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.x_index = x_index
        args.y_index = y_index
        args.z_index = z_index
        args.value_count = value_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeVoxelIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeVoxelIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeVoxelIntData failed: unknown result")

    def GetVolumeTileIntData(self, node_id, part_id, fill_value, tile, length):
        """
        Parameters:
         - node_id
         - part_id
         - fill_value
         - tile
         - length

        """
        self.send_GetVolumeTileIntData(node_id, part_id, fill_value, tile, length)
        return self.recv_GetVolumeTileIntData()

    def send_GetVolumeTileIntData(self, node_id, part_id, fill_value, tile, length):
        self._oprot.writeMessageBegin('GetVolumeTileIntData', TMessageType.CALL, self._seqid)
        args = GetVolumeTileIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.fill_value = fill_value
        args.tile = tile
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeTileIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeTileIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeTileIntData failed: unknown result")

    def GetHeightFieldData(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetHeightFieldData(node_id, part_id, start, length)
        return self.recv_GetHeightFieldData()

    def send_GetHeightFieldData(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetHeightFieldData', TMessageType.CALL, self._seqid)
        args = GetHeightFieldData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHeightFieldData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHeightFieldData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHeightFieldData failed: unknown result")

    def SetVolumeInfo(self, node_id, part_id, volume_info):
        """
        Parameters:
         - node_id
         - part_id
         - volume_info

        """
        self.send_SetVolumeInfo(node_id, part_id, volume_info)
        return self.recv_SetVolumeInfo()

    def send_SetVolumeInfo(self, node_id, part_id, volume_info):
        self._oprot.writeMessageBegin('SetVolumeInfo', TMessageType.CALL, self._seqid)
        args = SetVolumeInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.volume_info = volume_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVolumeInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVolumeInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVolumeInfo failed: unknown result")

    def SetVolumeTileFloatData(self, node_id, part_id, tile, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - tile
         - values_array

        """
        self.send_SetVolumeTileFloatData(node_id, part_id, tile, values_array)
        return self.recv_SetVolumeTileFloatData()

    def send_SetVolumeTileFloatData(self, node_id, part_id, tile, values_array):
        self._oprot.writeMessageBegin('SetVolumeTileFloatData', TMessageType.CALL, self._seqid)
        args = SetVolumeTileFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.tile = tile
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVolumeTileFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVolumeTileFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVolumeTileFloatData failed: unknown result")

    def SetVolumeTileIntData(self, node_id, part_id, tile, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - tile
         - values_array

        """
        self.send_SetVolumeTileIntData(node_id, part_id, tile, values_array)
        return self.recv_SetVolumeTileIntData()

    def send_SetVolumeTileIntData(self, node_id, part_id, tile, values_array):
        self._oprot.writeMessageBegin('SetVolumeTileIntData', TMessageType.CALL, self._seqid)
        args = SetVolumeTileIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.tile = tile
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVolumeTileIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVolumeTileIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVolumeTileIntData failed: unknown result")

    def SetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - values_array

        """
        self.send_SetVolumeVoxelFloatData(node_id, part_id, x_index, y_index, z_index, values_array)
        return self.recv_SetVolumeVoxelFloatData()

    def send_SetVolumeVoxelFloatData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        self._oprot.writeMessageBegin('SetVolumeVoxelFloatData', TMessageType.CALL, self._seqid)
        args = SetVolumeVoxelFloatData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.x_index = x_index
        args.y_index = y_index
        args.z_index = z_index
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVolumeVoxelFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVolumeVoxelFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVolumeVoxelFloatData failed: unknown result")

    def SetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        """
        Parameters:
         - node_id
         - part_id
         - x_index
         - y_index
         - z_index
         - values_array

        """
        self.send_SetVolumeVoxelIntData(node_id, part_id, x_index, y_index, z_index, values_array)
        return self.recv_SetVolumeVoxelIntData()

    def send_SetVolumeVoxelIntData(self, node_id, part_id, x_index, y_index, z_index, values_array):
        self._oprot.writeMessageBegin('SetVolumeVoxelIntData', TMessageType.CALL, self._seqid)
        args = SetVolumeVoxelIntData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.x_index = x_index
        args.y_index = y_index
        args.z_index = z_index
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetVolumeVoxelIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetVolumeVoxelIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetVolumeVoxelIntData failed: unknown result")

    def GetVolumeBounds(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetVolumeBounds(node_id, part_id)
        return self.recv_GetVolumeBounds()

    def send_GetVolumeBounds(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetVolumeBounds', TMessageType.CALL, self._seqid)
        args = GetVolumeBounds_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetVolumeBounds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetVolumeBounds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetVolumeBounds failed: unknown result")

    def SetHeightFieldData(self, node_id, part_id, name, values_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - name
         - values_array
         - start

        """
        self.send_SetHeightFieldData(node_id, part_id, name, values_array, start)
        return self.recv_SetHeightFieldData()

    def send_SetHeightFieldData(self, node_id, part_id, name, values_array, start):
        self._oprot.writeMessageBegin('SetHeightFieldData', TMessageType.CALL, self._seqid)
        args = SetHeightFieldData_args()
        args.node_id = node_id
        args.part_id = part_id
        args.name = name
        args.values_array = values_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetHeightFieldData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetHeightFieldData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetHeightFieldData failed: unknown result")

    def GetCurveInfo(self, node_id, part_id):
        """
        Parameters:
         - node_id
         - part_id

        """
        self.send_GetCurveInfo(node_id, part_id)
        return self.recv_GetCurveInfo()

    def send_GetCurveInfo(self, node_id, part_id):
        self._oprot.writeMessageBegin('GetCurveInfo', TMessageType.CALL, self._seqid)
        args = GetCurveInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCurveInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCurveInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCurveInfo failed: unknown result")

    def GetCurveCounts(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetCurveCounts(node_id, part_id, start, length)
        return self.recv_GetCurveCounts()

    def send_GetCurveCounts(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetCurveCounts', TMessageType.CALL, self._seqid)
        args = GetCurveCounts_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCurveCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCurveCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCurveCounts failed: unknown result")

    def GetCurveOrders(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetCurveOrders(node_id, part_id, start, length)
        return self.recv_GetCurveOrders()

    def send_GetCurveOrders(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetCurveOrders', TMessageType.CALL, self._seqid)
        args = GetCurveOrders_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCurveOrders(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCurveOrders_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCurveOrders failed: unknown result")

    def GetCurveKnots(self, node_id, part_id, start, length):
        """
        Parameters:
         - node_id
         - part_id
         - start
         - length

        """
        self.send_GetCurveKnots(node_id, part_id, start, length)
        return self.recv_GetCurveKnots()

    def send_GetCurveKnots(self, node_id, part_id, start, length):
        self._oprot.writeMessageBegin('GetCurveKnots', TMessageType.CALL, self._seqid)
        args = GetCurveKnots_args()
        args.node_id = node_id
        args.part_id = part_id
        args.start = start
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCurveKnots(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCurveKnots_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCurveKnots failed: unknown result")

    def SetCurveInfo(self, node_id, part_id, info):
        """
        Parameters:
         - node_id
         - part_id
         - info

        """
        self.send_SetCurveInfo(node_id, part_id, info)
        return self.recv_SetCurveInfo()

    def send_SetCurveInfo(self, node_id, part_id, info):
        self._oprot.writeMessageBegin('SetCurveInfo', TMessageType.CALL, self._seqid)
        args = SetCurveInfo_args()
        args.node_id = node_id
        args.part_id = part_id
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCurveInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCurveInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCurveInfo failed: unknown result")

    def SetCurveCounts(self, node_id, part_id, counts_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - counts_array
         - start

        """
        self.send_SetCurveCounts(node_id, part_id, counts_array, start)
        return self.recv_SetCurveCounts()

    def send_SetCurveCounts(self, node_id, part_id, counts_array, start):
        self._oprot.writeMessageBegin('SetCurveCounts', TMessageType.CALL, self._seqid)
        args = SetCurveCounts_args()
        args.node_id = node_id
        args.part_id = part_id
        args.counts_array = counts_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCurveCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCurveCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCurveCounts failed: unknown result")

    def SetCurveOrders(self, node_id, part_id, orders_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - orders_array
         - start

        """
        self.send_SetCurveOrders(node_id, part_id, orders_array, start)
        return self.recv_SetCurveOrders()

    def send_SetCurveOrders(self, node_id, part_id, orders_array, start):
        self._oprot.writeMessageBegin('SetCurveOrders', TMessageType.CALL, self._seqid)
        args = SetCurveOrders_args()
        args.node_id = node_id
        args.part_id = part_id
        args.orders_array = orders_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCurveOrders(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCurveOrders_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCurveOrders failed: unknown result")

    def SetCurveKnots(self, node_id, part_id, knots_array, start):
        """
        Parameters:
         - node_id
         - part_id
         - knots_array
         - start

        """
        self.send_SetCurveKnots(node_id, part_id, knots_array, start)
        return self.recv_SetCurveKnots()

    def send_SetCurveKnots(self, node_id, part_id, knots_array, start):
        self._oprot.writeMessageBegin('SetCurveKnots', TMessageType.CALL, self._seqid)
        args = SetCurveKnots_args()
        args.node_id = node_id
        args.part_id = part_id
        args.knots_array = knots_array
        args.start = start
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCurveKnots(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCurveKnots_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCurveKnots failed: unknown result")

    def GetBoxInfo(self, geo_node_id, part_id):
        """
        Parameters:
         - geo_node_id
         - part_id

        """
        self.send_GetBoxInfo(geo_node_id, part_id)
        return self.recv_GetBoxInfo()

    def send_GetBoxInfo(self, geo_node_id, part_id):
        self._oprot.writeMessageBegin('GetBoxInfo', TMessageType.CALL, self._seqid)
        args = GetBoxInfo_args()
        args.geo_node_id = geo_node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetBoxInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetBoxInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetBoxInfo failed: unknown result")

    def GetSphereInfo(self, geo_node_id, part_id):
        """
        Parameters:
         - geo_node_id
         - part_id

        """
        self.send_GetSphereInfo(geo_node_id, part_id)
        return self.recv_GetSphereInfo()

    def send_GetSphereInfo(self, geo_node_id, part_id):
        self._oprot.writeMessageBegin('GetSphereInfo', TMessageType.CALL, self._seqid)
        args = GetSphereInfo_args()
        args.geo_node_id = geo_node_id
        args.part_id = part_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSphereInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSphereInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSphereInfo failed: unknown result")

    def GetActiveCacheCount(self):
        self.send_GetActiveCacheCount()
        return self.recv_GetActiveCacheCount()

    def send_GetActiveCacheCount(self):
        self._oprot.writeMessageBegin('GetActiveCacheCount', TMessageType.CALL, self._seqid)
        args = GetActiveCacheCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetActiveCacheCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetActiveCacheCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetActiveCacheCount failed: unknown result")

    def GetActiveCacheNames(self, active_cache_count):
        """
        Parameters:
         - active_cache_count

        """
        self.send_GetActiveCacheNames(active_cache_count)
        return self.recv_GetActiveCacheNames()

    def send_GetActiveCacheNames(self, active_cache_count):
        self._oprot.writeMessageBegin('GetActiveCacheNames', TMessageType.CALL, self._seqid)
        args = GetActiveCacheNames_args()
        args.active_cache_count = active_cache_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetActiveCacheNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetActiveCacheNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetActiveCacheNames failed: unknown result")

    def GetCacheProperty(self, cache_name, cache_property):
        """
        Parameters:
         - cache_name
         - cache_property

        """
        self.send_GetCacheProperty(cache_name, cache_property)
        return self.recv_GetCacheProperty()

    def send_GetCacheProperty(self, cache_name, cache_property):
        self._oprot.writeMessageBegin('GetCacheProperty', TMessageType.CALL, self._seqid)
        args = GetCacheProperty_args()
        args.cache_name = cache_name
        args.cache_property = cache_property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetCacheProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetCacheProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCacheProperty failed: unknown result")

    def SetCacheProperty(self, cache_name, cache_property, property_value):
        """
        Parameters:
         - cache_name
         - cache_property
         - property_value

        """
        self.send_SetCacheProperty(cache_name, cache_property, property_value)
        return self.recv_SetCacheProperty()

    def send_SetCacheProperty(self, cache_name, cache_property, property_value):
        self._oprot.writeMessageBegin('SetCacheProperty', TMessageType.CALL, self._seqid)
        args = SetCacheProperty_args()
        args.cache_name = cache_name
        args.cache_property = cache_property
        args.property_value = property_value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetCacheProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetCacheProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetCacheProperty failed: unknown result")

    def SaveGeoToFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        self.send_SaveGeoToFile(node_id, file_name)
        return self.recv_SaveGeoToFile()

    def send_SaveGeoToFile(self, node_id, file_name):
        self._oprot.writeMessageBegin('SaveGeoToFile', TMessageType.CALL, self._seqid)
        args = SaveGeoToFile_args()
        args.node_id = node_id
        args.file_name = file_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SaveGeoToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SaveGeoToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SaveGeoToFile failed: unknown result")

    def LoadGeoFromFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        self.send_LoadGeoFromFile(node_id, file_name)
        return self.recv_LoadGeoFromFile()

    def send_LoadGeoFromFile(self, node_id, file_name):
        self._oprot.writeMessageBegin('LoadGeoFromFile', TMessageType.CALL, self._seqid)
        args = LoadGeoFromFile_args()
        args.node_id = node_id
        args.file_name = file_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadGeoFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadGeoFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadGeoFromFile failed: unknown result")

    def SaveNodeToFile(self, node_id, file_name):
        """
        Parameters:
         - node_id
         - file_name

        """
        self.send_SaveNodeToFile(node_id, file_name)
        return self.recv_SaveNodeToFile()

    def send_SaveNodeToFile(self, node_id, file_name):
        self._oprot.writeMessageBegin('SaveNodeToFile', TMessageType.CALL, self._seqid)
        args = SaveNodeToFile_args()
        args.node_id = node_id
        args.file_name = file_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SaveNodeToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SaveNodeToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SaveNodeToFile failed: unknown result")

    def LoadNodeFromFile(self, file_name, parent_node_id, node_label, cook_on_load):
        """
        Parameters:
         - file_name
         - parent_node_id
         - node_label
         - cook_on_load

        """
        self.send_LoadNodeFromFile(file_name, parent_node_id, node_label, cook_on_load)
        return self.recv_LoadNodeFromFile()

    def send_LoadNodeFromFile(self, file_name, parent_node_id, node_label, cook_on_load):
        self._oprot.writeMessageBegin('LoadNodeFromFile', TMessageType.CALL, self._seqid)
        args = LoadNodeFromFile_args()
        args.file_name = file_name
        args.parent_node_id = parent_node_id
        args.node_label = node_label
        args.cook_on_load = cook_on_load
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadNodeFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadNodeFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadNodeFromFile failed: unknown result")

    def GetGeoSize(self, node_id, format):
        """
        Parameters:
         - node_id
         - format

        """
        self.send_GetGeoSize(node_id, format)
        return self.recv_GetGeoSize()

    def send_GetGeoSize(self, node_id, format):
        self._oprot.writeMessageBegin('GetGeoSize', TMessageType.CALL, self._seqid)
        args = GetGeoSize_args()
        args.node_id = node_id
        args.format = format
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGeoSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGeoSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGeoSize failed: unknown result")

    def SaveGeoToMemory(self, node_id, length):
        """
        Parameters:
         - node_id
         - length

        """
        self.send_SaveGeoToMemory(node_id, length)
        return self.recv_SaveGeoToMemory()

    def send_SaveGeoToMemory(self, node_id, length):
        self._oprot.writeMessageBegin('SaveGeoToMemory', TMessageType.CALL, self._seqid)
        args = SaveGeoToMemory_args()
        args.node_id = node_id
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SaveGeoToMemory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SaveGeoToMemory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SaveGeoToMemory failed: unknown result")

    def LoadGeoFromMemory(self, node_id, format, buffer, length):
        """
        Parameters:
         - node_id
         - format
         - buffer
         - length

        """
        self.send_LoadGeoFromMemory(node_id, format, buffer, length)
        return self.recv_LoadGeoFromMemory()

    def send_LoadGeoFromMemory(self, node_id, format, buffer, length):
        self._oprot.writeMessageBegin('LoadGeoFromMemory', TMessageType.CALL, self._seqid)
        args = LoadGeoFromMemory_args()
        args.node_id = node_id
        args.format = format
        args.buffer = buffer
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadGeoFromMemory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadGeoFromMemory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadGeoFromMemory failed: unknown result")

    def SetNodeDisplay(self, node_id, onOff):
        """
        Parameters:
         - node_id
         - onOff

        """
        self.send_SetNodeDisplay(node_id, onOff)
        return self.recv_SetNodeDisplay()

    def send_SetNodeDisplay(self, node_id, onOff):
        self._oprot.writeMessageBegin('SetNodeDisplay', TMessageType.CALL, self._seqid)
        args = SetNodeDisplay_args()
        args.node_id = node_id
        args.onOff = onOff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetNodeDisplay(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetNodeDisplay_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetNodeDisplay failed: unknown result")

    def GetTotalCookCount(self, node_id, node_type_filter, node_flags_filter, recursive):
        """
        Parameters:
         - node_id
         - node_type_filter
         - node_flags_filter
         - recursive

        """
        self.send_GetTotalCookCount(node_id, node_type_filter, node_flags_filter, recursive)
        return self.recv_GetTotalCookCount()

    def send_GetTotalCookCount(self, node_id, node_type_filter, node_flags_filter, recursive):
        self._oprot.writeMessageBegin('GetTotalCookCount', TMessageType.CALL, self._seqid)
        args = GetTotalCookCount_args()
        args.node_id = node_id
        args.node_type_filter = node_type_filter
        args.node_flags_filter = node_flags_filter
        args.recursive = recursive
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetTotalCookCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetTotalCookCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTotalCookCount failed: unknown result")

    def SetSessionSync(self, enable):
        """
        Parameters:
         - enable

        """
        self.send_SetSessionSync(enable)
        return self.recv_SetSessionSync()

    def send_SetSessionSync(self, enable):
        self._oprot.writeMessageBegin('SetSessionSync', TMessageType.CALL, self._seqid)
        args = SetSessionSync_args()
        args.enable = enable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetSessionSync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetSessionSync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSessionSync failed: unknown result")

    def GetViewport(self):
        self.send_GetViewport()
        return self.recv_GetViewport()

    def send_GetViewport(self):
        self._oprot.writeMessageBegin('GetViewport', TMessageType.CALL, self._seqid)
        args = GetViewport_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetViewport(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetViewport_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetViewport failed: unknown result")

    def SetViewport(self, viewport):
        """
        Parameters:
         - viewport

        """
        self.send_SetViewport(viewport)
        return self.recv_SetViewport()

    def send_SetViewport(self, viewport):
        self._oprot.writeMessageBegin('SetViewport', TMessageType.CALL, self._seqid)
        args = SetViewport_args()
        args.viewport = viewport
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetViewport(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetViewport_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetViewport failed: unknown result")

    def GetSessionSyncInfo(self):
        self.send_GetSessionSyncInfo()
        return self.recv_GetSessionSyncInfo()

    def send_GetSessionSyncInfo(self):
        self._oprot.writeMessageBegin('GetSessionSyncInfo', TMessageType.CALL, self._seqid)
        args = GetSessionSyncInfo_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSessionSyncInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSessionSyncInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSessionSyncInfo failed: unknown result")

    def SetSessionSyncInfo(self, session_sync_info):
        """
        Parameters:
         - session_sync_info

        """
        self.send_SetSessionSyncInfo(session_sync_info)
        return self.recv_SetSessionSyncInfo()

    def send_SetSessionSyncInfo(self, session_sync_info):
        self._oprot.writeMessageBegin('SetSessionSyncInfo', TMessageType.CALL, self._seqid)
        args = SetSessionSyncInfo_args()
        args.session_sync_info = session_sync_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetSessionSyncInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetSessionSyncInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetSessionSyncInfo failed: unknown result")

    def GetPDGGraphContexts(self, count):
        """
        Parameters:
         - count

        """
        self.send_GetPDGGraphContexts(count)
        return self.recv_GetPDGGraphContexts()

    def send_GetPDGGraphContexts(self, count):
        self._oprot.writeMessageBegin('GetPDGGraphContexts', TMessageType.CALL, self._seqid)
        args = GetPDGGraphContexts_args()
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPDGGraphContexts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPDGGraphContexts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPDGGraphContexts failed: unknown result")

    def GetPDGGraphContextId(self, top_node_id):
        """
        Parameters:
         - top_node_id

        """
        self.send_GetPDGGraphContextId(top_node_id)
        return self.recv_GetPDGGraphContextId()

    def send_GetPDGGraphContextId(self, top_node_id):
        self._oprot.writeMessageBegin('GetPDGGraphContextId', TMessageType.CALL, self._seqid)
        args = GetPDGGraphContextId_args()
        args.top_node_id = top_node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPDGGraphContextId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPDGGraphContextId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPDGGraphContextId failed: unknown result")

    def CookPDG(self, cook_node_id, generate_only, blocking):
        """
        Parameters:
         - cook_node_id
         - generate_only
         - blocking

        """
        self.send_CookPDG(cook_node_id, generate_only, blocking)
        return self.recv_CookPDG()

    def send_CookPDG(self, cook_node_id, generate_only, blocking):
        self._oprot.writeMessageBegin('CookPDG', TMessageType.CALL, self._seqid)
        args = CookPDG_args()
        args.cook_node_id = cook_node_id
        args.generate_only = generate_only
        args.blocking = blocking
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CookPDG(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CookPDG_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CookPDG failed: unknown result")

    def GetPDGEvents(self, graph_context_id, length):
        """
        Parameters:
         - graph_context_id
         - length

        """
        self.send_GetPDGEvents(graph_context_id, length)
        return self.recv_GetPDGEvents()

    def send_GetPDGEvents(self, graph_context_id, length):
        self._oprot.writeMessageBegin('GetPDGEvents', TMessageType.CALL, self._seqid)
        args = GetPDGEvents_args()
        args.graph_context_id = graph_context_id
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPDGEvents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPDGEvents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPDGEvents failed: unknown result")

    def GetPDGState(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        self.send_GetPDGState(graph_context_id)
        return self.recv_GetPDGState()

    def send_GetPDGState(self, graph_context_id):
        self._oprot.writeMessageBegin('GetPDGState', TMessageType.CALL, self._seqid)
        args = GetPDGState_args()
        args.graph_context_id = graph_context_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPDGState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPDGState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPDGState failed: unknown result")

    def CreateWorkitem(self, node_id, name, index):
        """
        Parameters:
         - node_id
         - name
         - index

        """
        self.send_CreateWorkitem(node_id, name, index)
        return self.recv_CreateWorkitem()

    def send_CreateWorkitem(self, node_id, name, index):
        self._oprot.writeMessageBegin('CreateWorkitem', TMessageType.CALL, self._seqid)
        args = CreateWorkitem_args()
        args.node_id = node_id
        args.name = name
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateWorkitem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateWorkitem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateWorkitem failed: unknown result")

    def GetWorkitemInfo(self, graph_context_id, workitem_id):
        """
        Parameters:
         - graph_context_id
         - workitem_id

        """
        self.send_GetWorkitemInfo(graph_context_id, workitem_id)
        return self.recv_GetWorkitemInfo()

    def send_GetWorkitemInfo(self, graph_context_id, workitem_id):
        self._oprot.writeMessageBegin('GetWorkitemInfo', TMessageType.CALL, self._seqid)
        args = GetWorkitemInfo_args()
        args.graph_context_id = graph_context_id
        args.workitem_id = workitem_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemInfo failed: unknown result")

    def SetWorkitemIntData(self, node_id, workitem_id, data_name, values_array):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - values_array

        """
        self.send_SetWorkitemIntData(node_id, workitem_id, data_name, values_array)
        return self.recv_SetWorkitemIntData()

    def send_SetWorkitemIntData(self, node_id, workitem_id, data_name, values_array):
        self._oprot.writeMessageBegin('SetWorkitemIntData', TMessageType.CALL, self._seqid)
        args = SetWorkitemIntData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetWorkitemIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetWorkitemIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetWorkitemIntData failed: unknown result")

    def SetWorkitemFloatData(self, node_id, workitem_id, data_name, values_array):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - values_array

        """
        self.send_SetWorkitemFloatData(node_id, workitem_id, data_name, values_array)
        return self.recv_SetWorkitemFloatData()

    def send_SetWorkitemFloatData(self, node_id, workitem_id, data_name, values_array):
        self._oprot.writeMessageBegin('SetWorkitemFloatData', TMessageType.CALL, self._seqid)
        args = SetWorkitemFloatData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.values_array = values_array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetWorkitemFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetWorkitemFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetWorkitemFloatData failed: unknown result")

    def SetWorkitemStringData(self, node_id, workitem_id, data_name, data_index, value):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - data_index
         - value

        """
        self.send_SetWorkitemStringData(node_id, workitem_id, data_name, data_index, value)
        return self.recv_SetWorkitemStringData()

    def send_SetWorkitemStringData(self, node_id, workitem_id, data_name, data_index, value):
        self._oprot.writeMessageBegin('SetWorkitemStringData', TMessageType.CALL, self._seqid)
        args = SetWorkitemStringData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.data_index = data_index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetWorkitemStringData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetWorkitemStringData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SetWorkitemStringData failed: unknown result")

    def CommitWorkitems(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_CommitWorkitems(node_id)
        return self.recv_CommitWorkitems()

    def send_CommitWorkitems(self, node_id):
        self._oprot.writeMessageBegin('CommitWorkitems', TMessageType.CALL, self._seqid)
        args = CommitWorkitems_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CommitWorkitems(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CommitWorkitems_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CommitWorkitems failed: unknown result")

    def GetNumWorkitems(self, node_id):
        """
        Parameters:
         - node_id

        """
        self.send_GetNumWorkitems(node_id)
        return self.recv_GetNumWorkitems()

    def send_GetNumWorkitems(self, node_id):
        self._oprot.writeMessageBegin('GetNumWorkitems', TMessageType.CALL, self._seqid)
        args = GetNumWorkitems_args()
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNumWorkitems(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNumWorkitems_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNumWorkitems failed: unknown result")

    def GetWorkitems(self, node_id, length):
        """
        Parameters:
         - node_id
         - length

        """
        self.send_GetWorkitems(node_id, length)
        return self.recv_GetWorkitems()

    def send_GetWorkitems(self, node_id, length):
        self._oprot.writeMessageBegin('GetWorkitems', TMessageType.CALL, self._seqid)
        args = GetWorkitems_args()
        args.node_id = node_id
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitems(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitems_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitems failed: unknown result")

    def GetWorkitemDataLength(self, node_id, workitem_id, data_name):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name

        """
        self.send_GetWorkitemDataLength(node_id, workitem_id, data_name)
        return self.recv_GetWorkitemDataLength()

    def send_GetWorkitemDataLength(self, node_id, workitem_id, data_name):
        self._oprot.writeMessageBegin('GetWorkitemDataLength', TMessageType.CALL, self._seqid)
        args = GetWorkitemDataLength_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemDataLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemDataLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemDataLength failed: unknown result")

    def GetWorkitemIntData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        self.send_GetWorkitemIntData(node_id, workitem_id, data_name, length)
        return self.recv_GetWorkitemIntData()

    def send_GetWorkitemIntData(self, node_id, workitem_id, data_name, length):
        self._oprot.writeMessageBegin('GetWorkitemIntData', TMessageType.CALL, self._seqid)
        args = GetWorkitemIntData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemIntData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemIntData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemIntData failed: unknown result")

    def GetWorkitemFloatData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        self.send_GetWorkitemFloatData(node_id, workitem_id, data_name, length)
        return self.recv_GetWorkitemFloatData()

    def send_GetWorkitemFloatData(self, node_id, workitem_id, data_name, length):
        self._oprot.writeMessageBegin('GetWorkitemFloatData', TMessageType.CALL, self._seqid)
        args = GetWorkitemFloatData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemFloatData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemFloatData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemFloatData failed: unknown result")

    def GetWorkitemStringData(self, node_id, workitem_id, data_name, length):
        """
        Parameters:
         - node_id
         - workitem_id
         - data_name
         - length

        """
        self.send_GetWorkitemStringData(node_id, workitem_id, data_name, length)
        return self.recv_GetWorkitemStringData()

    def send_GetWorkitemStringData(self, node_id, workitem_id, data_name, length):
        self._oprot.writeMessageBegin('GetWorkitemStringData', TMessageType.CALL, self._seqid)
        args = GetWorkitemStringData_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.data_name = data_name
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemStringData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemStringData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemStringData failed: unknown result")

    def GetWorkitemResultInfo(self, node_id, workitem_id, resultinfo_count):
        """
        Parameters:
         - node_id
         - workitem_id
         - resultinfo_count

        """
        self.send_GetWorkitemResultInfo(node_id, workitem_id, resultinfo_count)
        return self.recv_GetWorkitemResultInfo()

    def send_GetWorkitemResultInfo(self, node_id, workitem_id, resultinfo_count):
        self._oprot.writeMessageBegin('GetWorkitemResultInfo', TMessageType.CALL, self._seqid)
        args = GetWorkitemResultInfo_args()
        args.node_id = node_id
        args.workitem_id = workitem_id
        args.resultinfo_count = resultinfo_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetWorkitemResultInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetWorkitemResultInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkitemResultInfo failed: unknown result")

    def DirtyPDGNode(self, node_id, clean_results):
        """
        Parameters:
         - node_id
         - clean_results

        """
        self.send_DirtyPDGNode(node_id, clean_results)
        return self.recv_DirtyPDGNode()

    def send_DirtyPDGNode(self, node_id, clean_results):
        self._oprot.writeMessageBegin('DirtyPDGNode', TMessageType.CALL, self._seqid)
        args = DirtyPDGNode_args()
        args.node_id = node_id
        args.clean_results = clean_results
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DirtyPDGNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DirtyPDGNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DirtyPDGNode failed: unknown result")

    def PausePDGCook(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        self.send_PausePDGCook(graph_context_id)
        return self.recv_PausePDGCook()

    def send_PausePDGCook(self, graph_context_id):
        self._oprot.writeMessageBegin('PausePDGCook', TMessageType.CALL, self._seqid)
        args = PausePDGCook_args()
        args.graph_context_id = graph_context_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_PausePDGCook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = PausePDGCook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "PausePDGCook failed: unknown result")

    def CancelPDGCook(self, graph_context_id):
        """
        Parameters:
         - graph_context_id

        """
        self.send_CancelPDGCook(graph_context_id)
        return self.recv_CancelPDGCook()

    def send_CancelPDGCook(self, graph_context_id):
        self._oprot.writeMessageBegin('CancelPDGCook', TMessageType.CALL, self._seqid)
        args = CancelPDGCook_args()
        args.graph_context_id = graph_context_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CancelPDGCook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CancelPDGCook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CancelPDGCook failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["IsInitialized"] = Processor.process_IsInitialized
        self._processMap["Initialize"] = Processor.process_Initialize
        self._processMap["Cleanup"] = Processor.process_Cleanup
        self._processMap["GetSessionEnvInt"] = Processor.process_GetSessionEnvInt
        self._processMap["GetServerEnvInt"] = Processor.process_GetServerEnvInt
        self._processMap["GetServerEnvString"] = Processor.process_GetServerEnvString
        self._processMap["GetServerEnvVarCount"] = Processor.process_GetServerEnvVarCount
        self._processMap["GetServerEnvVarList"] = Processor.process_GetServerEnvVarList
        self._processMap["SetServerEnvInt"] = Processor.process_SetServerEnvInt
        self._processMap["SetServerEnvString"] = Processor.process_SetServerEnvString
        self._processMap["GetStatus"] = Processor.process_GetStatus
        self._processMap["GetStatusStringBufLength"] = Processor.process_GetStatusStringBufLength
        self._processMap["GetStatusString"] = Processor.process_GetStatusString
        self._processMap["ComposeNodeCookResult"] = Processor.process_ComposeNodeCookResult
        self._processMap["GetComposedNodeCookResult"] = Processor.process_GetComposedNodeCookResult
        self._processMap["CheckForSpecificErrors"] = Processor.process_CheckForSpecificErrors
        self._processMap["GetCookingTotalCount"] = Processor.process_GetCookingTotalCount
        self._processMap["GetCookingCurrentCount"] = Processor.process_GetCookingCurrentCount
        self._processMap["ConvertTransform"] = Processor.process_ConvertTransform
        self._processMap["ConvertMatrixToQuat"] = Processor.process_ConvertMatrixToQuat
        self._processMap["ConvertMatrixToEuler"] = Processor.process_ConvertMatrixToEuler
        self._processMap["ConvertTransformQuatToMatrix"] = Processor.process_ConvertTransformQuatToMatrix
        self._processMap["ConvertTransformEulerToMatrix"] = Processor.process_ConvertTransformEulerToMatrix
        self._processMap["PythonThreadInterpreterLock"] = Processor.process_PythonThreadInterpreterLock
        self._processMap["GetStringBufLength"] = Processor.process_GetStringBufLength
        self._processMap["GetString"] = Processor.process_GetString
        self._processMap["SetCustomString"] = Processor.process_SetCustomString
        self._processMap["RemoveCustomString"] = Processor.process_RemoveCustomString
        self._processMap["GetStringBatchSize"] = Processor.process_GetStringBatchSize
        self._processMap["GetStringBatch"] = Processor.process_GetStringBatch
        self._processMap["GetTime"] = Processor.process_GetTime
        self._processMap["SetTime"] = Processor.process_SetTime
        self._processMap["GetUseHoudiniTime"] = Processor.process_GetUseHoudiniTime
        self._processMap["SetUseHoudiniTime"] = Processor.process_SetUseHoudiniTime
        self._processMap["GetTimelineOptions"] = Processor.process_GetTimelineOptions
        self._processMap["SetTimelineOptions"] = Processor.process_SetTimelineOptions
        self._processMap["LoadAssetLibraryFromFile"] = Processor.process_LoadAssetLibraryFromFile
        self._processMap["LoadAssetLibraryFromMemory"] = Processor.process_LoadAssetLibraryFromMemory
        self._processMap["GetAvailableAssetCount"] = Processor.process_GetAvailableAssetCount
        self._processMap["GetAvailableAssets"] = Processor.process_GetAvailableAssets
        self._processMap["GetAssetInfo"] = Processor.process_GetAssetInfo
        self._processMap["GetAssetDefinitionParmCounts"] = Processor.process_GetAssetDefinitionParmCounts
        self._processMap["GetAssetDefinitionParmInfos"] = Processor.process_GetAssetDefinitionParmInfos
        self._processMap["GetAssetDefinitionParmValues"] = Processor.process_GetAssetDefinitionParmValues
        self._processMap["Interrupt"] = Processor.process_Interrupt
        self._processMap["LoadHIPFile"] = Processor.process_LoadHIPFile
        self._processMap["SaveHIPFile"] = Processor.process_SaveHIPFile
        self._processMap["IsNodeValid"] = Processor.process_IsNodeValid
        self._processMap["GetNodeInfo"] = Processor.process_GetNodeInfo
        self._processMap["GetNodePath"] = Processor.process_GetNodePath
        self._processMap["GetManagerNodeId"] = Processor.process_GetManagerNodeId
        self._processMap["ComposeChildNodeList"] = Processor.process_ComposeChildNodeList
        self._processMap["GetComposedChildNodeList"] = Processor.process_GetComposedChildNodeList
        self._processMap["CreateNode"] = Processor.process_CreateNode
        self._processMap["CreateInputNode"] = Processor.process_CreateInputNode
        self._processMap["CreateHeightfieldInputNode"] = Processor.process_CreateHeightfieldInputNode
        self._processMap["CreateHeightFieldInput"] = Processor.process_CreateHeightFieldInput
        self._processMap["CreateHeightfieldInputVolumeNode"] = Processor.process_CreateHeightfieldInputVolumeNode
        self._processMap["CookNode"] = Processor.process_CookNode
        self._processMap["DeleteNode"] = Processor.process_DeleteNode
        self._processMap["RenameNode"] = Processor.process_RenameNode
        self._processMap["ConnectNodeInput"] = Processor.process_ConnectNodeInput
        self._processMap["DisconnectNodeInput"] = Processor.process_DisconnectNodeInput
        self._processMap["QueryNodeInput"] = Processor.process_QueryNodeInput
        self._processMap["GetNodeInputName"] = Processor.process_GetNodeInputName
        self._processMap["DisconnectNodeOutputsAt"] = Processor.process_DisconnectNodeOutputsAt
        self._processMap["QueryNodeOutputConnectedCount"] = Processor.process_QueryNodeOutputConnectedCount
        self._processMap["QueryNodeOutputConnectedNodes"] = Processor.process_QueryNodeOutputConnectedNodes
        self._processMap["GetNodeOutputName"] = Processor.process_GetNodeOutputName
        self._processMap["GetParameters"] = Processor.process_GetParameters
        self._processMap["GetParmInfo"] = Processor.process_GetParmInfo
        self._processMap["GetParmIdFromName"] = Processor.process_GetParmIdFromName
        self._processMap["GetParmInfoFromName"] = Processor.process_GetParmInfoFromName
        self._processMap["GetParmTagName"] = Processor.process_GetParmTagName
        self._processMap["GetParmTagValue"] = Processor.process_GetParmTagValue
        self._processMap["ParmHasTag"] = Processor.process_ParmHasTag
        self._processMap["ParmHasExpression"] = Processor.process_ParmHasExpression
        self._processMap["GetParmWithTag"] = Processor.process_GetParmWithTag
        self._processMap["GetParmExpression"] = Processor.process_GetParmExpression
        self._processMap["RevertParmToDefault"] = Processor.process_RevertParmToDefault
        self._processMap["RevertParmToDefaults"] = Processor.process_RevertParmToDefaults
        self._processMap["SetParmExpression"] = Processor.process_SetParmExpression
        self._processMap["RemoveParmExpression"] = Processor.process_RemoveParmExpression
        self._processMap["GetParmIntValue"] = Processor.process_GetParmIntValue
        self._processMap["GetParmIntValues"] = Processor.process_GetParmIntValues
        self._processMap["GetParmFloatValue"] = Processor.process_GetParmFloatValue
        self._processMap["GetParmFloatValues"] = Processor.process_GetParmFloatValues
        self._processMap["GetParmStringValue"] = Processor.process_GetParmStringValue
        self._processMap["GetParmStringValues"] = Processor.process_GetParmStringValues
        self._processMap["GetParmNodeValue"] = Processor.process_GetParmNodeValue
        self._processMap["GetParmFile"] = Processor.process_GetParmFile
        self._processMap["GetParmChoiceLists"] = Processor.process_GetParmChoiceLists
        self._processMap["SetParmIntValue"] = Processor.process_SetParmIntValue
        self._processMap["SetParmIntValues"] = Processor.process_SetParmIntValues
        self._processMap["SetParmFloatValue"] = Processor.process_SetParmFloatValue
        self._processMap["SetParmFloatValues"] = Processor.process_SetParmFloatValues
        self._processMap["SetParmStringValue"] = Processor.process_SetParmStringValue
        self._processMap["SetParmNodeValue"] = Processor.process_SetParmNodeValue
        self._processMap["InsertMultiparmInstance"] = Processor.process_InsertMultiparmInstance
        self._processMap["RemoveMultiparmInstance"] = Processor.process_RemoveMultiparmInstance
        self._processMap["GetHandleInfo"] = Processor.process_GetHandleInfo
        self._processMap["GetHandleBindingInfo"] = Processor.process_GetHandleBindingInfo
        self._processMap["GetPresetBufLength"] = Processor.process_GetPresetBufLength
        self._processMap["GetPreset"] = Processor.process_GetPreset
        self._processMap["SetPreset"] = Processor.process_SetPreset
        self._processMap["GetObjectInfo"] = Processor.process_GetObjectInfo
        self._processMap["GetObjectTransform"] = Processor.process_GetObjectTransform
        self._processMap["ComposeObjectList"] = Processor.process_ComposeObjectList
        self._processMap["GetComposedObjectList"] = Processor.process_GetComposedObjectList
        self._processMap["GetComposedObjectTransforms"] = Processor.process_GetComposedObjectTransforms
        self._processMap["GetInstancedObjectIds"] = Processor.process_GetInstancedObjectIds
        self._processMap["GetInstanceTransforms"] = Processor.process_GetInstanceTransforms
        self._processMap["GetInstanceTransformsOnPart"] = Processor.process_GetInstanceTransformsOnPart
        self._processMap["SetObjectTransform"] = Processor.process_SetObjectTransform
        self._processMap["GetDisplayGeoInfo"] = Processor.process_GetDisplayGeoInfo
        self._processMap["GetGeoInfo"] = Processor.process_GetGeoInfo
        self._processMap["GetPartInfo"] = Processor.process_GetPartInfo
        self._processMap["GetFaceCounts"] = Processor.process_GetFaceCounts
        self._processMap["GetVertexList"] = Processor.process_GetVertexList
        self._processMap["GetAttributeInfo"] = Processor.process_GetAttributeInfo
        self._processMap["GetAttributeNames"] = Processor.process_GetAttributeNames
        self._processMap["GetAttributeIntData"] = Processor.process_GetAttributeIntData
        self._processMap["GetAttributeInt64Data"] = Processor.process_GetAttributeInt64Data
        self._processMap["GetAttributeFloatData"] = Processor.process_GetAttributeFloatData
        self._processMap["GetAttributeFloat64Data"] = Processor.process_GetAttributeFloat64Data
        self._processMap["GetAttributeStringData"] = Processor.process_GetAttributeStringData
        self._processMap["GetGroupNames"] = Processor.process_GetGroupNames
        self._processMap["GetGroupMembership"] = Processor.process_GetGroupMembership
        self._processMap["GetGroupCountOnPackedInstancePart"] = Processor.process_GetGroupCountOnPackedInstancePart
        self._processMap["GetGroupNamesOnPackedInstancePart"] = Processor.process_GetGroupNamesOnPackedInstancePart
        self._processMap["GetGroupMembershipOnPackedInstancePart"] = Processor.process_GetGroupMembershipOnPackedInstancePart
        self._processMap["GetInstancedPartIds"] = Processor.process_GetInstancedPartIds
        self._processMap["GetInstancerPartTransforms"] = Processor.process_GetInstancerPartTransforms
        self._processMap["SetPartInfo"] = Processor.process_SetPartInfo
        self._processMap["SetFaceCounts"] = Processor.process_SetFaceCounts
        self._processMap["SetVertexList"] = Processor.process_SetVertexList
        self._processMap["AddAttribute"] = Processor.process_AddAttribute
        self._processMap["DeleteAttribute"] = Processor.process_DeleteAttribute
        self._processMap["SetAttributeIntData"] = Processor.process_SetAttributeIntData
        self._processMap["SetAttributeInt64Data"] = Processor.process_SetAttributeInt64Data
        self._processMap["SetAttributeFloatData"] = Processor.process_SetAttributeFloatData
        self._processMap["SetAttributeFloat64Data"] = Processor.process_SetAttributeFloat64Data
        self._processMap["SetAttributeStringData"] = Processor.process_SetAttributeStringData
        self._processMap["AddGroup"] = Processor.process_AddGroup
        self._processMap["DeleteGroup"] = Processor.process_DeleteGroup
        self._processMap["SetGroupMembership"] = Processor.process_SetGroupMembership
        self._processMap["CommitGeo"] = Processor.process_CommitGeo
        self._processMap["RevertGeo"] = Processor.process_RevertGeo
        self._processMap["GetMaterialNodeIdsOnFaces"] = Processor.process_GetMaterialNodeIdsOnFaces
        self._processMap["GetMaterialInfo"] = Processor.process_GetMaterialInfo
        self._processMap["RenderCOPToImage"] = Processor.process_RenderCOPToImage
        self._processMap["RenderTextureToImage"] = Processor.process_RenderTextureToImage
        self._processMap["GetImageInfo"] = Processor.process_GetImageInfo
        self._processMap["SetImageInfo"] = Processor.process_SetImageInfo
        self._processMap["GetImagePlaneCount"] = Processor.process_GetImagePlaneCount
        self._processMap["GetImagePlanes"] = Processor.process_GetImagePlanes
        self._processMap["ExtractImageToFile"] = Processor.process_ExtractImageToFile
        self._processMap["GetImageFilePath"] = Processor.process_GetImageFilePath
        self._processMap["ExtractImageToMemory"] = Processor.process_ExtractImageToMemory
        self._processMap["GetImageMemoryBuffer"] = Processor.process_GetImageMemoryBuffer
        self._processMap["GetSupportedImageFileFormatCount"] = Processor.process_GetSupportedImageFileFormatCount
        self._processMap["GetSupportedImageFileFormats"] = Processor.process_GetSupportedImageFileFormats
        self._processMap["SetAnimCurve"] = Processor.process_SetAnimCurve
        self._processMap["SetTransformAnimCurve"] = Processor.process_SetTransformAnimCurve
        self._processMap["ResetSimulation"] = Processor.process_ResetSimulation
        self._processMap["GetVolumeInfo"] = Processor.process_GetVolumeInfo
        self._processMap["GetFirstVolumeTile"] = Processor.process_GetFirstVolumeTile
        self._processMap["GetNextVolumeTile"] = Processor.process_GetNextVolumeTile
        self._processMap["GetVolumeVoxelFloatData"] = Processor.process_GetVolumeVoxelFloatData
        self._processMap["GetVolumeTileFloatData"] = Processor.process_GetVolumeTileFloatData
        self._processMap["GetVolumeVoxelIntData"] = Processor.process_GetVolumeVoxelIntData
        self._processMap["GetVolumeTileIntData"] = Processor.process_GetVolumeTileIntData
        self._processMap["GetHeightFieldData"] = Processor.process_GetHeightFieldData
        self._processMap["SetVolumeInfo"] = Processor.process_SetVolumeInfo
        self._processMap["SetVolumeTileFloatData"] = Processor.process_SetVolumeTileFloatData
        self._processMap["SetVolumeTileIntData"] = Processor.process_SetVolumeTileIntData
        self._processMap["SetVolumeVoxelFloatData"] = Processor.process_SetVolumeVoxelFloatData
        self._processMap["SetVolumeVoxelIntData"] = Processor.process_SetVolumeVoxelIntData
        self._processMap["GetVolumeBounds"] = Processor.process_GetVolumeBounds
        self._processMap["SetHeightFieldData"] = Processor.process_SetHeightFieldData
        self._processMap["GetCurveInfo"] = Processor.process_GetCurveInfo
        self._processMap["GetCurveCounts"] = Processor.process_GetCurveCounts
        self._processMap["GetCurveOrders"] = Processor.process_GetCurveOrders
        self._processMap["GetCurveKnots"] = Processor.process_GetCurveKnots
        self._processMap["SetCurveInfo"] = Processor.process_SetCurveInfo
        self._processMap["SetCurveCounts"] = Processor.process_SetCurveCounts
        self._processMap["SetCurveOrders"] = Processor.process_SetCurveOrders
        self._processMap["SetCurveKnots"] = Processor.process_SetCurveKnots
        self._processMap["GetBoxInfo"] = Processor.process_GetBoxInfo
        self._processMap["GetSphereInfo"] = Processor.process_GetSphereInfo
        self._processMap["GetActiveCacheCount"] = Processor.process_GetActiveCacheCount
        self._processMap["GetActiveCacheNames"] = Processor.process_GetActiveCacheNames
        self._processMap["GetCacheProperty"] = Processor.process_GetCacheProperty
        self._processMap["SetCacheProperty"] = Processor.process_SetCacheProperty
        self._processMap["SaveGeoToFile"] = Processor.process_SaveGeoToFile
        self._processMap["LoadGeoFromFile"] = Processor.process_LoadGeoFromFile
        self._processMap["SaveNodeToFile"] = Processor.process_SaveNodeToFile
        self._processMap["LoadNodeFromFile"] = Processor.process_LoadNodeFromFile
        self._processMap["GetGeoSize"] = Processor.process_GetGeoSize
        self._processMap["SaveGeoToMemory"] = Processor.process_SaveGeoToMemory
        self._processMap["LoadGeoFromMemory"] = Processor.process_LoadGeoFromMemory
        self._processMap["SetNodeDisplay"] = Processor.process_SetNodeDisplay
        self._processMap["GetTotalCookCount"] = Processor.process_GetTotalCookCount
        self._processMap["SetSessionSync"] = Processor.process_SetSessionSync
        self._processMap["GetViewport"] = Processor.process_GetViewport
        self._processMap["SetViewport"] = Processor.process_SetViewport
        self._processMap["GetSessionSyncInfo"] = Processor.process_GetSessionSyncInfo
        self._processMap["SetSessionSyncInfo"] = Processor.process_SetSessionSyncInfo
        self._processMap["GetPDGGraphContexts"] = Processor.process_GetPDGGraphContexts
        self._processMap["GetPDGGraphContextId"] = Processor.process_GetPDGGraphContextId
        self._processMap["CookPDG"] = Processor.process_CookPDG
        self._processMap["GetPDGEvents"] = Processor.process_GetPDGEvents
        self._processMap["GetPDGState"] = Processor.process_GetPDGState
        self._processMap["CreateWorkitem"] = Processor.process_CreateWorkitem
        self._processMap["GetWorkitemInfo"] = Processor.process_GetWorkitemInfo
        self._processMap["SetWorkitemIntData"] = Processor.process_SetWorkitemIntData
        self._processMap["SetWorkitemFloatData"] = Processor.process_SetWorkitemFloatData
        self._processMap["SetWorkitemStringData"] = Processor.process_SetWorkitemStringData
        self._processMap["CommitWorkitems"] = Processor.process_CommitWorkitems
        self._processMap["GetNumWorkitems"] = Processor.process_GetNumWorkitems
        self._processMap["GetWorkitems"] = Processor.process_GetWorkitems
        self._processMap["GetWorkitemDataLength"] = Processor.process_GetWorkitemDataLength
        self._processMap["GetWorkitemIntData"] = Processor.process_GetWorkitemIntData
        self._processMap["GetWorkitemFloatData"] = Processor.process_GetWorkitemFloatData
        self._processMap["GetWorkitemStringData"] = Processor.process_GetWorkitemStringData
        self._processMap["GetWorkitemResultInfo"] = Processor.process_GetWorkitemResultInfo
        self._processMap["DirtyPDGNode"] = Processor.process_DirtyPDGNode
        self._processMap["PausePDGCook"] = Processor.process_PausePDGCook
        self._processMap["CancelPDGCook"] = Processor.process_CancelPDGCook
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_IsInitialized(self, seqid, iprot, oprot):
        args = IsInitialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = IsInitialized_result()
        try:
            result.success = self._handler.IsInitialized()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("IsInitialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Initialize(self, seqid, iprot, oprot):
        args = Initialize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Initialize_result()
        try:
            result.success = self._handler.Initialize(args.cook_options, args.use_cooking_thread, args.cooking_thread_stack_size, args.houdini_environment_files, args.otl_search_path, args.dso_search_path, args.image_dso_search_path, args.audio_dso_search_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Initialize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Cleanup(self, seqid, iprot, oprot):
        args = Cleanup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Cleanup_result()
        try:
            result.success = self._handler.Cleanup()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Cleanup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSessionEnvInt(self, seqid, iprot, oprot):
        args = GetSessionEnvInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSessionEnvInt_result()
        try:
            result.success = self._handler.GetSessionEnvInt(args.int_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSessionEnvInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetServerEnvInt(self, seqid, iprot, oprot):
        args = GetServerEnvInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetServerEnvInt_result()
        try:
            result.success = self._handler.GetServerEnvInt(args.variable_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetServerEnvInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetServerEnvString(self, seqid, iprot, oprot):
        args = GetServerEnvString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetServerEnvString_result()
        try:
            result.success = self._handler.GetServerEnvString(args.variable_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetServerEnvString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetServerEnvVarCount(self, seqid, iprot, oprot):
        args = GetServerEnvVarCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetServerEnvVarCount_result()
        try:
            result.success = self._handler.GetServerEnvVarCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetServerEnvVarCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetServerEnvVarList(self, seqid, iprot, oprot):
        args = GetServerEnvVarList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetServerEnvVarList_result()
        try:
            result.success = self._handler.GetServerEnvVarList(args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetServerEnvVarList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetServerEnvInt(self, seqid, iprot, oprot):
        args = SetServerEnvInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetServerEnvInt_result()
        try:
            result.success = self._handler.SetServerEnvInt(args.variable_name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetServerEnvInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetServerEnvString(self, seqid, iprot, oprot):
        args = SetServerEnvString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetServerEnvString_result()
        try:
            result.success = self._handler.SetServerEnvString(args.variable_name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetServerEnvString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStatus(self, seqid, iprot, oprot):
        args = GetStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStatus_result()
        try:
            result.success = self._handler.GetStatus(args.status_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStatusStringBufLength(self, seqid, iprot, oprot):
        args = GetStatusStringBufLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStatusStringBufLength_result()
        try:
            result.success = self._handler.GetStatusStringBufLength(args.status_type, args.verbosity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStatusStringBufLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStatusString(self, seqid, iprot, oprot):
        args = GetStatusString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStatusString_result()
        try:
            result.success = self._handler.GetStatusString(args.status_type, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStatusString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ComposeNodeCookResult(self, seqid, iprot, oprot):
        args = ComposeNodeCookResult_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ComposeNodeCookResult_result()
        try:
            result.success = self._handler.ComposeNodeCookResult(args.node_id, args.verbosity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ComposeNodeCookResult", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetComposedNodeCookResult(self, seqid, iprot, oprot):
        args = GetComposedNodeCookResult_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetComposedNodeCookResult_result()
        try:
            result.success = self._handler.GetComposedNodeCookResult(args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetComposedNodeCookResult", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CheckForSpecificErrors(self, seqid, iprot, oprot):
        args = CheckForSpecificErrors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CheckForSpecificErrors_result()
        try:
            result.success = self._handler.CheckForSpecificErrors(args.node_id, args.errors_to_look_for)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CheckForSpecificErrors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCookingTotalCount(self, seqid, iprot, oprot):
        args = GetCookingTotalCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCookingTotalCount_result()
        try:
            result.success = self._handler.GetCookingTotalCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCookingTotalCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCookingCurrentCount(self, seqid, iprot, oprot):
        args = GetCookingCurrentCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCookingCurrentCount_result()
        try:
            result.success = self._handler.GetCookingCurrentCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCookingCurrentCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConvertTransform(self, seqid, iprot, oprot):
        args = ConvertTransform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConvertTransform_result()
        try:
            result.success = self._handler.ConvertTransform(args.transform_in, args.rst_order, args.rot_order)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConvertTransform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConvertMatrixToQuat(self, seqid, iprot, oprot):
        args = ConvertMatrixToQuat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConvertMatrixToQuat_result()
        try:
            result.success = self._handler.ConvertMatrixToQuat(args.matrix, args.rst_order)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConvertMatrixToQuat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConvertMatrixToEuler(self, seqid, iprot, oprot):
        args = ConvertMatrixToEuler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConvertMatrixToEuler_result()
        try:
            result.success = self._handler.ConvertMatrixToEuler(args.matrix, args.rst_order, args.rot_order)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConvertMatrixToEuler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConvertTransformQuatToMatrix(self, seqid, iprot, oprot):
        args = ConvertTransformQuatToMatrix_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConvertTransformQuatToMatrix_result()
        try:
            result.success = self._handler.ConvertTransformQuatToMatrix(args.transform)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConvertTransformQuatToMatrix", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConvertTransformEulerToMatrix(self, seqid, iprot, oprot):
        args = ConvertTransformEulerToMatrix_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConvertTransformEulerToMatrix_result()
        try:
            result.success = self._handler.ConvertTransformEulerToMatrix(args.transform)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConvertTransformEulerToMatrix", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_PythonThreadInterpreterLock(self, seqid, iprot, oprot):
        args = PythonThreadInterpreterLock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = PythonThreadInterpreterLock_result()
        try:
            result.success = self._handler.PythonThreadInterpreterLock(args.locked)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("PythonThreadInterpreterLock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStringBufLength(self, seqid, iprot, oprot):
        args = GetStringBufLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStringBufLength_result()
        try:
            result.success = self._handler.GetStringBufLength(args.string_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStringBufLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetString(self, seqid, iprot, oprot):
        args = GetString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetString_result()
        try:
            result.success = self._handler.GetString(args.string_handle, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCustomString(self, seqid, iprot, oprot):
        args = SetCustomString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCustomString_result()
        try:
            result.success = self._handler.SetCustomString(args.string_value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCustomString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RemoveCustomString(self, seqid, iprot, oprot):
        args = RemoveCustomString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RemoveCustomString_result()
        try:
            result.success = self._handler.RemoveCustomString(args.string_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RemoveCustomString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStringBatchSize(self, seqid, iprot, oprot):
        args = GetStringBatchSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStringBatchSize_result()
        try:
            result.success = self._handler.GetStringBatchSize(args.string_handle_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStringBatchSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStringBatch(self, seqid, iprot, oprot):
        args = GetStringBatch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStringBatch_result()
        try:
            result.success = self._handler.GetStringBatch(args.char_array_length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStringBatch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetTime(self, seqid, iprot, oprot):
        args = GetTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetTime_result()
        try:
            result.success = self._handler.GetTime()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetTime(self, seqid, iprot, oprot):
        args = SetTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetTime_result()
        try:
            result.success = self._handler.SetTime(args.time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetUseHoudiniTime(self, seqid, iprot, oprot):
        args = GetUseHoudiniTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetUseHoudiniTime_result()
        try:
            result.success = self._handler.GetUseHoudiniTime()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetUseHoudiniTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetUseHoudiniTime(self, seqid, iprot, oprot):
        args = SetUseHoudiniTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetUseHoudiniTime_result()
        try:
            result.success = self._handler.SetUseHoudiniTime(args.enabled)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetUseHoudiniTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetTimelineOptions(self, seqid, iprot, oprot):
        args = GetTimelineOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetTimelineOptions_result()
        try:
            result.success = self._handler.GetTimelineOptions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetTimelineOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetTimelineOptions(self, seqid, iprot, oprot):
        args = SetTimelineOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetTimelineOptions_result()
        try:
            result.success = self._handler.SetTimelineOptions(args.timeline_options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetTimelineOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadAssetLibraryFromFile(self, seqid, iprot, oprot):
        args = LoadAssetLibraryFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadAssetLibraryFromFile_result()
        try:
            result.success = self._handler.LoadAssetLibraryFromFile(args.file_path, args.allow_overwrite)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadAssetLibraryFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadAssetLibraryFromMemory(self, seqid, iprot, oprot):
        args = LoadAssetLibraryFromMemory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadAssetLibraryFromMemory_result()
        try:
            result.success = self._handler.LoadAssetLibraryFromMemory(args.library_buffer, args.library_buffer_length, args.allow_overwrite)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadAssetLibraryFromMemory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAvailableAssetCount(self, seqid, iprot, oprot):
        args = GetAvailableAssetCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAvailableAssetCount_result()
        try:
            result.success = self._handler.GetAvailableAssetCount(args.library_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAvailableAssetCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAvailableAssets(self, seqid, iprot, oprot):
        args = GetAvailableAssets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAvailableAssets_result()
        try:
            result.success = self._handler.GetAvailableAssets(args.library_id, args.asset_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAvailableAssets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAssetInfo(self, seqid, iprot, oprot):
        args = GetAssetInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAssetInfo_result()
        try:
            result.success = self._handler.GetAssetInfo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAssetInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAssetDefinitionParmCounts(self, seqid, iprot, oprot):
        args = GetAssetDefinitionParmCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAssetDefinitionParmCounts_result()
        try:
            result.success = self._handler.GetAssetDefinitionParmCounts(args.library_id, args.asset_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAssetDefinitionParmCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAssetDefinitionParmInfos(self, seqid, iprot, oprot):
        args = GetAssetDefinitionParmInfos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAssetDefinitionParmInfos_result()
        try:
            result.success = self._handler.GetAssetDefinitionParmInfos(args.library_id, args.asset_name, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAssetDefinitionParmInfos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAssetDefinitionParmValues(self, seqid, iprot, oprot):
        args = GetAssetDefinitionParmValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAssetDefinitionParmValues_result()
        try:
            result.success = self._handler.GetAssetDefinitionParmValues(args.library_id, args.asset_name, args.int_start, args.int_length, args.float_start, args.float_length, args.string_evaluate, args.string_start, args.string_length, args.choice_start, args.choice_length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAssetDefinitionParmValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Interrupt(self, seqid, iprot, oprot):
        args = Interrupt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Interrupt_result()
        try:
            result.success = self._handler.Interrupt()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Interrupt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadHIPFile(self, seqid, iprot, oprot):
        args = LoadHIPFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadHIPFile_result()
        try:
            result.success = self._handler.LoadHIPFile(args.file_name, args.cook_on_load)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadHIPFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SaveHIPFile(self, seqid, iprot, oprot):
        args = SaveHIPFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SaveHIPFile_result()
        try:
            result.success = self._handler.SaveHIPFile(args.file_path, args.lock_nodes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SaveHIPFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_IsNodeValid(self, seqid, iprot, oprot):
        args = IsNodeValid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = IsNodeValid_result()
        try:
            result.success = self._handler.IsNodeValid(args.node_id, args.unique_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("IsNodeValid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNodeInfo(self, seqid, iprot, oprot):
        args = GetNodeInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNodeInfo_result()
        try:
            result.success = self._handler.GetNodeInfo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNodeInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNodePath(self, seqid, iprot, oprot):
        args = GetNodePath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNodePath_result()
        try:
            result.success = self._handler.GetNodePath(args.node_id, args.relative_to_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNodePath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetManagerNodeId(self, seqid, iprot, oprot):
        args = GetManagerNodeId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetManagerNodeId_result()
        try:
            result.success = self._handler.GetManagerNodeId(args.node_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetManagerNodeId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ComposeChildNodeList(self, seqid, iprot, oprot):
        args = ComposeChildNodeList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ComposeChildNodeList_result()
        try:
            result.success = self._handler.ComposeChildNodeList(args.parent_node_id, args.node_type_filter, args.node_flags_filter, args.recursive)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ComposeChildNodeList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetComposedChildNodeList(self, seqid, iprot, oprot):
        args = GetComposedChildNodeList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetComposedChildNodeList_result()
        try:
            result.success = self._handler.GetComposedChildNodeList(args.parent_node_id, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetComposedChildNodeList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateNode(self, seqid, iprot, oprot):
        args = CreateNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateNode_result()
        try:
            result.success = self._handler.CreateNode(args.parent_node_id, args.operator_name, args.node_label, args.cook_on_creation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateInputNode(self, seqid, iprot, oprot):
        args = CreateInputNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateInputNode_result()
        try:
            result.success = self._handler.CreateInputNode(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateInputNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateHeightfieldInputNode(self, seqid, iprot, oprot):
        args = CreateHeightfieldInputNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateHeightfieldInputNode_result()
        try:
            result.success = self._handler.CreateHeightfieldInputNode(args.parent_node_id, args.name, args.xsize, args.ysize, args.voxelsize)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateHeightfieldInputNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateHeightFieldInput(self, seqid, iprot, oprot):
        args = CreateHeightFieldInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateHeightFieldInput_result()
        try:
            result.success = self._handler.CreateHeightFieldInput(args.parent_node_id, args.name, args.xsize, args.ysize, args.voxelsize, args.sampling)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateHeightFieldInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateHeightfieldInputVolumeNode(self, seqid, iprot, oprot):
        args = CreateHeightfieldInputVolumeNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateHeightfieldInputVolumeNode_result()
        try:
            result.success = self._handler.CreateHeightfieldInputVolumeNode(args.parent_node_id, args.name, args.xsize, args.ysize, args.voxelsize)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateHeightfieldInputVolumeNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CookNode(self, seqid, iprot, oprot):
        args = CookNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CookNode_result()
        try:
            result.success = self._handler.CookNode(args.node_id, args.cook_options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CookNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteNode(self, seqid, iprot, oprot):
        args = DeleteNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteNode_result()
        try:
            result.success = self._handler.DeleteNode(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RenameNode(self, seqid, iprot, oprot):
        args = RenameNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RenameNode_result()
        try:
            result.success = self._handler.RenameNode(args.node_id, args.new_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RenameNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ConnectNodeInput(self, seqid, iprot, oprot):
        args = ConnectNodeInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ConnectNodeInput_result()
        try:
            result.success = self._handler.ConnectNodeInput(args.node_id, args.input_index, args.node_id_to_connect, args.output_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ConnectNodeInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DisconnectNodeInput(self, seqid, iprot, oprot):
        args = DisconnectNodeInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DisconnectNodeInput_result()
        try:
            result.success = self._handler.DisconnectNodeInput(args.node_id, args.input_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DisconnectNodeInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QueryNodeInput(self, seqid, iprot, oprot):
        args = QueryNodeInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QueryNodeInput_result()
        try:
            result.success = self._handler.QueryNodeInput(args.node_to_query, args.input_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QueryNodeInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNodeInputName(self, seqid, iprot, oprot):
        args = GetNodeInputName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNodeInputName_result()
        try:
            result.success = self._handler.GetNodeInputName(args.node_id, args.input_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNodeInputName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DisconnectNodeOutputsAt(self, seqid, iprot, oprot):
        args = DisconnectNodeOutputsAt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DisconnectNodeOutputsAt_result()
        try:
            result.success = self._handler.DisconnectNodeOutputsAt(args.node_id, args.output_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DisconnectNodeOutputsAt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QueryNodeOutputConnectedCount(self, seqid, iprot, oprot):
        args = QueryNodeOutputConnectedCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QueryNodeOutputConnectedCount_result()
        try:
            result.success = self._handler.QueryNodeOutputConnectedCount(args.node_id, args.output_idx, args.into_subnets, args.through_dots)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QueryNodeOutputConnectedCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_QueryNodeOutputConnectedNodes(self, seqid, iprot, oprot):
        args = QueryNodeOutputConnectedNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = QueryNodeOutputConnectedNodes_result()
        try:
            result.success = self._handler.QueryNodeOutputConnectedNodes(args.node_id, args.output_idx, args.into_subnets, args.through_dots, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("QueryNodeOutputConnectedNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNodeOutputName(self, seqid, iprot, oprot):
        args = GetNodeOutputName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNodeOutputName_result()
        try:
            result.success = self._handler.GetNodeOutputName(args.node_id, args.output_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNodeOutputName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParameters(self, seqid, iprot, oprot):
        args = GetParameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParameters_result()
        try:
            result.success = self._handler.GetParameters(args.node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmInfo(self, seqid, iprot, oprot):
        args = GetParmInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmInfo_result()
        try:
            result.success = self._handler.GetParmInfo(args.node_id, args.parm_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmIdFromName(self, seqid, iprot, oprot):
        args = GetParmIdFromName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmIdFromName_result()
        try:
            result.success = self._handler.GetParmIdFromName(args.node_id, args.parm_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmIdFromName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmInfoFromName(self, seqid, iprot, oprot):
        args = GetParmInfoFromName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmInfoFromName_result()
        try:
            result.success = self._handler.GetParmInfoFromName(args.node_id, args.parm_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmInfoFromName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmTagName(self, seqid, iprot, oprot):
        args = GetParmTagName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmTagName_result()
        try:
            result.success = self._handler.GetParmTagName(args.node_id, args.parm_id, args.tag_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmTagName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmTagValue(self, seqid, iprot, oprot):
        args = GetParmTagValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmTagValue_result()
        try:
            result.success = self._handler.GetParmTagValue(args.node_id, args.parm_id, args.tag_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmTagValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ParmHasTag(self, seqid, iprot, oprot):
        args = ParmHasTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ParmHasTag_result()
        try:
            result.success = self._handler.ParmHasTag(args.node_id, args.parm_id, args.tag_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ParmHasTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ParmHasExpression(self, seqid, iprot, oprot):
        args = ParmHasExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ParmHasExpression_result()
        try:
            result.success = self._handler.ParmHasExpression(args.node_id, args.parm_name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ParmHasExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmWithTag(self, seqid, iprot, oprot):
        args = GetParmWithTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmWithTag_result()
        try:
            result.success = self._handler.GetParmWithTag(args.node_id, args.tag_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmWithTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmExpression(self, seqid, iprot, oprot):
        args = GetParmExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmExpression_result()
        try:
            result.success = self._handler.GetParmExpression(args.node_id, args.parm_name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RevertParmToDefault(self, seqid, iprot, oprot):
        args = RevertParmToDefault_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RevertParmToDefault_result()
        try:
            result.success = self._handler.RevertParmToDefault(args.node_id, args.parm_name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RevertParmToDefault", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RevertParmToDefaults(self, seqid, iprot, oprot):
        args = RevertParmToDefaults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RevertParmToDefaults_result()
        try:
            result.success = self._handler.RevertParmToDefaults(args.node_id, args.parm_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RevertParmToDefaults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmExpression(self, seqid, iprot, oprot):
        args = SetParmExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmExpression_result()
        try:
            result.success = self._handler.SetParmExpression(args.node_id, args.value, args.parm_id, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RemoveParmExpression(self, seqid, iprot, oprot):
        args = RemoveParmExpression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RemoveParmExpression_result()
        try:
            result.success = self._handler.RemoveParmExpression(args.node_id, args.parm_id, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RemoveParmExpression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmIntValue(self, seqid, iprot, oprot):
        args = GetParmIntValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmIntValue_result()
        try:
            result.success = self._handler.GetParmIntValue(args.node_id, args.parm_name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmIntValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmIntValues(self, seqid, iprot, oprot):
        args = GetParmIntValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmIntValues_result()
        try:
            result.success = self._handler.GetParmIntValues(args.node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmIntValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmFloatValue(self, seqid, iprot, oprot):
        args = GetParmFloatValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmFloatValue_result()
        try:
            result.success = self._handler.GetParmFloatValue(args.node_id, args.parm_name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmFloatValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmFloatValues(self, seqid, iprot, oprot):
        args = GetParmFloatValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmFloatValues_result()
        try:
            result.success = self._handler.GetParmFloatValues(args.node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmFloatValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmStringValue(self, seqid, iprot, oprot):
        args = GetParmStringValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmStringValue_result()
        try:
            result.success = self._handler.GetParmStringValue(args.node_id, args.parm_name, args.index, args.evaluate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmStringValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmStringValues(self, seqid, iprot, oprot):
        args = GetParmStringValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmStringValues_result()
        try:
            result.success = self._handler.GetParmStringValues(args.node_id, args.evaluate, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmStringValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmNodeValue(self, seqid, iprot, oprot):
        args = GetParmNodeValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmNodeValue_result()
        try:
            result.success = self._handler.GetParmNodeValue(args.node_id, args.parm_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmNodeValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmFile(self, seqid, iprot, oprot):
        args = GetParmFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmFile_result()
        try:
            result.success = self._handler.GetParmFile(args.node_id, args.parm_name, args.destination_directory, args.destination_file_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetParmChoiceLists(self, seqid, iprot, oprot):
        args = GetParmChoiceLists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetParmChoiceLists_result()
        try:
            result.success = self._handler.GetParmChoiceLists(args.node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetParmChoiceLists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmIntValue(self, seqid, iprot, oprot):
        args = SetParmIntValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmIntValue_result()
        try:
            result.success = self._handler.SetParmIntValue(args.node_id, args.parm_name, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmIntValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmIntValues(self, seqid, iprot, oprot):
        args = SetParmIntValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmIntValues_result()
        try:
            result.success = self._handler.SetParmIntValues(args.node_id, args.values_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmIntValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmFloatValue(self, seqid, iprot, oprot):
        args = SetParmFloatValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmFloatValue_result()
        try:
            result.success = self._handler.SetParmFloatValue(args.node_id, args.parm_name, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmFloatValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmFloatValues(self, seqid, iprot, oprot):
        args = SetParmFloatValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmFloatValues_result()
        try:
            result.success = self._handler.SetParmFloatValues(args.node_id, args.values_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmFloatValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmStringValue(self, seqid, iprot, oprot):
        args = SetParmStringValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmStringValue_result()
        try:
            result.success = self._handler.SetParmStringValue(args.node_id, args.value, args.parm_id, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmStringValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetParmNodeValue(self, seqid, iprot, oprot):
        args = SetParmNodeValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetParmNodeValue_result()
        try:
            result.success = self._handler.SetParmNodeValue(args.node_id, args.parm_name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetParmNodeValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_InsertMultiparmInstance(self, seqid, iprot, oprot):
        args = InsertMultiparmInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = InsertMultiparmInstance_result()
        try:
            result.success = self._handler.InsertMultiparmInstance(args.node_id, args.parm_id, args.instance_position)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("InsertMultiparmInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RemoveMultiparmInstance(self, seqid, iprot, oprot):
        args = RemoveMultiparmInstance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RemoveMultiparmInstance_result()
        try:
            result.success = self._handler.RemoveMultiparmInstance(args.node_id, args.parm_id, args.instance_position)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RemoveMultiparmInstance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHandleInfo(self, seqid, iprot, oprot):
        args = GetHandleInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHandleInfo_result()
        try:
            result.success = self._handler.GetHandleInfo(args.node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHandleInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHandleBindingInfo(self, seqid, iprot, oprot):
        args = GetHandleBindingInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHandleBindingInfo_result()
        try:
            result.success = self._handler.GetHandleBindingInfo(args.node_id, args.handle_index, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHandleBindingInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPresetBufLength(self, seqid, iprot, oprot):
        args = GetPresetBufLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPresetBufLength_result()
        try:
            result.success = self._handler.GetPresetBufLength(args.node_id, args.preset_type, args.preset_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPresetBufLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPreset(self, seqid, iprot, oprot):
        args = GetPreset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPreset_result()
        try:
            result.success = self._handler.GetPreset(args.node_id, args.buffer_length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPreset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetPreset(self, seqid, iprot, oprot):
        args = SetPreset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetPreset_result()
        try:
            result.success = self._handler.SetPreset(args.node_id, args.preset_type, args.preset_name, args.buffer, args.buffer_length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetPreset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetObjectInfo(self, seqid, iprot, oprot):
        args = GetObjectInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetObjectInfo_result()
        try:
            result.success = self._handler.GetObjectInfo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetObjectInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetObjectTransform(self, seqid, iprot, oprot):
        args = GetObjectTransform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetObjectTransform_result()
        try:
            result.success = self._handler.GetObjectTransform(args.node_id, args.relative_to_node_id, args.rst_order)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetObjectTransform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ComposeObjectList(self, seqid, iprot, oprot):
        args = ComposeObjectList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ComposeObjectList_result()
        try:
            result.success = self._handler.ComposeObjectList(args.parent_node_id, args.categories)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ComposeObjectList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetComposedObjectList(self, seqid, iprot, oprot):
        args = GetComposedObjectList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetComposedObjectList_result()
        try:
            result.success = self._handler.GetComposedObjectList(args.parent_node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetComposedObjectList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetComposedObjectTransforms(self, seqid, iprot, oprot):
        args = GetComposedObjectTransforms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetComposedObjectTransforms_result()
        try:
            result.success = self._handler.GetComposedObjectTransforms(args.parent_node_id, args.rst_order, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetComposedObjectTransforms", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetInstancedObjectIds(self, seqid, iprot, oprot):
        args = GetInstancedObjectIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetInstancedObjectIds_result()
        try:
            result.success = self._handler.GetInstancedObjectIds(args.object_node_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetInstancedObjectIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetInstanceTransforms(self, seqid, iprot, oprot):
        args = GetInstanceTransforms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetInstanceTransforms_result()
        try:
            result.success = self._handler.GetInstanceTransforms(args.object_node_id, args.rst_order, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetInstanceTransforms", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetInstanceTransformsOnPart(self, seqid, iprot, oprot):
        args = GetInstanceTransformsOnPart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetInstanceTransformsOnPart_result()
        try:
            result.success = self._handler.GetInstanceTransformsOnPart(args.node_id, args.part_id, args.rst_order, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetInstanceTransformsOnPart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetObjectTransform(self, seqid, iprot, oprot):
        args = SetObjectTransform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetObjectTransform_result()
        try:
            result.success = self._handler.SetObjectTransform(args.node_id, args.trans)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetObjectTransform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetDisplayGeoInfo(self, seqid, iprot, oprot):
        args = GetDisplayGeoInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetDisplayGeoInfo_result()
        try:
            result.success = self._handler.GetDisplayGeoInfo(args.object_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetDisplayGeoInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGeoInfo(self, seqid, iprot, oprot):
        args = GetGeoInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGeoInfo_result()
        try:
            result.success = self._handler.GetGeoInfo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGeoInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPartInfo(self, seqid, iprot, oprot):
        args = GetPartInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPartInfo_result()
        try:
            result.success = self._handler.GetPartInfo(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPartInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetFaceCounts(self, seqid, iprot, oprot):
        args = GetFaceCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetFaceCounts_result()
        try:
            result.success = self._handler.GetFaceCounts(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetFaceCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVertexList(self, seqid, iprot, oprot):
        args = GetVertexList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVertexList_result()
        try:
            result.success = self._handler.GetVertexList(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVertexList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeInfo(self, seqid, iprot, oprot):
        args = GetAttributeInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeInfo_result()
        try:
            result.success = self._handler.GetAttributeInfo(args.node_id, args.part_id, args.name, args.owner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeNames(self, seqid, iprot, oprot):
        args = GetAttributeNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeNames_result()
        try:
            result.success = self._handler.GetAttributeNames(args.node_id, args.part_id, args.owner, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeIntData(self, seqid, iprot, oprot):
        args = GetAttributeIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeIntData_result()
        try:
            result.success = self._handler.GetAttributeIntData(args.node_id, args.part_id, args.name, args.attr_info, args.stride, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeInt64Data(self, seqid, iprot, oprot):
        args = GetAttributeInt64Data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeInt64Data_result()
        try:
            result.success = self._handler.GetAttributeInt64Data(args.node_id, args.part_id, args.name, args.attr_info, args.stride, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeInt64Data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeFloatData(self, seqid, iprot, oprot):
        args = GetAttributeFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeFloatData_result()
        try:
            result.success = self._handler.GetAttributeFloatData(args.node_id, args.part_id, args.name, args.attr_info, args.stride, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeFloat64Data(self, seqid, iprot, oprot):
        args = GetAttributeFloat64Data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeFloat64Data_result()
        try:
            result.success = self._handler.GetAttributeFloat64Data(args.node_id, args.part_id, args.name, args.attr_info, args.stride, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeFloat64Data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAttributeStringData(self, seqid, iprot, oprot):
        args = GetAttributeStringData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAttributeStringData_result()
        try:
            result.success = self._handler.GetAttributeStringData(args.node_id, args.part_id, args.name, args.attr_info, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAttributeStringData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGroupNames(self, seqid, iprot, oprot):
        args = GetGroupNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGroupNames_result()
        try:
            result.success = self._handler.GetGroupNames(args.node_id, args.group_type, args.group_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGroupNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGroupMembership(self, seqid, iprot, oprot):
        args = GetGroupMembership_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGroupMembership_result()
        try:
            result.success = self._handler.GetGroupMembership(args.node_id, args.part_id, args.group_type, args.group_name, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGroupMembership", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGroupCountOnPackedInstancePart(self, seqid, iprot, oprot):
        args = GetGroupCountOnPackedInstancePart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGroupCountOnPackedInstancePart_result()
        try:
            result.success = self._handler.GetGroupCountOnPackedInstancePart(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGroupCountOnPackedInstancePart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGroupNamesOnPackedInstancePart(self, seqid, iprot, oprot):
        args = GetGroupNamesOnPackedInstancePart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGroupNamesOnPackedInstancePart_result()
        try:
            result.success = self._handler.GetGroupNamesOnPackedInstancePart(args.node_id, args.part_id, args.group_type, args.group_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGroupNamesOnPackedInstancePart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGroupMembershipOnPackedInstancePart(self, seqid, iprot, oprot):
        args = GetGroupMembershipOnPackedInstancePart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGroupMembershipOnPackedInstancePart_result()
        try:
            result.success = self._handler.GetGroupMembershipOnPackedInstancePart(args.node_id, args.part_id, args.group_type, args.group_name, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGroupMembershipOnPackedInstancePart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetInstancedPartIds(self, seqid, iprot, oprot):
        args = GetInstancedPartIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetInstancedPartIds_result()
        try:
            result.success = self._handler.GetInstancedPartIds(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetInstancedPartIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetInstancerPartTransforms(self, seqid, iprot, oprot):
        args = GetInstancerPartTransforms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetInstancerPartTransforms_result()
        try:
            result.success = self._handler.GetInstancerPartTransforms(args.node_id, args.part_id, args.rst_order, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetInstancerPartTransforms", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetPartInfo(self, seqid, iprot, oprot):
        args = SetPartInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetPartInfo_result()
        try:
            result.success = self._handler.SetPartInfo(args.node_id, args.part_id, args.part_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetPartInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetFaceCounts(self, seqid, iprot, oprot):
        args = SetFaceCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetFaceCounts_result()
        try:
            result.success = self._handler.SetFaceCounts(args.node_id, args.part_id, args.face_counts_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetFaceCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVertexList(self, seqid, iprot, oprot):
        args = SetVertexList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVertexList_result()
        try:
            result.success = self._handler.SetVertexList(args.node_id, args.part_id, args.vertex_list_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVertexList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_AddAttribute(self, seqid, iprot, oprot):
        args = AddAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = AddAttribute_result()
        try:
            result.success = self._handler.AddAttribute(args.node_id, args.part_id, args.name, args.attr_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("AddAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteAttribute(self, seqid, iprot, oprot):
        args = DeleteAttribute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteAttribute_result()
        try:
            result.success = self._handler.DeleteAttribute(args.node_id, args.part_id, args.name, args.attr_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteAttribute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAttributeIntData(self, seqid, iprot, oprot):
        args = SetAttributeIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAttributeIntData_result()
        try:
            result.success = self._handler.SetAttributeIntData(args.node_id, args.part_id, args.name, args.attr_info, args.data_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAttributeIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAttributeInt64Data(self, seqid, iprot, oprot):
        args = SetAttributeInt64Data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAttributeInt64Data_result()
        try:
            result.success = self._handler.SetAttributeInt64Data(args.node_id, args.part_id, args.name, args.attr_info, args.data_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAttributeInt64Data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAttributeFloatData(self, seqid, iprot, oprot):
        args = SetAttributeFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAttributeFloatData_result()
        try:
            result.success = self._handler.SetAttributeFloatData(args.node_id, args.part_id, args.name, args.attr_info, args.data_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAttributeFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAttributeFloat64Data(self, seqid, iprot, oprot):
        args = SetAttributeFloat64Data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAttributeFloat64Data_result()
        try:
            result.success = self._handler.SetAttributeFloat64Data(args.node_id, args.part_id, args.name, args.attr_info, args.data_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAttributeFloat64Data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAttributeStringData(self, seqid, iprot, oprot):
        args = SetAttributeStringData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAttributeStringData_result()
        try:
            result.success = self._handler.SetAttributeStringData(args.node_id, args.part_id, args.name, args.attr_info, args.data_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAttributeStringData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_AddGroup(self, seqid, iprot, oprot):
        args = AddGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = AddGroup_result()
        try:
            result.success = self._handler.AddGroup(args.node_id, args.part_id, args.group_type, args.group_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("AddGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteGroup(self, seqid, iprot, oprot):
        args = DeleteGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteGroup_result()
        try:
            result.success = self._handler.DeleteGroup(args.node_id, args.part_id, args.group_type, args.group_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetGroupMembership(self, seqid, iprot, oprot):
        args = SetGroupMembership_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetGroupMembership_result()
        try:
            result.success = self._handler.SetGroupMembership(args.node_id, args.part_id, args.group_type, args.group_name, args.membership_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetGroupMembership", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CommitGeo(self, seqid, iprot, oprot):
        args = CommitGeo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CommitGeo_result()
        try:
            result.success = self._handler.CommitGeo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CommitGeo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RevertGeo(self, seqid, iprot, oprot):
        args = RevertGeo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RevertGeo_result()
        try:
            result.success = self._handler.RevertGeo(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RevertGeo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetMaterialNodeIdsOnFaces(self, seqid, iprot, oprot):
        args = GetMaterialNodeIdsOnFaces_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetMaterialNodeIdsOnFaces_result()
        try:
            result.success = self._handler.GetMaterialNodeIdsOnFaces(args.geometry_node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetMaterialNodeIdsOnFaces", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetMaterialInfo(self, seqid, iprot, oprot):
        args = GetMaterialInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetMaterialInfo_result()
        try:
            result.success = self._handler.GetMaterialInfo(args.material_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetMaterialInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RenderCOPToImage(self, seqid, iprot, oprot):
        args = RenderCOPToImage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RenderCOPToImage_result()
        try:
            result.success = self._handler.RenderCOPToImage(args.cop_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RenderCOPToImage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RenderTextureToImage(self, seqid, iprot, oprot):
        args = RenderTextureToImage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RenderTextureToImage_result()
        try:
            result.success = self._handler.RenderTextureToImage(args.material_node_id, args.parm_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RenderTextureToImage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetImageInfo(self, seqid, iprot, oprot):
        args = GetImageInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetImageInfo_result()
        try:
            result.success = self._handler.GetImageInfo(args.material_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetImageInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetImageInfo(self, seqid, iprot, oprot):
        args = SetImageInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetImageInfo_result()
        try:
            result.success = self._handler.SetImageInfo(args.material_node_id, args.image_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetImageInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetImagePlaneCount(self, seqid, iprot, oprot):
        args = GetImagePlaneCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetImagePlaneCount_result()
        try:
            result.success = self._handler.GetImagePlaneCount(args.material_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetImagePlaneCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetImagePlanes(self, seqid, iprot, oprot):
        args = GetImagePlanes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetImagePlanes_result()
        try:
            result.success = self._handler.GetImagePlanes(args.material_node_id, args.image_plane_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetImagePlanes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExtractImageToFile(self, seqid, iprot, oprot):
        args = ExtractImageToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExtractImageToFile_result()
        try:
            result.success = self._handler.ExtractImageToFile(args.material_node_id, args.image_file_format_name, args.image_planes, args.destination_folder_path, args.destination_file_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExtractImageToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetImageFilePath(self, seqid, iprot, oprot):
        args = GetImageFilePath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetImageFilePath_result()
        try:
            result.success = self._handler.GetImageFilePath(args.material_node_id, args.image_file_format_name, args.image_planes, args.destination_folder_path, args.destination_file_name, args.texture_parm_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetImageFilePath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExtractImageToMemory(self, seqid, iprot, oprot):
        args = ExtractImageToMemory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExtractImageToMemory_result()
        try:
            result.success = self._handler.ExtractImageToMemory(args.material_node_id, args.image_file_format_name, args.image_planes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExtractImageToMemory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetImageMemoryBuffer(self, seqid, iprot, oprot):
        args = GetImageMemoryBuffer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetImageMemoryBuffer_result()
        try:
            result.success = self._handler.GetImageMemoryBuffer(args.material_node_id, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetImageMemoryBuffer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSupportedImageFileFormatCount(self, seqid, iprot, oprot):
        args = GetSupportedImageFileFormatCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSupportedImageFileFormatCount_result()
        try:
            result.success = self._handler.GetSupportedImageFileFormatCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSupportedImageFileFormatCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSupportedImageFileFormats(self, seqid, iprot, oprot):
        args = GetSupportedImageFileFormats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSupportedImageFileFormats_result()
        try:
            result.success = self._handler.GetSupportedImageFileFormats(args.file_format_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSupportedImageFileFormats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetAnimCurve(self, seqid, iprot, oprot):
        args = SetAnimCurve_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetAnimCurve_result()
        try:
            result.success = self._handler.SetAnimCurve(args.node_id, args.parm_id, args.parm_index, args.curve_keyframes_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetAnimCurve", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetTransformAnimCurve(self, seqid, iprot, oprot):
        args = SetTransformAnimCurve_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetTransformAnimCurve_result()
        try:
            result.success = self._handler.SetTransformAnimCurve(args.node_id, args.trans_comp, args.curve_keyframes_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetTransformAnimCurve", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ResetSimulation(self, seqid, iprot, oprot):
        args = ResetSimulation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ResetSimulation_result()
        try:
            result.success = self._handler.ResetSimulation(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ResetSimulation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeInfo(self, seqid, iprot, oprot):
        args = GetVolumeInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeInfo_result()
        try:
            result.success = self._handler.GetVolumeInfo(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetFirstVolumeTile(self, seqid, iprot, oprot):
        args = GetFirstVolumeTile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetFirstVolumeTile_result()
        try:
            result.success = self._handler.GetFirstVolumeTile(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetFirstVolumeTile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNextVolumeTile(self, seqid, iprot, oprot):
        args = GetNextVolumeTile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNextVolumeTile_result()
        try:
            result.success = self._handler.GetNextVolumeTile(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNextVolumeTile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeVoxelFloatData(self, seqid, iprot, oprot):
        args = GetVolumeVoxelFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeVoxelFloatData_result()
        try:
            result.success = self._handler.GetVolumeVoxelFloatData(args.node_id, args.part_id, args.x_index, args.y_index, args.z_index, args.value_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeVoxelFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeTileFloatData(self, seqid, iprot, oprot):
        args = GetVolumeTileFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeTileFloatData_result()
        try:
            result.success = self._handler.GetVolumeTileFloatData(args.node_id, args.part_id, args.fill_value, args.tile, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeTileFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeVoxelIntData(self, seqid, iprot, oprot):
        args = GetVolumeVoxelIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeVoxelIntData_result()
        try:
            result.success = self._handler.GetVolumeVoxelIntData(args.node_id, args.part_id, args.x_index, args.y_index, args.z_index, args.value_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeVoxelIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeTileIntData(self, seqid, iprot, oprot):
        args = GetVolumeTileIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeTileIntData_result()
        try:
            result.success = self._handler.GetVolumeTileIntData(args.node_id, args.part_id, args.fill_value, args.tile, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeTileIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHeightFieldData(self, seqid, iprot, oprot):
        args = GetHeightFieldData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHeightFieldData_result()
        try:
            result.success = self._handler.GetHeightFieldData(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHeightFieldData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVolumeInfo(self, seqid, iprot, oprot):
        args = SetVolumeInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVolumeInfo_result()
        try:
            result.success = self._handler.SetVolumeInfo(args.node_id, args.part_id, args.volume_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVolumeInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVolumeTileFloatData(self, seqid, iprot, oprot):
        args = SetVolumeTileFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVolumeTileFloatData_result()
        try:
            result.success = self._handler.SetVolumeTileFloatData(args.node_id, args.part_id, args.tile, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVolumeTileFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVolumeTileIntData(self, seqid, iprot, oprot):
        args = SetVolumeTileIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVolumeTileIntData_result()
        try:
            result.success = self._handler.SetVolumeTileIntData(args.node_id, args.part_id, args.tile, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVolumeTileIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVolumeVoxelFloatData(self, seqid, iprot, oprot):
        args = SetVolumeVoxelFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVolumeVoxelFloatData_result()
        try:
            result.success = self._handler.SetVolumeVoxelFloatData(args.node_id, args.part_id, args.x_index, args.y_index, args.z_index, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVolumeVoxelFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetVolumeVoxelIntData(self, seqid, iprot, oprot):
        args = SetVolumeVoxelIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetVolumeVoxelIntData_result()
        try:
            result.success = self._handler.SetVolumeVoxelIntData(args.node_id, args.part_id, args.x_index, args.y_index, args.z_index, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetVolumeVoxelIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetVolumeBounds(self, seqid, iprot, oprot):
        args = GetVolumeBounds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetVolumeBounds_result()
        try:
            result.success = self._handler.GetVolumeBounds(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetVolumeBounds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetHeightFieldData(self, seqid, iprot, oprot):
        args = SetHeightFieldData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetHeightFieldData_result()
        try:
            result.success = self._handler.SetHeightFieldData(args.node_id, args.part_id, args.name, args.values_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetHeightFieldData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCurveInfo(self, seqid, iprot, oprot):
        args = GetCurveInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCurveInfo_result()
        try:
            result.success = self._handler.GetCurveInfo(args.node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCurveInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCurveCounts(self, seqid, iprot, oprot):
        args = GetCurveCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCurveCounts_result()
        try:
            result.success = self._handler.GetCurveCounts(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCurveCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCurveOrders(self, seqid, iprot, oprot):
        args = GetCurveOrders_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCurveOrders_result()
        try:
            result.success = self._handler.GetCurveOrders(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCurveOrders", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCurveKnots(self, seqid, iprot, oprot):
        args = GetCurveKnots_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCurveKnots_result()
        try:
            result.success = self._handler.GetCurveKnots(args.node_id, args.part_id, args.start, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCurveKnots", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCurveInfo(self, seqid, iprot, oprot):
        args = SetCurveInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCurveInfo_result()
        try:
            result.success = self._handler.SetCurveInfo(args.node_id, args.part_id, args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCurveInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCurveCounts(self, seqid, iprot, oprot):
        args = SetCurveCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCurveCounts_result()
        try:
            result.success = self._handler.SetCurveCounts(args.node_id, args.part_id, args.counts_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCurveCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCurveOrders(self, seqid, iprot, oprot):
        args = SetCurveOrders_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCurveOrders_result()
        try:
            result.success = self._handler.SetCurveOrders(args.node_id, args.part_id, args.orders_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCurveOrders", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCurveKnots(self, seqid, iprot, oprot):
        args = SetCurveKnots_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCurveKnots_result()
        try:
            result.success = self._handler.SetCurveKnots(args.node_id, args.part_id, args.knots_array, args.start)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCurveKnots", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetBoxInfo(self, seqid, iprot, oprot):
        args = GetBoxInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetBoxInfo_result()
        try:
            result.success = self._handler.GetBoxInfo(args.geo_node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetBoxInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSphereInfo(self, seqid, iprot, oprot):
        args = GetSphereInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSphereInfo_result()
        try:
            result.success = self._handler.GetSphereInfo(args.geo_node_id, args.part_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSphereInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetActiveCacheCount(self, seqid, iprot, oprot):
        args = GetActiveCacheCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetActiveCacheCount_result()
        try:
            result.success = self._handler.GetActiveCacheCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetActiveCacheCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetActiveCacheNames(self, seqid, iprot, oprot):
        args = GetActiveCacheNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetActiveCacheNames_result()
        try:
            result.success = self._handler.GetActiveCacheNames(args.active_cache_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetActiveCacheNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetCacheProperty(self, seqid, iprot, oprot):
        args = GetCacheProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetCacheProperty_result()
        try:
            result.success = self._handler.GetCacheProperty(args.cache_name, args.cache_property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetCacheProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetCacheProperty(self, seqid, iprot, oprot):
        args = SetCacheProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetCacheProperty_result()
        try:
            result.success = self._handler.SetCacheProperty(args.cache_name, args.cache_property, args.property_value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetCacheProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SaveGeoToFile(self, seqid, iprot, oprot):
        args = SaveGeoToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SaveGeoToFile_result()
        try:
            result.success = self._handler.SaveGeoToFile(args.node_id, args.file_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SaveGeoToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadGeoFromFile(self, seqid, iprot, oprot):
        args = LoadGeoFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadGeoFromFile_result()
        try:
            result.success = self._handler.LoadGeoFromFile(args.node_id, args.file_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadGeoFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SaveNodeToFile(self, seqid, iprot, oprot):
        args = SaveNodeToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SaveNodeToFile_result()
        try:
            result.success = self._handler.SaveNodeToFile(args.node_id, args.file_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SaveNodeToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadNodeFromFile(self, seqid, iprot, oprot):
        args = LoadNodeFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadNodeFromFile_result()
        try:
            result.success = self._handler.LoadNodeFromFile(args.file_name, args.parent_node_id, args.node_label, args.cook_on_load)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadNodeFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGeoSize(self, seqid, iprot, oprot):
        args = GetGeoSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGeoSize_result()
        try:
            result.success = self._handler.GetGeoSize(args.node_id, args.format)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGeoSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SaveGeoToMemory(self, seqid, iprot, oprot):
        args = SaveGeoToMemory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SaveGeoToMemory_result()
        try:
            result.success = self._handler.SaveGeoToMemory(args.node_id, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SaveGeoToMemory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadGeoFromMemory(self, seqid, iprot, oprot):
        args = LoadGeoFromMemory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadGeoFromMemory_result()
        try:
            result.success = self._handler.LoadGeoFromMemory(args.node_id, args.format, args.buffer, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadGeoFromMemory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetNodeDisplay(self, seqid, iprot, oprot):
        args = SetNodeDisplay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetNodeDisplay_result()
        try:
            result.success = self._handler.SetNodeDisplay(args.node_id, args.onOff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetNodeDisplay", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetTotalCookCount(self, seqid, iprot, oprot):
        args = GetTotalCookCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetTotalCookCount_result()
        try:
            result.success = self._handler.GetTotalCookCount(args.node_id, args.node_type_filter, args.node_flags_filter, args.recursive)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetTotalCookCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetSessionSync(self, seqid, iprot, oprot):
        args = SetSessionSync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetSessionSync_result()
        try:
            result.success = self._handler.SetSessionSync(args.enable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetSessionSync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetViewport(self, seqid, iprot, oprot):
        args = GetViewport_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetViewport_result()
        try:
            result.success = self._handler.GetViewport()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetViewport", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetViewport(self, seqid, iprot, oprot):
        args = SetViewport_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetViewport_result()
        try:
            result.success = self._handler.SetViewport(args.viewport)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetViewport", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSessionSyncInfo(self, seqid, iprot, oprot):
        args = GetSessionSyncInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSessionSyncInfo_result()
        try:
            result.success = self._handler.GetSessionSyncInfo()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSessionSyncInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetSessionSyncInfo(self, seqid, iprot, oprot):
        args = SetSessionSyncInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetSessionSyncInfo_result()
        try:
            result.success = self._handler.SetSessionSyncInfo(args.session_sync_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetSessionSyncInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPDGGraphContexts(self, seqid, iprot, oprot):
        args = GetPDGGraphContexts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPDGGraphContexts_result()
        try:
            result.success = self._handler.GetPDGGraphContexts(args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPDGGraphContexts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPDGGraphContextId(self, seqid, iprot, oprot):
        args = GetPDGGraphContextId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPDGGraphContextId_result()
        try:
            result.success = self._handler.GetPDGGraphContextId(args.top_node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPDGGraphContextId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CookPDG(self, seqid, iprot, oprot):
        args = CookPDG_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CookPDG_result()
        try:
            result.success = self._handler.CookPDG(args.cook_node_id, args.generate_only, args.blocking)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CookPDG", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPDGEvents(self, seqid, iprot, oprot):
        args = GetPDGEvents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPDGEvents_result()
        try:
            result.success = self._handler.GetPDGEvents(args.graph_context_id, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPDGEvents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPDGState(self, seqid, iprot, oprot):
        args = GetPDGState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPDGState_result()
        try:
            result.success = self._handler.GetPDGState(args.graph_context_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPDGState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateWorkitem(self, seqid, iprot, oprot):
        args = CreateWorkitem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateWorkitem_result()
        try:
            result.success = self._handler.CreateWorkitem(args.node_id, args.name, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateWorkitem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemInfo(self, seqid, iprot, oprot):
        args = GetWorkitemInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemInfo_result()
        try:
            result.success = self._handler.GetWorkitemInfo(args.graph_context_id, args.workitem_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetWorkitemIntData(self, seqid, iprot, oprot):
        args = SetWorkitemIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetWorkitemIntData_result()
        try:
            result.success = self._handler.SetWorkitemIntData(args.node_id, args.workitem_id, args.data_name, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetWorkitemIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetWorkitemFloatData(self, seqid, iprot, oprot):
        args = SetWorkitemFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetWorkitemFloatData_result()
        try:
            result.success = self._handler.SetWorkitemFloatData(args.node_id, args.workitem_id, args.data_name, args.values_array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetWorkitemFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetWorkitemStringData(self, seqid, iprot, oprot):
        args = SetWorkitemStringData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetWorkitemStringData_result()
        try:
            result.success = self._handler.SetWorkitemStringData(args.node_id, args.workitem_id, args.data_name, args.data_index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetWorkitemStringData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CommitWorkitems(self, seqid, iprot, oprot):
        args = CommitWorkitems_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CommitWorkitems_result()
        try:
            result.success = self._handler.CommitWorkitems(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CommitWorkitems", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNumWorkitems(self, seqid, iprot, oprot):
        args = GetNumWorkitems_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNumWorkitems_result()
        try:
            result.success = self._handler.GetNumWorkitems(args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNumWorkitems", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitems(self, seqid, iprot, oprot):
        args = GetWorkitems_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitems_result()
        try:
            result.success = self._handler.GetWorkitems(args.node_id, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitems", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemDataLength(self, seqid, iprot, oprot):
        args = GetWorkitemDataLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemDataLength_result()
        try:
            result.success = self._handler.GetWorkitemDataLength(args.node_id, args.workitem_id, args.data_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemDataLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemIntData(self, seqid, iprot, oprot):
        args = GetWorkitemIntData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemIntData_result()
        try:
            result.success = self._handler.GetWorkitemIntData(args.node_id, args.workitem_id, args.data_name, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemIntData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemFloatData(self, seqid, iprot, oprot):
        args = GetWorkitemFloatData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemFloatData_result()
        try:
            result.success = self._handler.GetWorkitemFloatData(args.node_id, args.workitem_id, args.data_name, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemFloatData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemStringData(self, seqid, iprot, oprot):
        args = GetWorkitemStringData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemStringData_result()
        try:
            result.success = self._handler.GetWorkitemStringData(args.node_id, args.workitem_id, args.data_name, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemStringData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetWorkitemResultInfo(self, seqid, iprot, oprot):
        args = GetWorkitemResultInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetWorkitemResultInfo_result()
        try:
            result.success = self._handler.GetWorkitemResultInfo(args.node_id, args.workitem_id, args.resultinfo_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetWorkitemResultInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DirtyPDGNode(self, seqid, iprot, oprot):
        args = DirtyPDGNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DirtyPDGNode_result()
        try:
            result.success = self._handler.DirtyPDGNode(args.node_id, args.clean_results)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DirtyPDGNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_PausePDGCook(self, seqid, iprot, oprot):
        args = PausePDGCook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = PausePDGCook_result()
        try:
            result.success = self._handler.PausePDGCook(args.graph_context_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("PausePDGCook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CancelPDGCook(self, seqid, iprot, oprot):
        args = CancelPDGCook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CancelPDGCook_result()
        try:
            result.success = self._handler.CancelPDGCook(args.graph_context_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CancelPDGCook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class IsInitialized_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IsInitialized_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(IsInitialized_args)
IsInitialized_args.thrift_spec = (
)


class IsInitialized_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IsInitialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(IsInitialized_result)
IsInitialized_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class Initialize_args(object):
    """
    Attributes:
     - cook_options
     - use_cooking_thread
     - cooking_thread_stack_size
     - houdini_environment_files
     - otl_search_path
     - dso_search_path
     - image_dso_search_path
     - audio_dso_search_path

    """


    def __init__(self, cook_options=None, use_cooking_thread=None, cooking_thread_stack_size=None, houdini_environment_files=None, otl_search_path=None, dso_search_path=None, image_dso_search_path=None, audio_dso_search_path=None,):
        self.cook_options = cook_options
        self.use_cooking_thread = use_cooking_thread
        self.cooking_thread_stack_size = cooking_thread_stack_size
        self.houdini_environment_files = houdini_environment_files
        self.otl_search_path = otl_search_path
        self.dso_search_path = dso_search_path
        self.image_dso_search_path = image_dso_search_path
        self.audio_dso_search_path = audio_dso_search_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cook_options = CookOptions()
                    self.cook_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.use_cooking_thread = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cooking_thread_stack_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.houdini_environment_files = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.otl_search_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dso_search_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.image_dso_search_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.audio_dso_search_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Initialize_args')
        if self.cook_options is not None:
            oprot.writeFieldBegin('cook_options', TType.STRUCT, 1)
            self.cook_options.write(oprot)
            oprot.writeFieldEnd()
        if self.use_cooking_thread is not None:
            oprot.writeFieldBegin('use_cooking_thread', TType.BOOL, 2)
            oprot.writeBool(self.use_cooking_thread)
            oprot.writeFieldEnd()
        if self.cooking_thread_stack_size is not None:
            oprot.writeFieldBegin('cooking_thread_stack_size', TType.I32, 3)
            oprot.writeI32(self.cooking_thread_stack_size)
            oprot.writeFieldEnd()
        if self.houdini_environment_files is not None:
            oprot.writeFieldBegin('houdini_environment_files', TType.STRING, 4)
            oprot.writeString(self.houdini_environment_files.encode('utf-8') if sys.version_info[0] == 2 else self.houdini_environment_files)
            oprot.writeFieldEnd()
        if self.otl_search_path is not None:
            oprot.writeFieldBegin('otl_search_path', TType.STRING, 5)
            oprot.writeString(self.otl_search_path.encode('utf-8') if sys.version_info[0] == 2 else self.otl_search_path)
            oprot.writeFieldEnd()
        if self.dso_search_path is not None:
            oprot.writeFieldBegin('dso_search_path', TType.STRING, 6)
            oprot.writeString(self.dso_search_path.encode('utf-8') if sys.version_info[0] == 2 else self.dso_search_path)
            oprot.writeFieldEnd()
        if self.image_dso_search_path is not None:
            oprot.writeFieldBegin('image_dso_search_path', TType.STRING, 7)
            oprot.writeString(self.image_dso_search_path.encode('utf-8') if sys.version_info[0] == 2 else self.image_dso_search_path)
            oprot.writeFieldEnd()
        if self.audio_dso_search_path is not None:
            oprot.writeFieldBegin('audio_dso_search_path', TType.STRING, 8)
            oprot.writeString(self.audio_dso_search_path.encode('utf-8') if sys.version_info[0] == 2 else self.audio_dso_search_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Initialize_args)
Initialize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cook_options', [CookOptions, None], None, ),  # 1
    (2, TType.BOOL, 'use_cooking_thread', None, None, ),  # 2
    (3, TType.I32, 'cooking_thread_stack_size', None, None, ),  # 3
    (4, TType.STRING, 'houdini_environment_files', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'otl_search_path', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dso_search_path', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'image_dso_search_path', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'audio_dso_search_path', 'UTF8', None, ),  # 8
)


class Initialize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Initialize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Initialize_result)
Initialize_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class Cleanup_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cleanup_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Cleanup_args)
Cleanup_args.thrift_spec = (
)


class Cleanup_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cleanup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Cleanup_result)
Cleanup_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetSessionEnvInt_args(object):
    """
    Attributes:
     - int_type

    """


    def __init__(self, int_type=None,):
        self.int_type = int_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.int_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionEnvInt_args')
        if self.int_type is not None:
            oprot.writeFieldBegin('int_type', TType.I32, 1)
            oprot.writeI32(self.int_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSessionEnvInt_args)
GetSessionEnvInt_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'int_type', None, None, ),  # 1
)


class GetSessionEnvInt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSessionEnvInt_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionEnvInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSessionEnvInt_result)
GetSessionEnvInt_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetSessionEnvInt_Out, None], None, ),  # 0
)


class GetServerEnvInt_args(object):
    """
    Attributes:
     - variable_name

    """


    def __init__(self, variable_name=None,):
        self.variable_name = variable_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.variable_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvInt_args')
        if self.variable_name is not None:
            oprot.writeFieldBegin('variable_name', TType.STRING, 1)
            oprot.writeString(self.variable_name.encode('utf-8') if sys.version_info[0] == 2 else self.variable_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvInt_args)
GetServerEnvInt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'variable_name', 'UTF8', None, ),  # 1
)


class GetServerEnvInt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetServerEnvInt_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvInt_result)
GetServerEnvInt_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetServerEnvInt_Out, None], None, ),  # 0
)


class GetServerEnvString_args(object):
    """
    Attributes:
     - variable_name

    """


    def __init__(self, variable_name=None,):
        self.variable_name = variable_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.variable_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvString_args')
        if self.variable_name is not None:
            oprot.writeFieldBegin('variable_name', TType.STRING, 1)
            oprot.writeString(self.variable_name.encode('utf-8') if sys.version_info[0] == 2 else self.variable_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvString_args)
GetServerEnvString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'variable_name', 'UTF8', None, ),  # 1
)


class GetServerEnvString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetServerEnvString_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvString_result)
GetServerEnvString_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetServerEnvString_Out, None], None, ),  # 0
)


class GetServerEnvVarCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvVarCount_args)
GetServerEnvVarCount_args.thrift_spec = (
)


class GetServerEnvVarCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetServerEnvVarCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvVarCount_result)
GetServerEnvVarCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetServerEnvVarCount_Out, None], None, ),  # 0
)


class GetServerEnvVarList_args(object):
    """
    Attributes:
     - start
     - length

    """


    def __init__(self, start=None, length=None,):
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarList_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 1)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvVarList_args)
GetServerEnvVarList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'start', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetServerEnvVarList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetServerEnvVarList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetServerEnvVarList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetServerEnvVarList_result)
GetServerEnvVarList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetServerEnvVarList_Out, None], None, ),  # 0
)


class SetServerEnvInt_args(object):
    """
    Attributes:
     - variable_name
     - value

    """


    def __init__(self, variable_name=None, value=None,):
        self.variable_name = variable_name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.variable_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetServerEnvInt_args')
        if self.variable_name is not None:
            oprot.writeFieldBegin('variable_name', TType.STRING, 1)
            oprot.writeString(self.variable_name.encode('utf-8') if sys.version_info[0] == 2 else self.variable_name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetServerEnvInt_args)
SetServerEnvInt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'variable_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class SetServerEnvInt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetServerEnvInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetServerEnvInt_result)
SetServerEnvInt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetServerEnvString_args(object):
    """
    Attributes:
     - variable_name
     - value

    """


    def __init__(self, variable_name=None, value=None,):
        self.variable_name = variable_name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.variable_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetServerEnvString_args')
        if self.variable_name is not None:
            oprot.writeFieldBegin('variable_name', TType.STRING, 1)
            oprot.writeString(self.variable_name.encode('utf-8') if sys.version_info[0] == 2 else self.variable_name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetServerEnvString_args)
SetServerEnvString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'variable_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)


class SetServerEnvString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetServerEnvString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetServerEnvString_result)
SetServerEnvString_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetStatus_args(object):
    """
    Attributes:
     - status_type

    """


    def __init__(self, status_type=None,):
        self.status_type = status_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatus_args')
        if self.status_type is not None:
            oprot.writeFieldBegin('status_type', TType.I32, 1)
            oprot.writeI32(self.status_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatus_args)
GetStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status_type', None, None, ),  # 1
)


class GetStatus_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStatus_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatus_result)
GetStatus_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStatus_Out, None], None, ),  # 0
)


class GetStatusStringBufLength_args(object):
    """
    Attributes:
     - status_type
     - verbosity

    """


    def __init__(self, status_type=None, verbosity=None,):
        self.status_type = status_type
        self.verbosity = verbosity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.verbosity = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusStringBufLength_args')
        if self.status_type is not None:
            oprot.writeFieldBegin('status_type', TType.I32, 1)
            oprot.writeI32(self.status_type)
            oprot.writeFieldEnd()
        if self.verbosity is not None:
            oprot.writeFieldBegin('verbosity', TType.I32, 2)
            oprot.writeI32(self.verbosity)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatusStringBufLength_args)
GetStatusStringBufLength_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status_type', None, None, ),  # 1
    (2, TType.I32, 'verbosity', None, None, ),  # 2
)


class GetStatusStringBufLength_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStatusStringBufLength_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusStringBufLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatusStringBufLength_result)
GetStatusStringBufLength_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStatusStringBufLength_Out, None], None, ),  # 0
)


class GetStatusString_args(object):
    """
    Attributes:
     - status_type
     - length

    """


    def __init__(self, status_type=None, length=None,):
        self.status_type = status_type
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusString_args')
        if self.status_type is not None:
            oprot.writeFieldBegin('status_type', TType.I32, 1)
            oprot.writeI32(self.status_type)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatusString_args)
GetStatusString_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status_type', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetStatusString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStatusString_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatusString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatusString_result)
GetStatusString_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStatusString_Out, None], None, ),  # 0
)


class ComposeNodeCookResult_args(object):
    """
    Attributes:
     - node_id
     - verbosity

    """


    def __init__(self, node_id=None, verbosity=None,):
        self.node_id = node_id
        self.verbosity = verbosity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.verbosity = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeNodeCookResult_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.verbosity is not None:
            oprot.writeFieldBegin('verbosity', TType.I32, 2)
            oprot.writeI32(self.verbosity)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeNodeCookResult_args)
ComposeNodeCookResult_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'verbosity', None, None, ),  # 2
)


class ComposeNodeCookResult_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ComposeNodeCookResult_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeNodeCookResult_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeNodeCookResult_result)
ComposeNodeCookResult_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ComposeNodeCookResult_Out, None], None, ),  # 0
)


class GetComposedNodeCookResult_args(object):
    """
    Attributes:
     - length

    """


    def __init__(self, length=None,):
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedNodeCookResult_args')
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 1)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedNodeCookResult_args)
GetComposedNodeCookResult_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'length', None, None, ),  # 1
)


class GetComposedNodeCookResult_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetComposedNodeCookResult_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedNodeCookResult_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedNodeCookResult_result)
GetComposedNodeCookResult_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetComposedNodeCookResult_Out, None], None, ),  # 0
)


class CheckForSpecificErrors_args(object):
    """
    Attributes:
     - node_id
     - errors_to_look_for

    """


    def __init__(self, node_id=None, errors_to_look_for=None,):
        self.node_id = node_id
        self.errors_to_look_for = errors_to_look_for

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.errors_to_look_for = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckForSpecificErrors_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.errors_to_look_for is not None:
            oprot.writeFieldBegin('errors_to_look_for', TType.I32, 2)
            oprot.writeI32(self.errors_to_look_for)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckForSpecificErrors_args)
CheckForSpecificErrors_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'errors_to_look_for', None, None, ),  # 2
)


class CheckForSpecificErrors_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CheckForSpecificErrors_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckForSpecificErrors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckForSpecificErrors_result)
CheckForSpecificErrors_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CheckForSpecificErrors_Out, None], None, ),  # 0
)


class GetCookingTotalCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingTotalCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCookingTotalCount_args)
GetCookingTotalCount_args.thrift_spec = (
)


class GetCookingTotalCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCookingTotalCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingTotalCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCookingTotalCount_result)
GetCookingTotalCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCookingTotalCount_Out, None], None, ),  # 0
)


class GetCookingCurrentCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingCurrentCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCookingCurrentCount_args)
GetCookingCurrentCount_args.thrift_spec = (
)


class GetCookingCurrentCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCookingCurrentCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCookingCurrentCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCookingCurrentCount_result)
GetCookingCurrentCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCookingCurrentCount_Out, None], None, ),  # 0
)


class ConvertTransform_args(object):
    """
    Attributes:
     - transform_in
     - rst_order
     - rot_order

    """


    def __init__(self, transform_in=None, rst_order=None, rot_order=None,):
        self.transform_in = transform_in
        self.rst_order = rst_order
        self.rot_order = rot_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform_in = TransformEuler()
                    self.transform_in.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rot_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransform_args')
        if self.transform_in is not None:
            oprot.writeFieldBegin('transform_in', TType.STRUCT, 1)
            self.transform_in.write(oprot)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 2)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.rot_order is not None:
            oprot.writeFieldBegin('rot_order', TType.I32, 3)
            oprot.writeI32(self.rot_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransform_args)
ConvertTransform_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform_in', [TransformEuler, None], None, ),  # 1
    (2, TType.I32, 'rst_order', None, None, ),  # 2
    (3, TType.I32, 'rot_order', None, None, ),  # 3
)


class ConvertTransform_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConvertTransform_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransform_result)
ConvertTransform_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConvertTransform_Out, None], None, ),  # 0
)


class ConvertMatrixToQuat_args(object):
    """
    Attributes:
     - matrix
     - rst_order

    """


    def __init__(self, matrix=None, rst_order=None,):
        self.matrix = matrix
        self.rst_order = rst_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matrix = []
                    (_etype507, _size504) = iprot.readListBegin()
                    for _i508 in range(_size504):
                        _elem509 = iprot.readDouble()
                        self.matrix.append(_elem509)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToQuat_args')
        if self.matrix is not None:
            oprot.writeFieldBegin('matrix', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.matrix))
            for iter510 in self.matrix:
                oprot.writeDouble(iter510)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 2)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertMatrixToQuat_args)
ConvertMatrixToQuat_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matrix', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.I32, 'rst_order', None, None, ),  # 2
)


class ConvertMatrixToQuat_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConvertMatrixToQuat_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToQuat_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertMatrixToQuat_result)
ConvertMatrixToQuat_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConvertMatrixToQuat_Out, None], None, ),  # 0
)


class ConvertMatrixToEuler_args(object):
    """
    Attributes:
     - matrix
     - rst_order
     - rot_order

    """


    def __init__(self, matrix=None, rst_order=None, rot_order=None,):
        self.matrix = matrix
        self.rst_order = rst_order
        self.rot_order = rot_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.matrix = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readDouble()
                        self.matrix.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rot_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToEuler_args')
        if self.matrix is not None:
            oprot.writeFieldBegin('matrix', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.matrix))
            for iter517 in self.matrix:
                oprot.writeDouble(iter517)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 2)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.rot_order is not None:
            oprot.writeFieldBegin('rot_order', TType.I32, 3)
            oprot.writeI32(self.rot_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertMatrixToEuler_args)
ConvertMatrixToEuler_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'matrix', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.I32, 'rst_order', None, None, ),  # 2
    (3, TType.I32, 'rot_order', None, None, ),  # 3
)


class ConvertMatrixToEuler_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConvertMatrixToEuler_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertMatrixToEuler_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertMatrixToEuler_result)
ConvertMatrixToEuler_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConvertMatrixToEuler_Out, None], None, ),  # 0
)


class ConvertTransformQuatToMatrix_args(object):
    """
    Attributes:
     - transform

    """


    def __init__(self, transform=None,):
        self.transform = transform

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = Transform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformQuatToMatrix_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransformQuatToMatrix_args)
ConvertTransformQuatToMatrix_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [Transform, None], None, ),  # 1
)


class ConvertTransformQuatToMatrix_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConvertTransformQuatToMatrix_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformQuatToMatrix_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransformQuatToMatrix_result)
ConvertTransformQuatToMatrix_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConvertTransformQuatToMatrix_Out, None], None, ),  # 0
)


class ConvertTransformEulerToMatrix_args(object):
    """
    Attributes:
     - transform

    """


    def __init__(self, transform=None,):
        self.transform = transform

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transform = TransformEuler()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformEulerToMatrix_args')
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 1)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransformEulerToMatrix_args)
ConvertTransformEulerToMatrix_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transform', [TransformEuler, None], None, ),  # 1
)


class ConvertTransformEulerToMatrix_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConvertTransformEulerToMatrix_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConvertTransformEulerToMatrix_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConvertTransformEulerToMatrix_result)
ConvertTransformEulerToMatrix_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConvertTransformEulerToMatrix_Out, None], None, ),  # 0
)


class PythonThreadInterpreterLock_args(object):
    """
    Attributes:
     - locked

    """


    def __init__(self, locked=None,):
        self.locked = locked

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.locked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PythonThreadInterpreterLock_args')
        if self.locked is not None:
            oprot.writeFieldBegin('locked', TType.BOOL, 1)
            oprot.writeBool(self.locked)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PythonThreadInterpreterLock_args)
PythonThreadInterpreterLock_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'locked', None, None, ),  # 1
)


class PythonThreadInterpreterLock_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PythonThreadInterpreterLock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PythonThreadInterpreterLock_result)
PythonThreadInterpreterLock_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetStringBufLength_args(object):
    """
    Attributes:
     - string_handle

    """


    def __init__(self, string_handle=None,):
        self.string_handle = string_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.string_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBufLength_args')
        if self.string_handle is not None:
            oprot.writeFieldBegin('string_handle', TType.I32, 1)
            oprot.writeI32(self.string_handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBufLength_args)
GetStringBufLength_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'string_handle', None, None, ),  # 1
)


class GetStringBufLength_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStringBufLength_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBufLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBufLength_result)
GetStringBufLength_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStringBufLength_Out, None], None, ),  # 0
)


class GetString_args(object):
    """
    Attributes:
     - string_handle
     - length

    """


    def __init__(self, string_handle=None, length=None,):
        self.string_handle = string_handle
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.string_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetString_args')
        if self.string_handle is not None:
            oprot.writeFieldBegin('string_handle', TType.I32, 1)
            oprot.writeI32(self.string_handle)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetString_args)
GetString_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'string_handle', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetString_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetString_result)
GetString_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetString_Out, None], None, ),  # 0
)


class SetCustomString_args(object):
    """
    Attributes:
     - string_value

    """


    def __init__(self, string_value=None,):
        self.string_value = string_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCustomString_args')
        if self.string_value is not None:
            oprot.writeFieldBegin('string_value', TType.STRING, 1)
            oprot.writeString(self.string_value.encode('utf-8') if sys.version_info[0] == 2 else self.string_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCustomString_args)
SetCustomString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_value', 'UTF8', None, ),  # 1
)


class SetCustomString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SetCustomString_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCustomString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCustomString_result)
SetCustomString_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SetCustomString_Out, None], None, ),  # 0
)


class RemoveCustomString_args(object):
    """
    Attributes:
     - string_handle

    """


    def __init__(self, string_handle=None,):
        self.string_handle = string_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.string_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveCustomString_args')
        if self.string_handle is not None:
            oprot.writeFieldBegin('string_handle', TType.I32, 1)
            oprot.writeI32(self.string_handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveCustomString_args)
RemoveCustomString_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'string_handle', None, None, ),  # 1
)


class RemoveCustomString_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveCustomString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveCustomString_result)
RemoveCustomString_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetStringBatchSize_args(object):
    """
    Attributes:
     - string_handle_array

    """


    def __init__(self, string_handle_array=None,):
        self.string_handle_array = string_handle_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.string_handle_array = []
                    (_etype521, _size518) = iprot.readListBegin()
                    for _i522 in range(_size518):
                        _elem523 = iprot.readI32()
                        self.string_handle_array.append(_elem523)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatchSize_args')
        if self.string_handle_array is not None:
            oprot.writeFieldBegin('string_handle_array', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.string_handle_array))
            for iter524 in self.string_handle_array:
                oprot.writeI32(iter524)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBatchSize_args)
GetStringBatchSize_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'string_handle_array', (TType.I32, None, False), None, ),  # 1
)


class GetStringBatchSize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStringBatchSize_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatchSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBatchSize_result)
GetStringBatchSize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStringBatchSize_Out, None], None, ),  # 0
)


class GetStringBatch_args(object):
    """
    Attributes:
     - char_array_length

    """


    def __init__(self, char_array_length=None,):
        self.char_array_length = char_array_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.char_array_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatch_args')
        if self.char_array_length is not None:
            oprot.writeFieldBegin('char_array_length', TType.I32, 1)
            oprot.writeI32(self.char_array_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBatch_args)
GetStringBatch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'char_array_length', None, None, ),  # 1
)


class GetStringBatch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetStringBatch_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStringBatch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStringBatch_result)
GetStringBatch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetStringBatch_Out, None], None, ),  # 0
)


class GetTime_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTime_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTime_args)
GetTime_args.thrift_spec = (
)


class GetTime_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTime_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTime_result)
GetTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetTime_Out, None], None, ),  # 0
)


class SetTime_args(object):
    """
    Attributes:
     - time

    """


    def __init__(self, time=None,):
        self.time = time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTime_args')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.DOUBLE, 1)
            oprot.writeDouble(self.time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTime_args)
SetTime_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'time', None, None, ),  # 1
)


class SetTime_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTime_result)
SetTime_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetUseHoudiniTime_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUseHoudiniTime_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetUseHoudiniTime_args)
GetUseHoudiniTime_args.thrift_spec = (
)


class GetUseHoudiniTime_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetUseHoudiniTime_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetUseHoudiniTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetUseHoudiniTime_result)
GetUseHoudiniTime_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetUseHoudiniTime_Out, None], None, ),  # 0
)


class SetUseHoudiniTime_args(object):
    """
    Attributes:
     - enabled

    """


    def __init__(self, enabled=None,):
        self.enabled = enabled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetUseHoudiniTime_args')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetUseHoudiniTime_args)
SetUseHoudiniTime_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
)


class SetUseHoudiniTime_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetUseHoudiniTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetUseHoudiniTime_result)
SetUseHoudiniTime_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetTimelineOptions_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTimelineOptions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTimelineOptions_args)
GetTimelineOptions_args.thrift_spec = (
)


class GetTimelineOptions_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTimelineOptions_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTimelineOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTimelineOptions_result)
GetTimelineOptions_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetTimelineOptions_Out, None], None, ),  # 0
)


class SetTimelineOptions_args(object):
    """
    Attributes:
     - timeline_options

    """


    def __init__(self, timeline_options=None,):
        self.timeline_options = timeline_options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.timeline_options = TimelineOptions()
                    self.timeline_options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTimelineOptions_args')
        if self.timeline_options is not None:
            oprot.writeFieldBegin('timeline_options', TType.STRUCT, 1)
            self.timeline_options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTimelineOptions_args)
SetTimelineOptions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'timeline_options', [TimelineOptions, None], None, ),  # 1
)


class SetTimelineOptions_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTimelineOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTimelineOptions_result)
SetTimelineOptions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class LoadAssetLibraryFromFile_args(object):
    """
    Attributes:
     - file_path
     - allow_overwrite

    """


    def __init__(self, file_path=None, allow_overwrite=None,):
        self.file_path = file_path
        self.allow_overwrite = allow_overwrite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.allow_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromFile_args')
        if self.file_path is not None:
            oprot.writeFieldBegin('file_path', TType.STRING, 1)
            oprot.writeString(self.file_path.encode('utf-8') if sys.version_info[0] == 2 else self.file_path)
            oprot.writeFieldEnd()
        if self.allow_overwrite is not None:
            oprot.writeFieldBegin('allow_overwrite', TType.BOOL, 2)
            oprot.writeBool(self.allow_overwrite)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadAssetLibraryFromFile_args)
LoadAssetLibraryFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_path', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'allow_overwrite', None, None, ),  # 2
)


class LoadAssetLibraryFromFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoadAssetLibraryFromFile_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadAssetLibraryFromFile_result)
LoadAssetLibraryFromFile_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LoadAssetLibraryFromFile_Out, None], None, ),  # 0
)


class LoadAssetLibraryFromMemory_args(object):
    """
    Attributes:
     - library_buffer
     - library_buffer_length
     - allow_overwrite

    """


    def __init__(self, library_buffer=None, library_buffer_length=None, allow_overwrite=None,):
        self.library_buffer = library_buffer
        self.library_buffer_length = library_buffer_length
        self.allow_overwrite = allow_overwrite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.library_buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.library_buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.allow_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromMemory_args')
        if self.library_buffer is not None:
            oprot.writeFieldBegin('library_buffer', TType.STRING, 1)
            oprot.writeBinary(self.library_buffer)
            oprot.writeFieldEnd()
        if self.library_buffer_length is not None:
            oprot.writeFieldBegin('library_buffer_length', TType.I32, 2)
            oprot.writeI32(self.library_buffer_length)
            oprot.writeFieldEnd()
        if self.allow_overwrite is not None:
            oprot.writeFieldBegin('allow_overwrite', TType.BOOL, 3)
            oprot.writeBool(self.allow_overwrite)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadAssetLibraryFromMemory_args)
LoadAssetLibraryFromMemory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'library_buffer', 'BINARY', None, ),  # 1
    (2, TType.I32, 'library_buffer_length', None, None, ),  # 2
    (3, TType.BOOL, 'allow_overwrite', None, None, ),  # 3
)


class LoadAssetLibraryFromMemory_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoadAssetLibraryFromMemory_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadAssetLibraryFromMemory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadAssetLibraryFromMemory_result)
LoadAssetLibraryFromMemory_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LoadAssetLibraryFromMemory_Out, None], None, ),  # 0
)


class GetAvailableAssetCount_args(object):
    """
    Attributes:
     - library_id

    """


    def __init__(self, library_id=None,):
        self.library_id = library_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssetCount_args')
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 1)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAvailableAssetCount_args)
GetAvailableAssetCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'library_id', None, None, ),  # 1
)


class GetAvailableAssetCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAvailableAssetCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssetCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAvailableAssetCount_result)
GetAvailableAssetCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAvailableAssetCount_Out, None], None, ),  # 0
)


class GetAvailableAssets_args(object):
    """
    Attributes:
     - library_id
     - asset_count

    """


    def __init__(self, library_id=None, asset_count=None,):
        self.library_id = library_id
        self.asset_count = asset_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.asset_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssets_args')
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 1)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        if self.asset_count is not None:
            oprot.writeFieldBegin('asset_count', TType.I32, 2)
            oprot.writeI32(self.asset_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAvailableAssets_args)
GetAvailableAssets_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'library_id', None, None, ),  # 1
    (2, TType.I32, 'asset_count', None, None, ),  # 2
)


class GetAvailableAssets_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAvailableAssets_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAvailableAssets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAvailableAssets_result)
GetAvailableAssets_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAvailableAssets_Out, None], None, ),  # 0
)


class GetAssetInfo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetInfo_args)
GetAssetInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class GetAssetInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAssetInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetInfo_result)
GetAssetInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAssetInfo_Out, None], None, ),  # 0
)


class GetAssetDefinitionParmCounts_args(object):
    """
    Attributes:
     - library_id
     - asset_name

    """


    def __init__(self, library_id=None, asset_name=None,):
        self.library_id = library_id
        self.asset_name = asset_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.asset_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmCounts_args')
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 1)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        if self.asset_name is not None:
            oprot.writeFieldBegin('asset_name', TType.STRING, 2)
            oprot.writeString(self.asset_name.encode('utf-8') if sys.version_info[0] == 2 else self.asset_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmCounts_args)
GetAssetDefinitionParmCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'library_id', None, None, ),  # 1
    (2, TType.STRING, 'asset_name', 'UTF8', None, ),  # 2
)


class GetAssetDefinitionParmCounts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAssetDefinitionParmCounts_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmCounts_result)
GetAssetDefinitionParmCounts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAssetDefinitionParmCounts_Out, None], None, ),  # 0
)


class GetAssetDefinitionParmInfos_args(object):
    """
    Attributes:
     - library_id
     - asset_name
     - start
     - length

    """


    def __init__(self, library_id=None, asset_name=None, start=None, length=None,):
        self.library_id = library_id
        self.asset_name = asset_name
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.asset_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmInfos_args')
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 1)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        if self.asset_name is not None:
            oprot.writeFieldBegin('asset_name', TType.STRING, 2)
            oprot.writeString(self.asset_name.encode('utf-8') if sys.version_info[0] == 2 else self.asset_name)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmInfos_args)
GetAssetDefinitionParmInfos_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'library_id', None, None, ),  # 1
    (2, TType.STRING, 'asset_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetAssetDefinitionParmInfos_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAssetDefinitionParmInfos_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmInfos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmInfos_result)
GetAssetDefinitionParmInfos_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAssetDefinitionParmInfos_Out, None], None, ),  # 0
)


class GetAssetDefinitionParmValues_args(object):
    """
    Attributes:
     - library_id
     - asset_name
     - int_start
     - int_length
     - float_start
     - float_length
     - string_evaluate
     - string_start
     - string_length
     - choice_start
     - choice_length

    """


    def __init__(self, library_id=None, asset_name=None, int_start=None, int_length=None, float_start=None, float_length=None, string_evaluate=None, string_start=None, string_length=None, choice_start=None, choice_length=None,):
        self.library_id = library_id
        self.asset_name = asset_name
        self.int_start = int_start
        self.int_length = int_length
        self.float_start = float_start
        self.float_length = float_length
        self.string_evaluate = string_evaluate
        self.string_start = string_start
        self.string_length = string_length
        self.choice_start = choice_start
        self.choice_length = choice_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.library_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.asset_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.int_start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.int_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.float_start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.float_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.string_evaluate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.string_start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.string_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.choice_start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.choice_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmValues_args')
        if self.library_id is not None:
            oprot.writeFieldBegin('library_id', TType.I32, 1)
            oprot.writeI32(self.library_id)
            oprot.writeFieldEnd()
        if self.asset_name is not None:
            oprot.writeFieldBegin('asset_name', TType.STRING, 2)
            oprot.writeString(self.asset_name.encode('utf-8') if sys.version_info[0] == 2 else self.asset_name)
            oprot.writeFieldEnd()
        if self.int_start is not None:
            oprot.writeFieldBegin('int_start', TType.I32, 3)
            oprot.writeI32(self.int_start)
            oprot.writeFieldEnd()
        if self.int_length is not None:
            oprot.writeFieldBegin('int_length', TType.I32, 4)
            oprot.writeI32(self.int_length)
            oprot.writeFieldEnd()
        if self.float_start is not None:
            oprot.writeFieldBegin('float_start', TType.I32, 5)
            oprot.writeI32(self.float_start)
            oprot.writeFieldEnd()
        if self.float_length is not None:
            oprot.writeFieldBegin('float_length', TType.I32, 6)
            oprot.writeI32(self.float_length)
            oprot.writeFieldEnd()
        if self.string_evaluate is not None:
            oprot.writeFieldBegin('string_evaluate', TType.BOOL, 7)
            oprot.writeBool(self.string_evaluate)
            oprot.writeFieldEnd()
        if self.string_start is not None:
            oprot.writeFieldBegin('string_start', TType.I32, 8)
            oprot.writeI32(self.string_start)
            oprot.writeFieldEnd()
        if self.string_length is not None:
            oprot.writeFieldBegin('string_length', TType.I32, 9)
            oprot.writeI32(self.string_length)
            oprot.writeFieldEnd()
        if self.choice_start is not None:
            oprot.writeFieldBegin('choice_start', TType.I32, 10)
            oprot.writeI32(self.choice_start)
            oprot.writeFieldEnd()
        if self.choice_length is not None:
            oprot.writeFieldBegin('choice_length', TType.I32, 11)
            oprot.writeI32(self.choice_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmValues_args)
GetAssetDefinitionParmValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'library_id', None, None, ),  # 1
    (2, TType.STRING, 'asset_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'int_start', None, None, ),  # 3
    (4, TType.I32, 'int_length', None, None, ),  # 4
    (5, TType.I32, 'float_start', None, None, ),  # 5
    (6, TType.I32, 'float_length', None, None, ),  # 6
    (7, TType.BOOL, 'string_evaluate', None, None, ),  # 7
    (8, TType.I32, 'string_start', None, None, ),  # 8
    (9, TType.I32, 'string_length', None, None, ),  # 9
    (10, TType.I32, 'choice_start', None, None, ),  # 10
    (11, TType.I32, 'choice_length', None, None, ),  # 11
)


class GetAssetDefinitionParmValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAssetDefinitionParmValues_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAssetDefinitionParmValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAssetDefinitionParmValues_result)
GetAssetDefinitionParmValues_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAssetDefinitionParmValues_Out, None], None, ),  # 0
)


class Interrupt_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Interrupt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Interrupt_args)
Interrupt_args.thrift_spec = (
)


class Interrupt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Interrupt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Interrupt_result)
Interrupt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class LoadHIPFile_args(object):
    """
    Attributes:
     - file_name
     - cook_on_load

    """


    def __init__(self, file_name=None, cook_on_load=None,):
        self.file_name = file_name
        self.cook_on_load = cook_on_load

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.cook_on_load = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadHIPFile_args')
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 1)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.cook_on_load is not None:
            oprot.writeFieldBegin('cook_on_load', TType.BOOL, 2)
            oprot.writeBool(self.cook_on_load)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadHIPFile_args)
LoadHIPFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'cook_on_load', None, None, ),  # 2
)


class LoadHIPFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadHIPFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadHIPFile_result)
LoadHIPFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SaveHIPFile_args(object):
    """
    Attributes:
     - file_path
     - lock_nodes

    """


    def __init__(self, file_path=None, lock_nodes=None,):
        self.file_path = file_path
        self.lock_nodes = lock_nodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.lock_nodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveHIPFile_args')
        if self.file_path is not None:
            oprot.writeFieldBegin('file_path', TType.STRING, 1)
            oprot.writeString(self.file_path.encode('utf-8') if sys.version_info[0] == 2 else self.file_path)
            oprot.writeFieldEnd()
        if self.lock_nodes is not None:
            oprot.writeFieldBegin('lock_nodes', TType.BOOL, 2)
            oprot.writeBool(self.lock_nodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveHIPFile_args)
SaveHIPFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_path', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'lock_nodes', None, None, ),  # 2
)


class SaveHIPFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveHIPFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveHIPFile_result)
SaveHIPFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class IsNodeValid_args(object):
    """
    Attributes:
     - node_id
     - unique_node_id

    """


    def __init__(self, node_id=None, unique_node_id=None,):
        self.node_id = node_id
        self.unique_node_id = unique_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.unique_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IsNodeValid_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.unique_node_id is not None:
            oprot.writeFieldBegin('unique_node_id', TType.I32, 2)
            oprot.writeI32(self.unique_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(IsNodeValid_args)
IsNodeValid_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'unique_node_id', None, None, ),  # 2
)


class IsNodeValid_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IsNodeValid_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IsNodeValid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(IsNodeValid_result)
IsNodeValid_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [IsNodeValid_Out, None], None, ),  # 0
)


class GetNodeInfo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeInfo_args)
GetNodeInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class GetNodeInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNodeInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeInfo_result)
GetNodeInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNodeInfo_Out, None], None, ),  # 0
)


class GetNodePath_args(object):
    """
    Attributes:
     - node_id
     - relative_to_node_id

    """


    def __init__(self, node_id=None, relative_to_node_id=None,):
        self.node_id = node_id
        self.relative_to_node_id = relative_to_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.relative_to_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodePath_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.relative_to_node_id is not None:
            oprot.writeFieldBegin('relative_to_node_id', TType.I32, 2)
            oprot.writeI32(self.relative_to_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodePath_args)
GetNodePath_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'relative_to_node_id', None, None, ),  # 2
)


class GetNodePath_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNodePath_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodePath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodePath_result)
GetNodePath_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNodePath_Out, None], None, ),  # 0
)


class GetManagerNodeId_args(object):
    """
    Attributes:
     - node_type

    """


    def __init__(self, node_type=None,):
        self.node_type = node_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetManagerNodeId_args')
        if self.node_type is not None:
            oprot.writeFieldBegin('node_type', TType.I32, 1)
            oprot.writeI32(self.node_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetManagerNodeId_args)
GetManagerNodeId_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_type', None, None, ),  # 1
)


class GetManagerNodeId_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetManagerNodeId_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetManagerNodeId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetManagerNodeId_result)
GetManagerNodeId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetManagerNodeId_Out, None], None, ),  # 0
)


class ComposeChildNodeList_args(object):
    """
    Attributes:
     - parent_node_id
     - node_type_filter
     - node_flags_filter
     - recursive

    """


    def __init__(self, parent_node_id=None, node_type_filter=None, node_flags_filter=None, recursive=None,):
        self.parent_node_id = parent_node_id
        self.node_type_filter = node_type_filter
        self.node_flags_filter = node_flags_filter
        self.recursive = recursive

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_type_filter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_flags_filter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.recursive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeChildNodeList_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.node_type_filter is not None:
            oprot.writeFieldBegin('node_type_filter', TType.I32, 2)
            oprot.writeI32(self.node_type_filter)
            oprot.writeFieldEnd()
        if self.node_flags_filter is not None:
            oprot.writeFieldBegin('node_flags_filter', TType.I32, 3)
            oprot.writeI32(self.node_flags_filter)
            oprot.writeFieldEnd()
        if self.recursive is not None:
            oprot.writeFieldBegin('recursive', TType.BOOL, 4)
            oprot.writeBool(self.recursive)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeChildNodeList_args)
ComposeChildNodeList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.I32, 'node_type_filter', None, None, ),  # 2
    (3, TType.I32, 'node_flags_filter', None, None, ),  # 3
    (4, TType.BOOL, 'recursive', None, None, ),  # 4
)


class ComposeChildNodeList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ComposeChildNodeList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeChildNodeList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeChildNodeList_result)
ComposeChildNodeList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ComposeChildNodeList_Out, None], None, ),  # 0
)


class GetComposedChildNodeList_args(object):
    """
    Attributes:
     - parent_node_id
     - count

    """


    def __init__(self, parent_node_id=None, count=None,):
        self.parent_node_id = parent_node_id
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedChildNodeList_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedChildNodeList_args)
GetComposedChildNodeList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)


class GetComposedChildNodeList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetComposedChildNodeList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedChildNodeList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedChildNodeList_result)
GetComposedChildNodeList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetComposedChildNodeList_Out, None], None, ),  # 0
)


class CreateNode_args(object):
    """
    Attributes:
     - parent_node_id
     - operator_name
     - node_label
     - cook_on_creation

    """


    def __init__(self, parent_node_id=None, operator_name=None, node_label=None, cook_on_creation=None,):
        self.parent_node_id = parent_node_id
        self.operator_name = operator_name
        self.node_label = node_label
        self.cook_on_creation = cook_on_creation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.operator_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.node_label = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.cook_on_creation = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateNode_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.operator_name is not None:
            oprot.writeFieldBegin('operator_name', TType.STRING, 2)
            oprot.writeString(self.operator_name.encode('utf-8') if sys.version_info[0] == 2 else self.operator_name)
            oprot.writeFieldEnd()
        if self.node_label is not None:
            oprot.writeFieldBegin('node_label', TType.STRING, 3)
            oprot.writeString(self.node_label.encode('utf-8') if sys.version_info[0] == 2 else self.node_label)
            oprot.writeFieldEnd()
        if self.cook_on_creation is not None:
            oprot.writeFieldBegin('cook_on_creation', TType.BOOL, 4)
            oprot.writeBool(self.cook_on_creation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateNode_args)
CreateNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.STRING, 'operator_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'node_label', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'cook_on_creation', None, None, ),  # 4
)


class CreateNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateNode_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateNode_result)
CreateNode_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateNode_Out, None], None, ),  # 0
)


class CreateInputNode_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateInputNode_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateInputNode_args)
CreateInputNode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class CreateInputNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateInputNode_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateInputNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateInputNode_result)
CreateInputNode_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateInputNode_Out, None], None, ),  # 0
)


class CreateHeightfieldInputNode_args(object):
    """
    Attributes:
     - parent_node_id
     - name
     - xsize
     - ysize
     - voxelsize

    """


    def __init__(self, parent_node_id=None, name=None, xsize=None, ysize=None, voxelsize=None,):
        self.parent_node_id = parent_node_id
        self.name = name
        self.xsize = xsize
        self.ysize = ysize
        self.voxelsize = voxelsize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.xsize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ysize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.voxelsize = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputNode_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.xsize is not None:
            oprot.writeFieldBegin('xsize', TType.I32, 3)
            oprot.writeI32(self.xsize)
            oprot.writeFieldEnd()
        if self.ysize is not None:
            oprot.writeFieldBegin('ysize', TType.I32, 4)
            oprot.writeI32(self.ysize)
            oprot.writeFieldEnd()
        if self.voxelsize is not None:
            oprot.writeFieldBegin('voxelsize', TType.DOUBLE, 5)
            oprot.writeDouble(self.voxelsize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightfieldInputNode_args)
CreateHeightfieldInputNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'xsize', None, None, ),  # 3
    (4, TType.I32, 'ysize', None, None, ),  # 4
    (5, TType.DOUBLE, 'voxelsize', None, None, ),  # 5
)


class CreateHeightfieldInputNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateHeightfieldInputNode_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightfieldInputNode_result)
CreateHeightfieldInputNode_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateHeightfieldInputNode_Out, None], None, ),  # 0
)


class CreateHeightFieldInput_args(object):
    """
    Attributes:
     - parent_node_id
     - name
     - xsize
     - ysize
     - voxelsize
     - sampling

    """


    def __init__(self, parent_node_id=None, name=None, xsize=None, ysize=None, voxelsize=None, sampling=None,):
        self.parent_node_id = parent_node_id
        self.name = name
        self.xsize = xsize
        self.ysize = ysize
        self.voxelsize = voxelsize
        self.sampling = sampling

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.xsize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ysize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.voxelsize = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sampling = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightFieldInput_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.xsize is not None:
            oprot.writeFieldBegin('xsize', TType.I32, 3)
            oprot.writeI32(self.xsize)
            oprot.writeFieldEnd()
        if self.ysize is not None:
            oprot.writeFieldBegin('ysize', TType.I32, 4)
            oprot.writeI32(self.ysize)
            oprot.writeFieldEnd()
        if self.voxelsize is not None:
            oprot.writeFieldBegin('voxelsize', TType.DOUBLE, 5)
            oprot.writeDouble(self.voxelsize)
            oprot.writeFieldEnd()
        if self.sampling is not None:
            oprot.writeFieldBegin('sampling', TType.I32, 6)
            oprot.writeI32(self.sampling)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightFieldInput_args)
CreateHeightFieldInput_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'xsize', None, None, ),  # 3
    (4, TType.I32, 'ysize', None, None, ),  # 4
    (5, TType.DOUBLE, 'voxelsize', None, None, ),  # 5
    (6, TType.I32, 'sampling', None, None, ),  # 6
)


class CreateHeightFieldInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateHeightFieldInput_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightFieldInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightFieldInput_result)
CreateHeightFieldInput_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateHeightFieldInput_Out, None], None, ),  # 0
)


class CreateHeightfieldInputVolumeNode_args(object):
    """
    Attributes:
     - parent_node_id
     - name
     - xsize
     - ysize
     - voxelsize

    """


    def __init__(self, parent_node_id=None, name=None, xsize=None, ysize=None, voxelsize=None,):
        self.parent_node_id = parent_node_id
        self.name = name
        self.xsize = xsize
        self.ysize = ysize
        self.voxelsize = voxelsize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.xsize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ysize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.voxelsize = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputVolumeNode_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.xsize is not None:
            oprot.writeFieldBegin('xsize', TType.I32, 3)
            oprot.writeI32(self.xsize)
            oprot.writeFieldEnd()
        if self.ysize is not None:
            oprot.writeFieldBegin('ysize', TType.I32, 4)
            oprot.writeI32(self.ysize)
            oprot.writeFieldEnd()
        if self.voxelsize is not None:
            oprot.writeFieldBegin('voxelsize', TType.DOUBLE, 5)
            oprot.writeDouble(self.voxelsize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightfieldInputVolumeNode_args)
CreateHeightfieldInputVolumeNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'xsize', None, None, ),  # 3
    (4, TType.I32, 'ysize', None, None, ),  # 4
    (5, TType.DOUBLE, 'voxelsize', None, None, ),  # 5
)


class CreateHeightfieldInputVolumeNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateHeightfieldInputVolumeNode_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateHeightfieldInputVolumeNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateHeightfieldInputVolumeNode_result)
CreateHeightfieldInputVolumeNode_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateHeightfieldInputVolumeNode_Out, None], None, ),  # 0
)


class CookNode_args(object):
    """
    Attributes:
     - node_id
     - cook_options

    """


    def __init__(self, node_id=None, cook_options=None,):
        self.node_id = node_id
        self.cook_options = cook_options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.cook_options = CookOptions()
                    self.cook_options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CookNode_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.cook_options is not None:
            oprot.writeFieldBegin('cook_options', TType.STRUCT, 2)
            self.cook_options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CookNode_args)
CookNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'cook_options', [CookOptions, None], None, ),  # 2
)


class CookNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CookNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CookNode_result)
CookNode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class DeleteNode_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteNode_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteNode_args)
DeleteNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class DeleteNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteNode_result)
DeleteNode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RenameNode_args(object):
    """
    Attributes:
     - node_id
     - new_name

    """


    def __init__(self, node_id=None, new_name=None,):
        self.node_id = node_id
        self.new_name = new_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.new_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenameNode_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.new_name is not None:
            oprot.writeFieldBegin('new_name', TType.STRING, 2)
            oprot.writeString(self.new_name.encode('utf-8') if sys.version_info[0] == 2 else self.new_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenameNode_args)
RenameNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'new_name', 'UTF8', None, ),  # 2
)


class RenameNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenameNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenameNode_result)
RenameNode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class ConnectNodeInput_args(object):
    """
    Attributes:
     - node_id
     - input_index
     - node_id_to_connect
     - output_index

    """


    def __init__(self, node_id=None, input_index=None, node_id_to_connect=None, output_index=None,):
        self.node_id = node_id
        self.input_index = input_index
        self.node_id_to_connect = node_id_to_connect
        self.output_index = output_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.input_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_id_to_connect = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.output_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectNodeInput_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.input_index is not None:
            oprot.writeFieldBegin('input_index', TType.I32, 2)
            oprot.writeI32(self.input_index)
            oprot.writeFieldEnd()
        if self.node_id_to_connect is not None:
            oprot.writeFieldBegin('node_id_to_connect', TType.I32, 3)
            oprot.writeI32(self.node_id_to_connect)
            oprot.writeFieldEnd()
        if self.output_index is not None:
            oprot.writeFieldBegin('output_index', TType.I32, 4)
            oprot.writeI32(self.output_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConnectNodeInput_args)
ConnectNodeInput_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'input_index', None, None, ),  # 2
    (3, TType.I32, 'node_id_to_connect', None, None, ),  # 3
    (4, TType.I32, 'output_index', None, None, ),  # 4
)


class ConnectNodeInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectNodeInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ConnectNodeInput_result)
ConnectNodeInput_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class DisconnectNodeInput_args(object):
    """
    Attributes:
     - node_id
     - input_index

    """


    def __init__(self, node_id=None, input_index=None,):
        self.node_id = node_id
        self.input_index = input_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.input_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DisconnectNodeInput_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.input_index is not None:
            oprot.writeFieldBegin('input_index', TType.I32, 2)
            oprot.writeI32(self.input_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DisconnectNodeInput_args)
DisconnectNodeInput_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'input_index', None, None, ),  # 2
)


class DisconnectNodeInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DisconnectNodeInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DisconnectNodeInput_result)
DisconnectNodeInput_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class QueryNodeInput_args(object):
    """
    Attributes:
     - node_to_query
     - input_index

    """


    def __init__(self, node_to_query=None, input_index=None,):
        self.node_to_query = node_to_query
        self.input_index = input_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_to_query = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.input_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeInput_args')
        if self.node_to_query is not None:
            oprot.writeFieldBegin('node_to_query', TType.I32, 1)
            oprot.writeI32(self.node_to_query)
            oprot.writeFieldEnd()
        if self.input_index is not None:
            oprot.writeFieldBegin('input_index', TType.I32, 2)
            oprot.writeI32(self.input_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeInput_args)
QueryNodeInput_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_to_query', None, None, ),  # 1
    (2, TType.I32, 'input_index', None, None, ),  # 2
)


class QueryNodeInput_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryNodeInput_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeInput_result)
QueryNodeInput_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [QueryNodeInput_Out, None], None, ),  # 0
)


class GetNodeInputName_args(object):
    """
    Attributes:
     - node_id
     - input_idx

    """


    def __init__(self, node_id=None, input_idx=None,):
        self.node_id = node_id
        self.input_idx = input_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.input_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInputName_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.input_idx is not None:
            oprot.writeFieldBegin('input_idx', TType.I32, 2)
            oprot.writeI32(self.input_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeInputName_args)
GetNodeInputName_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'input_idx', None, None, ),  # 2
)


class GetNodeInputName_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNodeInputName_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeInputName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeInputName_result)
GetNodeInputName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNodeInputName_Out, None], None, ),  # 0
)


class DisconnectNodeOutputsAt_args(object):
    """
    Attributes:
     - node_id
     - output_index

    """


    def __init__(self, node_id=None, output_index=None,):
        self.node_id = node_id
        self.output_index = output_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DisconnectNodeOutputsAt_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.output_index is not None:
            oprot.writeFieldBegin('output_index', TType.I32, 2)
            oprot.writeI32(self.output_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DisconnectNodeOutputsAt_args)
DisconnectNodeOutputsAt_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'output_index', None, None, ),  # 2
)


class DisconnectNodeOutputsAt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DisconnectNodeOutputsAt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DisconnectNodeOutputsAt_result)
DisconnectNodeOutputsAt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class QueryNodeOutputConnectedCount_args(object):
    """
    Attributes:
     - node_id
     - output_idx
     - into_subnets
     - through_dots

    """


    def __init__(self, node_id=None, output_idx=None, into_subnets=None, through_dots=None,):
        self.node_id = node_id
        self.output_idx = output_idx
        self.into_subnets = into_subnets
        self.through_dots = through_dots

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.into_subnets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.through_dots = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedCount_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.output_idx is not None:
            oprot.writeFieldBegin('output_idx', TType.I32, 2)
            oprot.writeI32(self.output_idx)
            oprot.writeFieldEnd()
        if self.into_subnets is not None:
            oprot.writeFieldBegin('into_subnets', TType.BOOL, 3)
            oprot.writeBool(self.into_subnets)
            oprot.writeFieldEnd()
        if self.through_dots is not None:
            oprot.writeFieldBegin('through_dots', TType.BOOL, 4)
            oprot.writeBool(self.through_dots)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeOutputConnectedCount_args)
QueryNodeOutputConnectedCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'output_idx', None, None, ),  # 2
    (3, TType.BOOL, 'into_subnets', None, None, ),  # 3
    (4, TType.BOOL, 'through_dots', None, None, ),  # 4
)


class QueryNodeOutputConnectedCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryNodeOutputConnectedCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeOutputConnectedCount_result)
QueryNodeOutputConnectedCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [QueryNodeOutputConnectedCount_Out, None], None, ),  # 0
)


class QueryNodeOutputConnectedNodes_args(object):
    """
    Attributes:
     - node_id
     - output_idx
     - into_subnets
     - through_dots
     - start
     - length

    """


    def __init__(self, node_id=None, output_idx=None, into_subnets=None, through_dots=None, start=None, length=None,):
        self.node_id = node_id
        self.output_idx = output_idx
        self.into_subnets = into_subnets
        self.through_dots = through_dots
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.into_subnets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.through_dots = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedNodes_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.output_idx is not None:
            oprot.writeFieldBegin('output_idx', TType.I32, 2)
            oprot.writeI32(self.output_idx)
            oprot.writeFieldEnd()
        if self.into_subnets is not None:
            oprot.writeFieldBegin('into_subnets', TType.BOOL, 3)
            oprot.writeBool(self.into_subnets)
            oprot.writeFieldEnd()
        if self.through_dots is not None:
            oprot.writeFieldBegin('through_dots', TType.BOOL, 4)
            oprot.writeBool(self.through_dots)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 6)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeOutputConnectedNodes_args)
QueryNodeOutputConnectedNodes_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'output_idx', None, None, ),  # 2
    (3, TType.BOOL, 'into_subnets', None, None, ),  # 3
    (4, TType.BOOL, 'through_dots', None, None, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
    (6, TType.I32, 'length', None, None, ),  # 6
)


class QueryNodeOutputConnectedNodes_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryNodeOutputConnectedNodes_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryNodeOutputConnectedNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(QueryNodeOutputConnectedNodes_result)
QueryNodeOutputConnectedNodes_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [QueryNodeOutputConnectedNodes_Out, None], None, ),  # 0
)


class GetNodeOutputName_args(object):
    """
    Attributes:
     - node_id
     - output_idx

    """


    def __init__(self, node_id=None, output_idx=None,):
        self.node_id = node_id
        self.output_idx = output_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeOutputName_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.output_idx is not None:
            oprot.writeFieldBegin('output_idx', TType.I32, 2)
            oprot.writeI32(self.output_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeOutputName_args)
GetNodeOutputName_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'output_idx', None, None, ),  # 2
)


class GetNodeOutputName_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNodeOutputName_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNodeOutputName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNodeOutputName_result)
GetNodeOutputName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNodeOutputName_Out, None], None, ),  # 0
)


class GetParameters_args(object):
    """
    Attributes:
     - node_id
     - start
     - length

    """


    def __init__(self, node_id=None, start=None, length=None,):
        self.node_id = node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParameters_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParameters_args)
GetParameters_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetParameters_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParameters_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParameters_result)
GetParameters_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParameters_Out, None], None, ),  # 0
)


class GetParmInfo_args(object):
    """
    Attributes:
     - node_id
     - parm_id

    """


    def __init__(self, node_id=None, parm_id=None,):
        self.node_id = node_id
        self.parm_id = parm_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmInfo_args)
GetParmInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
)


class GetParmInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmInfo_result)
GetParmInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmInfo_Out, None], None, ),  # 0
)


class GetParmIdFromName_args(object):
    """
    Attributes:
     - node_id
     - parm_name

    """


    def __init__(self, node_id=None, parm_name=None,):
        self.node_id = node_id
        self.parm_name = parm_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIdFromName_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIdFromName_args)
GetParmIdFromName_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
)


class GetParmIdFromName_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmIdFromName_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIdFromName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIdFromName_result)
GetParmIdFromName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmIdFromName_Out, None], None, ),  # 0
)


class GetParmInfoFromName_args(object):
    """
    Attributes:
     - node_id
     - parm_name

    """


    def __init__(self, node_id=None, parm_name=None,):
        self.node_id = node_id
        self.parm_name = parm_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfoFromName_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmInfoFromName_args)
GetParmInfoFromName_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
)


class GetParmInfoFromName_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmInfoFromName_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmInfoFromName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmInfoFromName_result)
GetParmInfoFromName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmInfoFromName_Out, None], None, ),  # 0
)


class GetParmTagName_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - tag_index

    """


    def __init__(self, node_id=None, parm_id=None, tag_index=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.tag_index = tag_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tag_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagName_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.tag_index is not None:
            oprot.writeFieldBegin('tag_index', TType.I32, 3)
            oprot.writeI32(self.tag_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmTagName_args)
GetParmTagName_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.I32, 'tag_index', None, None, ),  # 3
)


class GetParmTagName_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmTagName_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmTagName_result)
GetParmTagName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmTagName_Out, None], None, ),  # 0
)


class GetParmTagValue_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - tag_name

    """


    def __init__(self, node_id=None, parm_id=None, tag_name=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.tag_name = tag_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tag_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.tag_name is not None:
            oprot.writeFieldBegin('tag_name', TType.STRING, 3)
            oprot.writeString(self.tag_name.encode('utf-8') if sys.version_info[0] == 2 else self.tag_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmTagValue_args)
GetParmTagValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.STRING, 'tag_name', 'UTF8', None, ),  # 3
)


class GetParmTagValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmTagValue_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmTagValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmTagValue_result)
GetParmTagValue_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmTagValue_Out, None], None, ),  # 0
)


class ParmHasTag_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - tag_name

    """


    def __init__(self, node_id=None, parm_id=None, tag_name=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.tag_name = tag_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tag_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasTag_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.tag_name is not None:
            oprot.writeFieldBegin('tag_name', TType.STRING, 3)
            oprot.writeString(self.tag_name.encode('utf-8') if sys.version_info[0] == 2 else self.tag_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ParmHasTag_args)
ParmHasTag_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.STRING, 'tag_name', 'UTF8', None, ),  # 3
)


class ParmHasTag_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ParmHasTag_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ParmHasTag_result)
ParmHasTag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ParmHasTag_Out, None], None, ),  # 0
)


class ParmHasExpression_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index

    """


    def __init__(self, node_id=None, parm_name=None, index=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasExpression_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ParmHasExpression_args)
ParmHasExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class ParmHasExpression_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ParmHasExpression_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParmHasExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ParmHasExpression_result)
ParmHasExpression_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ParmHasExpression_Out, None], None, ),  # 0
)


class GetParmWithTag_args(object):
    """
    Attributes:
     - node_id
     - tag_name

    """


    def __init__(self, node_id=None, tag_name=None,):
        self.node_id = node_id
        self.tag_name = tag_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmWithTag_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.tag_name is not None:
            oprot.writeFieldBegin('tag_name', TType.STRING, 2)
            oprot.writeString(self.tag_name.encode('utf-8') if sys.version_info[0] == 2 else self.tag_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmWithTag_args)
GetParmWithTag_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'tag_name', 'UTF8', None, ),  # 2
)


class GetParmWithTag_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmWithTag_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmWithTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmWithTag_result)
GetParmWithTag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmWithTag_Out, None], None, ),  # 0
)


class GetParmExpression_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index

    """


    def __init__(self, node_id=None, parm_name=None, index=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmExpression_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmExpression_args)
GetParmExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class GetParmExpression_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmExpression_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmExpression_result)
GetParmExpression_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmExpression_Out, None], None, ),  # 0
)


class RevertParmToDefault_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index

    """


    def __init__(self, node_id=None, parm_name=None, index=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertParmToDefault_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertParmToDefault_args)
RevertParmToDefault_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class RevertParmToDefault_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertParmToDefault_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertParmToDefault_result)
RevertParmToDefault_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RevertParmToDefaults_args(object):
    """
    Attributes:
     - node_id
     - parm_name

    """


    def __init__(self, node_id=None, parm_name=None,):
        self.node_id = node_id
        self.parm_name = parm_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertParmToDefaults_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertParmToDefaults_args)
RevertParmToDefaults_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
)


class RevertParmToDefaults_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertParmToDefaults_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertParmToDefaults_result)
RevertParmToDefaults_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmExpression_args(object):
    """
    Attributes:
     - node_id
     - value
     - parm_id
     - index

    """


    def __init__(self, node_id=None, value=None, parm_id=None, index=None,):
        self.node_id = node_id
        self.value = value
        self.parm_id = parm_id
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmExpression_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 3)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmExpression_args)
SetParmExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.I32, 'parm_id', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)


class SetParmExpression_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmExpression_result)
SetParmExpression_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RemoveParmExpression_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - index

    """


    def __init__(self, node_id=None, parm_id=None, index=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveParmExpression_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveParmExpression_args)
RemoveParmExpression_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class RemoveParmExpression_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveParmExpression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveParmExpression_result)
RemoveParmExpression_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetParmIntValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index

    """


    def __init__(self, node_id=None, parm_name=None, index=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIntValue_args)
GetParmIntValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class GetParmIntValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmIntValue_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIntValue_result)
GetParmIntValue_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmIntValue_Out, None], None, ),  # 0
)


class GetParmIntValues_args(object):
    """
    Attributes:
     - node_id
     - start
     - length

    """


    def __init__(self, node_id=None, start=None, length=None,):
        self.node_id = node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValues_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIntValues_args)
GetParmIntValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetParmIntValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmIntValues_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmIntValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmIntValues_result)
GetParmIntValues_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmIntValues_Out, None], None, ),  # 0
)


class GetParmFloatValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index

    """


    def __init__(self, node_id=None, parm_name=None, index=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFloatValue_args)
GetParmFloatValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class GetParmFloatValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmFloatValue_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFloatValue_result)
GetParmFloatValue_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmFloatValue_Out, None], None, ),  # 0
)


class GetParmFloatValues_args(object):
    """
    Attributes:
     - node_id
     - start
     - length

    """


    def __init__(self, node_id=None, start=None, length=None,):
        self.node_id = node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValues_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFloatValues_args)
GetParmFloatValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetParmFloatValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmFloatValues_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFloatValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFloatValues_result)
GetParmFloatValues_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmFloatValues_Out, None], None, ),  # 0
)


class GetParmStringValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index
     - evaluate

    """


    def __init__(self, node_id=None, parm_name=None, index=None, evaluate=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index
        self.evaluate = evaluate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.evaluate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.evaluate is not None:
            oprot.writeFieldBegin('evaluate', TType.BOOL, 4)
            oprot.writeBool(self.evaluate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmStringValue_args)
GetParmStringValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
    (4, TType.BOOL, 'evaluate', None, None, ),  # 4
)


class GetParmStringValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmStringValue_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmStringValue_result)
GetParmStringValue_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmStringValue_Out, None], None, ),  # 0
)


class GetParmStringValues_args(object):
    """
    Attributes:
     - node_id
     - evaluate
     - start
     - length

    """


    def __init__(self, node_id=None, evaluate=None, start=None, length=None,):
        self.node_id = node_id
        self.evaluate = evaluate
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.evaluate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValues_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.evaluate is not None:
            oprot.writeFieldBegin('evaluate', TType.BOOL, 2)
            oprot.writeBool(self.evaluate)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmStringValues_args)
GetParmStringValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.BOOL, 'evaluate', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetParmStringValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmStringValues_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmStringValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmStringValues_result)
GetParmStringValues_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmStringValues_Out, None], None, ),  # 0
)


class GetParmNodeValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name

    """


    def __init__(self, node_id=None, parm_name=None,):
        self.node_id = node_id
        self.parm_name = parm_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmNodeValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmNodeValue_args)
GetParmNodeValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
)


class GetParmNodeValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmNodeValue_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmNodeValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmNodeValue_result)
GetParmNodeValue_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmNodeValue_Out, None], None, ),  # 0
)


class GetParmFile_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - destination_directory
     - destination_file_name

    """


    def __init__(self, node_id=None, parm_name=None, destination_directory=None, destination_file_name=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.destination_directory = destination_directory
        self.destination_file_name = destination_file_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.destination_directory = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.destination_file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.destination_directory is not None:
            oprot.writeFieldBegin('destination_directory', TType.STRING, 3)
            oprot.writeString(self.destination_directory.encode('utf-8') if sys.version_info[0] == 2 else self.destination_directory)
            oprot.writeFieldEnd()
        if self.destination_file_name is not None:
            oprot.writeFieldBegin('destination_file_name', TType.STRING, 4)
            oprot.writeString(self.destination_file_name.encode('utf-8') if sys.version_info[0] == 2 else self.destination_file_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFile_args)
GetParmFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'destination_directory', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'destination_file_name', 'UTF8', None, ),  # 4
)


class GetParmFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmFile_result)
GetParmFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetParmChoiceLists_args(object):
    """
    Attributes:
     - node_id
     - start
     - length

    """


    def __init__(self, node_id=None, start=None, length=None,):
        self.node_id = node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmChoiceLists_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmChoiceLists_args)
GetParmChoiceLists_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetParmChoiceLists_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetParmChoiceLists_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetParmChoiceLists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetParmChoiceLists_result)
GetParmChoiceLists_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetParmChoiceLists_Out, None], None, ),  # 0
)


class SetParmIntValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index
     - value

    """


    def __init__(self, node_id=None, parm_name=None, index=None, value=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmIntValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmIntValue_args)
SetParmIntValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
)


class SetParmIntValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmIntValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmIntValue_result)
SetParmIntValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmIntValues_args(object):
    """
    Attributes:
     - node_id
     - values_array
     - start

    """


    def __init__(self, node_id=None, values_array=None, start=None,):
        self.node_id = node_id
        self.values_array = values_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readI32()
                        self.values_array.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmIntValues_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter531 in self.values_array:
                oprot.writeI32(iter531)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmIntValues_args)
SetParmIntValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
)


class SetParmIntValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmIntValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmIntValues_result)
SetParmIntValues_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmFloatValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - index
     - value

    """


    def __init__(self, node_id=None, parm_name=None, index=None, value=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmFloatValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 4)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmFloatValue_args)
SetParmFloatValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
    (4, TType.DOUBLE, 'value', None, None, ),  # 4
)


class SetParmFloatValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmFloatValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmFloatValue_result)
SetParmFloatValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmFloatValues_args(object):
    """
    Attributes:
     - node_id
     - values_array
     - start

    """


    def __init__(self, node_id=None, values_array=None, start=None,):
        self.node_id = node_id
        self.values_array = values_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = iprot.readDouble()
                        self.values_array.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmFloatValues_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter538 in self.values_array:
                oprot.writeDouble(iter538)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmFloatValues_args)
SetParmFloatValues_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
)


class SetParmFloatValues_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmFloatValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmFloatValues_result)
SetParmFloatValues_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmStringValue_args(object):
    """
    Attributes:
     - node_id
     - value
     - parm_id
     - index

    """


    def __init__(self, node_id=None, value=None, parm_id=None, index=None,):
        self.node_id = node_id
        self.value = value
        self.parm_id = parm_id
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmStringValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 3)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmStringValue_args)
SetParmStringValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.I32, 'parm_id', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)


class SetParmStringValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmStringValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmStringValue_result)
SetParmStringValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetParmNodeValue_args(object):
    """
    Attributes:
     - node_id
     - parm_name
     - value

    """


    def __init__(self, node_id=None, parm_name=None, value=None,):
        self.node_id = node_id
        self.parm_name = parm_name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parm_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmNodeValue_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_name is not None:
            oprot.writeFieldBegin('parm_name', TType.STRING, 2)
            oprot.writeString(self.parm_name.encode('utf-8') if sys.version_info[0] == 2 else self.parm_name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 3)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmNodeValue_args)
SetParmNodeValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'parm_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'value', None, None, ),  # 3
)


class SetParmNodeValue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetParmNodeValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetParmNodeValue_result)
SetParmNodeValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class InsertMultiparmInstance_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - instance_position

    """


    def __init__(self, node_id=None, parm_id=None, instance_position=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.instance_position = instance_position

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.instance_position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertMultiparmInstance_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.instance_position is not None:
            oprot.writeFieldBegin('instance_position', TType.I32, 3)
            oprot.writeI32(self.instance_position)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InsertMultiparmInstance_args)
InsertMultiparmInstance_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.I32, 'instance_position', None, None, ),  # 3
)


class InsertMultiparmInstance_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertMultiparmInstance_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InsertMultiparmInstance_result)
InsertMultiparmInstance_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RemoveMultiparmInstance_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - instance_position

    """


    def __init__(self, node_id=None, parm_id=None, instance_position=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.instance_position = instance_position

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.instance_position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveMultiparmInstance_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.instance_position is not None:
            oprot.writeFieldBegin('instance_position', TType.I32, 3)
            oprot.writeI32(self.instance_position)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveMultiparmInstance_args)
RemoveMultiparmInstance_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.I32, 'instance_position', None, None, ),  # 3
)


class RemoveMultiparmInstance_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemoveMultiparmInstance_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RemoveMultiparmInstance_result)
RemoveMultiparmInstance_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetHandleInfo_args(object):
    """
    Attributes:
     - node_id
     - start
     - length

    """


    def __init__(self, node_id=None, start=None, length=None,):
        self.node_id = node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHandleInfo_args)
GetHandleInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetHandleInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetHandleInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHandleInfo_result)
GetHandleInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetHandleInfo_Out, None], None, ),  # 0
)


class GetHandleBindingInfo_args(object):
    """
    Attributes:
     - node_id
     - handle_index
     - start
     - length

    """


    def __init__(self, node_id=None, handle_index=None, start=None, length=None,):
        self.node_id = node_id
        self.handle_index = handle_index
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.handle_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleBindingInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.handle_index is not None:
            oprot.writeFieldBegin('handle_index', TType.I32, 2)
            oprot.writeI32(self.handle_index)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHandleBindingInfo_args)
GetHandleBindingInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'handle_index', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetHandleBindingInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetHandleBindingInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHandleBindingInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHandleBindingInfo_result)
GetHandleBindingInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetHandleBindingInfo_Out, None], None, ),  # 0
)


class GetPresetBufLength_args(object):
    """
    Attributes:
     - node_id
     - preset_type
     - preset_name

    """


    def __init__(self, node_id=None, preset_type=None, preset_name=None,):
        self.node_id = node_id
        self.preset_type = preset_type
        self.preset_name = preset_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.preset_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.preset_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPresetBufLength_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.preset_type is not None:
            oprot.writeFieldBegin('preset_type', TType.I32, 2)
            oprot.writeI32(self.preset_type)
            oprot.writeFieldEnd()
        if self.preset_name is not None:
            oprot.writeFieldBegin('preset_name', TType.STRING, 3)
            oprot.writeString(self.preset_name.encode('utf-8') if sys.version_info[0] == 2 else self.preset_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPresetBufLength_args)
GetPresetBufLength_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'preset_type', None, None, ),  # 2
    (3, TType.STRING, 'preset_name', 'UTF8', None, ),  # 3
)


class GetPresetBufLength_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPresetBufLength_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPresetBufLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPresetBufLength_result)
GetPresetBufLength_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPresetBufLength_Out, None], None, ),  # 0
)


class GetPreset_args(object):
    """
    Attributes:
     - node_id
     - buffer_length

    """


    def __init__(self, node_id=None, buffer_length=None,):
        self.node_id = node_id
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPreset_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 2)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPreset_args)
GetPreset_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'buffer_length', None, None, ),  # 2
)


class GetPreset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPreset_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPreset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPreset_result)
GetPreset_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPreset_Out, None], None, ),  # 0
)


class SetPreset_args(object):
    """
    Attributes:
     - node_id
     - preset_type
     - preset_name
     - buffer
     - buffer_length

    """


    def __init__(self, node_id=None, preset_type=None, preset_name=None, buffer=None, buffer_length=None,):
        self.node_id = node_id
        self.preset_type = preset_type
        self.preset_name = preset_name
        self.buffer = buffer
        self.buffer_length = buffer_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.preset_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.preset_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.buffer_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetPreset_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.preset_type is not None:
            oprot.writeFieldBegin('preset_type', TType.I32, 2)
            oprot.writeI32(self.preset_type)
            oprot.writeFieldEnd()
        if self.preset_name is not None:
            oprot.writeFieldBegin('preset_name', TType.STRING, 3)
            oprot.writeString(self.preset_name.encode('utf-8') if sys.version_info[0] == 2 else self.preset_name)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 4)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        if self.buffer_length is not None:
            oprot.writeFieldBegin('buffer_length', TType.I32, 5)
            oprot.writeI32(self.buffer_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetPreset_args)
SetPreset_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'preset_type', None, None, ),  # 2
    (3, TType.STRING, 'preset_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'buffer', 'BINARY', None, ),  # 4
    (5, TType.I32, 'buffer_length', None, None, ),  # 5
)


class SetPreset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetPreset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetPreset_result)
SetPreset_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetObjectInfo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetObjectInfo_args)
GetObjectInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class GetObjectInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetObjectInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetObjectInfo_result)
GetObjectInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetObjectInfo_Out, None], None, ),  # 0
)


class GetObjectTransform_args(object):
    """
    Attributes:
     - node_id
     - relative_to_node_id
     - rst_order

    """


    def __init__(self, node_id=None, relative_to_node_id=None, rst_order=None,):
        self.node_id = node_id
        self.relative_to_node_id = relative_to_node_id
        self.rst_order = rst_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.relative_to_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectTransform_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.relative_to_node_id is not None:
            oprot.writeFieldBegin('relative_to_node_id', TType.I32, 2)
            oprot.writeI32(self.relative_to_node_id)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 3)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetObjectTransform_args)
GetObjectTransform_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'relative_to_node_id', None, None, ),  # 2
    (3, TType.I32, 'rst_order', None, None, ),  # 3
)


class GetObjectTransform_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetObjectTransform_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetObjectTransform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetObjectTransform_result)
GetObjectTransform_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetObjectTransform_Out, None], None, ),  # 0
)


class ComposeObjectList_args(object):
    """
    Attributes:
     - parent_node_id
     - categories

    """


    def __init__(self, parent_node_id=None, categories=None,):
        self.parent_node_id = parent_node_id
        self.categories = categories

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.categories = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeObjectList_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.categories is not None:
            oprot.writeFieldBegin('categories', TType.STRING, 2)
            oprot.writeString(self.categories.encode('utf-8') if sys.version_info[0] == 2 else self.categories)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeObjectList_args)
ComposeObjectList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.STRING, 'categories', 'UTF8', None, ),  # 2
)


class ComposeObjectList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ComposeObjectList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ComposeObjectList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ComposeObjectList_result)
ComposeObjectList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ComposeObjectList_Out, None], None, ),  # 0
)


class GetComposedObjectList_args(object):
    """
    Attributes:
     - parent_node_id
     - start
     - length

    """


    def __init__(self, parent_node_id=None, start=None, length=None,):
        self.parent_node_id = parent_node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectList_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedObjectList_args)
GetComposedObjectList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetComposedObjectList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetComposedObjectList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedObjectList_result)
GetComposedObjectList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetComposedObjectList_Out, None], None, ),  # 0
)


class GetComposedObjectTransforms_args(object):
    """
    Attributes:
     - parent_node_id
     - rst_order
     - start
     - length

    """


    def __init__(self, parent_node_id=None, rst_order=None, start=None, length=None,):
        self.parent_node_id = parent_node_id
        self.rst_order = rst_order
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectTransforms_args')
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 1)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 2)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedObjectTransforms_args)
GetComposedObjectTransforms_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parent_node_id', None, None, ),  # 1
    (2, TType.I32, 'rst_order', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetComposedObjectTransforms_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetComposedObjectTransforms_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetComposedObjectTransforms_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetComposedObjectTransforms_result)
GetComposedObjectTransforms_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetComposedObjectTransforms_Out, None], None, ),  # 0
)


class GetInstancedObjectIds_args(object):
    """
    Attributes:
     - object_node_id
     - start
     - length

    """


    def __init__(self, object_node_id=None, start=None, length=None,):
        self.object_node_id = object_node_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.object_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedObjectIds_args')
        if self.object_node_id is not None:
            oprot.writeFieldBegin('object_node_id', TType.I32, 1)
            oprot.writeI32(self.object_node_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancedObjectIds_args)
GetInstancedObjectIds_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'object_node_id', None, None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class GetInstancedObjectIds_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetInstancedObjectIds_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedObjectIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancedObjectIds_result)
GetInstancedObjectIds_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetInstancedObjectIds_Out, None], None, ),  # 0
)


class GetInstanceTransforms_args(object):
    """
    Attributes:
     - object_node_id
     - rst_order
     - start
     - length

    """


    def __init__(self, object_node_id=None, rst_order=None, start=None, length=None,):
        self.object_node_id = object_node_id
        self.rst_order = rst_order
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.object_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransforms_args')
        if self.object_node_id is not None:
            oprot.writeFieldBegin('object_node_id', TType.I32, 1)
            oprot.writeI32(self.object_node_id)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 2)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstanceTransforms_args)
GetInstanceTransforms_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'object_node_id', None, None, ),  # 1
    (2, TType.I32, 'rst_order', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetInstanceTransforms_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetInstanceTransforms_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransforms_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstanceTransforms_result)
GetInstanceTransforms_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetInstanceTransforms_Out, None], None, ),  # 0
)


class GetInstanceTransformsOnPart_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - rst_order
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, rst_order=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.rst_order = rst_order
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransformsOnPart_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 3)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 5)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstanceTransformsOnPart_args)
GetInstanceTransformsOnPart_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'rst_order', None, None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
    (5, TType.I32, 'length', None, None, ),  # 5
)


class GetInstanceTransformsOnPart_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetInstanceTransformsOnPart_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstanceTransformsOnPart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstanceTransformsOnPart_result)
GetInstanceTransformsOnPart_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetInstanceTransformsOnPart_Out, None], None, ),  # 0
)


class SetObjectTransform_args(object):
    """
    Attributes:
     - node_id
     - trans

    """


    def __init__(self, node_id=None, trans=None,):
        self.node_id = node_id
        self.trans = trans

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.trans = TransformEuler()
                    self.trans.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetObjectTransform_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.trans is not None:
            oprot.writeFieldBegin('trans', TType.STRUCT, 2)
            self.trans.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetObjectTransform_args)
SetObjectTransform_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'trans', [TransformEuler, None], None, ),  # 2
)


class SetObjectTransform_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetObjectTransform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetObjectTransform_result)
SetObjectTransform_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetDisplayGeoInfo_args(object):
    """
    Attributes:
     - object_node_id

    """


    def __init__(self, object_node_id=None,):
        self.object_node_id = object_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.object_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDisplayGeoInfo_args')
        if self.object_node_id is not None:
            oprot.writeFieldBegin('object_node_id', TType.I32, 1)
            oprot.writeI32(self.object_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDisplayGeoInfo_args)
GetDisplayGeoInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'object_node_id', None, None, ),  # 1
)


class GetDisplayGeoInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetDisplayGeoInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDisplayGeoInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDisplayGeoInfo_result)
GetDisplayGeoInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetDisplayGeoInfo_Out, None], None, ),  # 0
)


class GetGeoInfo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGeoInfo_args)
GetGeoInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class GetGeoInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGeoInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGeoInfo_result)
GetGeoInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGeoInfo_Out, None], None, ),  # 0
)


class GetPartInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPartInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPartInfo_args)
GetPartInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetPartInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPartInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPartInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPartInfo_result)
GetPartInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPartInfo_Out, None], None, ),  # 0
)


class GetFaceCounts_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFaceCounts_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFaceCounts_args)
GetFaceCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetFaceCounts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFaceCounts_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFaceCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFaceCounts_result)
GetFaceCounts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetFaceCounts_Out, None], None, ),  # 0
)


class GetVertexList_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVertexList_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVertexList_args)
GetVertexList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetVertexList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVertexList_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVertexList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVertexList_result)
GetVertexList_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVertexList_Out, None], None, ),  # 0
)


class GetAttributeInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - owner

    """


    def __init__(self, node_id=None, part_id=None, name=None, owner=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.owner = owner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.owner = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.I32, 4)
            oprot.writeI32(self.owner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeInfo_args)
GetAttributeInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'owner', None, None, ),  # 4
)


class GetAttributeInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeInfo_result)
GetAttributeInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeInfo_Out, None], None, ),  # 0
)


class GetAttributeNames_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - owner
     - count

    """


    def __init__(self, node_id=None, part_id=None, owner=None, count=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.owner = owner
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.owner = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeNames_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.I32, 3)
            oprot.writeI32(self.owner)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeNames_args)
GetAttributeNames_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'owner', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
)


class GetAttributeNames_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeNames_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeNames_result)
GetAttributeNames_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeNames_Out, None], None, ),  # 0
)


class GetAttributeIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - stride
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, stride=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.stride = stride
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.stride is not None:
            oprot.writeFieldBegin('stride', TType.I32, 5)
            oprot.writeI32(self.stride)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 7)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeIntData_args)
GetAttributeIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.I32, 'stride', None, None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
    (7, TType.I32, 'length', None, None, ),  # 7
)


class GetAttributeIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeIntData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeIntData_result)
GetAttributeIntData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeIntData_Out, None], None, ),  # 0
)


class GetAttributeInt64Data_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - stride
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, stride=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.stride = stride
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInt64Data_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.stride is not None:
            oprot.writeFieldBegin('stride', TType.I32, 5)
            oprot.writeI32(self.stride)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 7)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeInt64Data_args)
GetAttributeInt64Data_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.I32, 'stride', None, None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
    (7, TType.I32, 'length', None, None, ),  # 7
)


class GetAttributeInt64Data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeInt64Data_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeInt64Data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeInt64Data_result)
GetAttributeInt64Data_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeInt64Data_Out, None], None, ),  # 0
)


class GetAttributeFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - stride
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, stride=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.stride = stride
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.stride is not None:
            oprot.writeFieldBegin('stride', TType.I32, 5)
            oprot.writeI32(self.stride)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 7)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeFloatData_args)
GetAttributeFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.I32, 'stride', None, None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
    (7, TType.I32, 'length', None, None, ),  # 7
)


class GetAttributeFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeFloatData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeFloatData_result)
GetAttributeFloatData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeFloatData_Out, None], None, ),  # 0
)


class GetAttributeFloat64Data_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - stride
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, stride=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.stride = stride
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.stride = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloat64Data_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.stride is not None:
            oprot.writeFieldBegin('stride', TType.I32, 5)
            oprot.writeI32(self.stride)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 7)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeFloat64Data_args)
GetAttributeFloat64Data_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.I32, 'stride', None, None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
    (7, TType.I32, 'length', None, None, ),  # 7
)


class GetAttributeFloat64Data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeFloat64Data_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeFloat64Data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeFloat64Data_result)
GetAttributeFloat64Data_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeFloat64Data_Out, None], None, ),  # 0
)


class GetAttributeStringData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeStringData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 6)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeStringData_args)
GetAttributeStringData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
    (6, TType.I32, 'length', None, None, ),  # 6
)


class GetAttributeStringData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAttributeStringData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAttributeStringData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAttributeStringData_result)
GetAttributeStringData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAttributeStringData_Out, None], None, ),  # 0
)


class GetGroupNames_args(object):
    """
    Attributes:
     - node_id
     - group_type
     - group_count

    """


    def __init__(self, node_id=None, group_type=None, group_count=None,):
        self.node_id = node_id
        self.group_type = group_type
        self.group_count = group_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNames_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 2)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_count is not None:
            oprot.writeFieldBegin('group_count', TType.I32, 3)
            oprot.writeI32(self.group_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupNames_args)
GetGroupNames_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'group_type', None, None, ),  # 2
    (3, TType.I32, 'group_count', None, None, ),  # 3
)


class GetGroupNames_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupNames_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupNames_result)
GetGroupNames_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGroupNames_Out, None], None, ),  # 0
)


class GetGroupMembership_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_name
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_name=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_name = group_name
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.group_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembership_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_name is not None:
            oprot.writeFieldBegin('group_name', TType.STRING, 4)
            oprot.writeString(self.group_name.encode('utf-8') if sys.version_info[0] == 2 else self.group_name)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 6)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupMembership_args)
GetGroupMembership_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.STRING, 'group_name', 'UTF8', None, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
    (6, TType.I32, 'length', None, None, ),  # 6
)


class GetGroupMembership_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupMembership_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembership_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupMembership_result)
GetGroupMembership_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGroupMembership_Out, None], None, ),  # 0
)


class GetGroupCountOnPackedInstancePart_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupCountOnPackedInstancePart_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupCountOnPackedInstancePart_args)
GetGroupCountOnPackedInstancePart_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetGroupCountOnPackedInstancePart_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupCountOnPackedInstancePart_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupCountOnPackedInstancePart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupCountOnPackedInstancePart_result)
GetGroupCountOnPackedInstancePart_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGroupCountOnPackedInstancePart_Out, None], None, ),  # 0
)


class GetGroupNamesOnPackedInstancePart_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_count

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_count=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_count = group_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.group_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNamesOnPackedInstancePart_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_count is not None:
            oprot.writeFieldBegin('group_count', TType.I32, 4)
            oprot.writeI32(self.group_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupNamesOnPackedInstancePart_args)
GetGroupNamesOnPackedInstancePart_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.I32, 'group_count', None, None, ),  # 4
)


class GetGroupNamesOnPackedInstancePart_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupNamesOnPackedInstancePart_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupNamesOnPackedInstancePart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupNamesOnPackedInstancePart_result)
GetGroupNamesOnPackedInstancePart_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGroupNamesOnPackedInstancePart_Out, None], None, ),  # 0
)


class GetGroupMembershipOnPackedInstancePart_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_name
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_name=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_name = group_name
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.group_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembershipOnPackedInstancePart_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_name is not None:
            oprot.writeFieldBegin('group_name', TType.STRING, 4)
            oprot.writeString(self.group_name.encode('utf-8') if sys.version_info[0] == 2 else self.group_name)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 6)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupMembershipOnPackedInstancePart_args)
GetGroupMembershipOnPackedInstancePart_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.STRING, 'group_name', 'UTF8', None, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
    (6, TType.I32, 'length', None, None, ),  # 6
)


class GetGroupMembershipOnPackedInstancePart_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupMembershipOnPackedInstancePart_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGroupMembershipOnPackedInstancePart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGroupMembershipOnPackedInstancePart_result)
GetGroupMembershipOnPackedInstancePart_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGroupMembershipOnPackedInstancePart_Out, None], None, ),  # 0
)


class GetInstancedPartIds_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedPartIds_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancedPartIds_args)
GetInstancedPartIds_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetInstancedPartIds_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetInstancedPartIds_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancedPartIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancedPartIds_result)
GetInstancedPartIds_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetInstancedPartIds_Out, None], None, ),  # 0
)


class GetInstancerPartTransforms_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - rst_order
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, rst_order=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.rst_order = rst_order
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rst_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancerPartTransforms_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.rst_order is not None:
            oprot.writeFieldBegin('rst_order', TType.I32, 3)
            oprot.writeI32(self.rst_order)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 5)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancerPartTransforms_args)
GetInstancerPartTransforms_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'rst_order', None, None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
    (5, TType.I32, 'length', None, None, ),  # 5
)


class GetInstancerPartTransforms_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetInstancerPartTransforms_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetInstancerPartTransforms_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetInstancerPartTransforms_result)
GetInstancerPartTransforms_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetInstancerPartTransforms_Out, None], None, ),  # 0
)


class SetPartInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - part_info

    """


    def __init__(self, node_id=None, part_id=None, part_info=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.part_info = part_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.part_info = PartInfo()
                    self.part_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetPartInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.part_info is not None:
            oprot.writeFieldBegin('part_info', TType.STRUCT, 3)
            self.part_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetPartInfo_args)
SetPartInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRUCT, 'part_info', [PartInfo, None], None, ),  # 3
)


class SetPartInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetPartInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetPartInfo_result)
SetPartInfo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetFaceCounts_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - face_counts_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, face_counts_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.face_counts_array = face_counts_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.face_counts_array = []
                    (_etype542, _size539) = iprot.readListBegin()
                    for _i543 in range(_size539):
                        _elem544 = iprot.readI32()
                        self.face_counts_array.append(_elem544)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetFaceCounts_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.face_counts_array is not None:
            oprot.writeFieldBegin('face_counts_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.face_counts_array))
            for iter545 in self.face_counts_array:
                oprot.writeI32(iter545)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetFaceCounts_args)
SetFaceCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.LIST, 'face_counts_array', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
)


class SetFaceCounts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetFaceCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetFaceCounts_result)
SetFaceCounts_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetVertexList_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - vertex_list_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, vertex_list_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.vertex_list_array = vertex_list_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.vertex_list_array = []
                    (_etype549, _size546) = iprot.readListBegin()
                    for _i550 in range(_size546):
                        _elem551 = iprot.readI32()
                        self.vertex_list_array.append(_elem551)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVertexList_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.vertex_list_array is not None:
            oprot.writeFieldBegin('vertex_list_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.vertex_list_array))
            for iter552 in self.vertex_list_array:
                oprot.writeI32(iter552)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVertexList_args)
SetVertexList_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.LIST, 'vertex_list_array', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
)


class SetVertexList_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVertexList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVertexList_result)
SetVertexList_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class AddAttribute_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddAttribute_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AddAttribute_args)
AddAttribute_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
)


class AddAttribute_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddAttribute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AddAttribute_result)
AddAttribute_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class DeleteAttribute_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteAttribute_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteAttribute_args)
DeleteAttribute_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
)


class DeleteAttribute_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteAttribute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteAttribute_result)
DeleteAttribute_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetAttributeIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - data_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, data_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.data_array = data_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype556, _size553) = iprot.readListBegin()
                    for _i557 in range(_size553):
                        _elem558 = iprot.readI32()
                        self.data_array.append(_elem558)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.data_array))
            for iter559 in self.data_array:
                oprot.writeI32(iter559)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeIntData_args)
SetAttributeIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.LIST, 'data_array', (TType.I32, None, False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetAttributeIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeIntData_result)
SetAttributeIntData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetAttributeInt64Data_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - data_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, data_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.data_array = data_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype563, _size560) = iprot.readListBegin()
                    for _i564 in range(_size560):
                        _elem565 = iprot.readI64()
                        self.data_array.append(_elem565)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeInt64Data_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.data_array))
            for iter566 in self.data_array:
                oprot.writeI64(iter566)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeInt64Data_args)
SetAttributeInt64Data_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.LIST, 'data_array', (TType.I64, None, False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetAttributeInt64Data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeInt64Data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeInt64Data_result)
SetAttributeInt64Data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetAttributeFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - data_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, data_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.data_array = data_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype570, _size567) = iprot.readListBegin()
                    for _i571 in range(_size567):
                        _elem572 = iprot.readDouble()
                        self.data_array.append(_elem572)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.data_array))
            for iter573 in self.data_array:
                oprot.writeDouble(iter573)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeFloatData_args)
SetAttributeFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.LIST, 'data_array', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetAttributeFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeFloatData_result)
SetAttributeFloatData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetAttributeFloat64Data_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - data_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, data_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.data_array = data_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype577, _size574) = iprot.readListBegin()
                    for _i578 in range(_size574):
                        _elem579 = iprot.readDouble()
                        self.data_array.append(_elem579)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeFloat64Data_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.data_array))
            for iter580 in self.data_array:
                oprot.writeDouble(iter580)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeFloat64Data_args)
SetAttributeFloat64Data_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.LIST, 'data_array', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetAttributeFloat64Data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeFloat64Data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeFloat64Data_result)
SetAttributeFloat64Data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetAttributeStringData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - attr_info
     - data_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, attr_info=None, data_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.attr_info = attr_info
        self.data_array = data_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attr_info = AttributeInfo()
                    self.attr_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.data_array = []
                    (_etype584, _size581) = iprot.readListBegin()
                    for _i585 in range(_size581):
                        _elem586 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.data_array.append(_elem586)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeStringData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.attr_info is not None:
            oprot.writeFieldBegin('attr_info', TType.STRUCT, 4)
            self.attr_info.write(oprot)
            oprot.writeFieldEnd()
        if self.data_array is not None:
            oprot.writeFieldBegin('data_array', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.data_array))
            for iter587 in self.data_array:
                oprot.writeString(iter587.encode('utf-8') if sys.version_info[0] == 2 else iter587)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeStringData_args)
SetAttributeStringData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'attr_info', [AttributeInfo, None], None, ),  # 4
    (5, TType.LIST, 'data_array', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetAttributeStringData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAttributeStringData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAttributeStringData_result)
SetAttributeStringData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class AddGroup_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_name

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_name=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_name = group_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.group_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddGroup_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_name is not None:
            oprot.writeFieldBegin('group_name', TType.STRING, 4)
            oprot.writeString(self.group_name.encode('utf-8') if sys.version_info[0] == 2 else self.group_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AddGroup_args)
AddGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.STRING, 'group_name', 'UTF8', None, ),  # 4
)


class AddGroup_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AddGroup_result)
AddGroup_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class DeleteGroup_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_name

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_name=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_name = group_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.group_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteGroup_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_name is not None:
            oprot.writeFieldBegin('group_name', TType.STRING, 4)
            oprot.writeString(self.group_name.encode('utf-8') if sys.version_info[0] == 2 else self.group_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteGroup_args)
DeleteGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.STRING, 'group_name', 'UTF8', None, ),  # 4
)


class DeleteGroup_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteGroup_result)
DeleteGroup_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetGroupMembership_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - group_type
     - group_name
     - membership_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, group_type=None, group_name=None, membership_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.group_type = group_type
        self.group_name = group_name
        self.membership_array = membership_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.group_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.group_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.membership_array = []
                    (_etype591, _size588) = iprot.readListBegin()
                    for _i592 in range(_size588):
                        _elem593 = iprot.readI32()
                        self.membership_array.append(_elem593)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetGroupMembership_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.group_type is not None:
            oprot.writeFieldBegin('group_type', TType.I32, 3)
            oprot.writeI32(self.group_type)
            oprot.writeFieldEnd()
        if self.group_name is not None:
            oprot.writeFieldBegin('group_name', TType.STRING, 4)
            oprot.writeString(self.group_name.encode('utf-8') if sys.version_info[0] == 2 else self.group_name)
            oprot.writeFieldEnd()
        if self.membership_array is not None:
            oprot.writeFieldBegin('membership_array', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.membership_array))
            for iter594 in self.membership_array:
                oprot.writeI32(iter594)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 6)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetGroupMembership_args)
SetGroupMembership_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'group_type', None, None, ),  # 3
    (4, TType.STRING, 'group_name', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'membership_array', (TType.I32, None, False), None, ),  # 5
    (6, TType.I32, 'start', None, None, ),  # 6
)


class SetGroupMembership_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetGroupMembership_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetGroupMembership_result)
SetGroupMembership_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class CommitGeo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitGeo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CommitGeo_args)
CommitGeo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class CommitGeo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitGeo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CommitGeo_result)
CommitGeo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RevertGeo_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertGeo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertGeo_args)
RevertGeo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class RevertGeo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RevertGeo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RevertGeo_result)
RevertGeo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetMaterialNodeIdsOnFaces_args(object):
    """
    Attributes:
     - geometry_node_id
     - part_id
     - start
     - length

    """


    def __init__(self, geometry_node_id=None, part_id=None, start=None, length=None,):
        self.geometry_node_id = geometry_node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.geometry_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialNodeIdsOnFaces_args')
        if self.geometry_node_id is not None:
            oprot.writeFieldBegin('geometry_node_id', TType.I32, 1)
            oprot.writeI32(self.geometry_node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMaterialNodeIdsOnFaces_args)
GetMaterialNodeIdsOnFaces_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'geometry_node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetMaterialNodeIdsOnFaces_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetMaterialNodeIdsOnFaces_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialNodeIdsOnFaces_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMaterialNodeIdsOnFaces_result)
GetMaterialNodeIdsOnFaces_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetMaterialNodeIdsOnFaces_Out, None], None, ),  # 0
)


class GetMaterialInfo_args(object):
    """
    Attributes:
     - material_node_id

    """


    def __init__(self, material_node_id=None,):
        self.material_node_id = material_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialInfo_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMaterialInfo_args)
GetMaterialInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
)


class GetMaterialInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetMaterialInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMaterialInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMaterialInfo_result)
GetMaterialInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetMaterialInfo_Out, None], None, ),  # 0
)


class RenderCOPToImage_args(object):
    """
    Attributes:
     - cop_node_id

    """


    def __init__(self, cop_node_id=None,):
        self.cop_node_id = cop_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.cop_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderCOPToImage_args')
        if self.cop_node_id is not None:
            oprot.writeFieldBegin('cop_node_id', TType.I32, 1)
            oprot.writeI32(self.cop_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenderCOPToImage_args)
RenderCOPToImage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'cop_node_id', None, None, ),  # 1
)


class RenderCOPToImage_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderCOPToImage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenderCOPToImage_result)
RenderCOPToImage_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RenderTextureToImage_args(object):
    """
    Attributes:
     - material_node_id
     - parm_id

    """


    def __init__(self, material_node_id=None, parm_id=None,):
        self.material_node_id = material_node_id
        self.parm_id = parm_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderTextureToImage_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenderTextureToImage_args)
RenderTextureToImage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
)


class RenderTextureToImage_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RenderTextureToImage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RenderTextureToImage_result)
RenderTextureToImage_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetImageInfo_args(object):
    """
    Attributes:
     - material_node_id

    """


    def __init__(self, material_node_id=None,):
        self.material_node_id = material_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageInfo_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageInfo_args)
GetImageInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
)


class GetImageInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetImageInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageInfo_result)
GetImageInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetImageInfo_Out, None], None, ),  # 0
)


class SetImageInfo_args(object):
    """
    Attributes:
     - material_node_id
     - image_info

    """


    def __init__(self, material_node_id=None, image_info=None,):
        self.material_node_id = material_node_id
        self.image_info = image_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.image_info = ImageInfo()
                    self.image_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetImageInfo_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.image_info is not None:
            oprot.writeFieldBegin('image_info', TType.STRUCT, 2)
            self.image_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetImageInfo_args)
SetImageInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'image_info', [ImageInfo, None], None, ),  # 2
)


class SetImageInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetImageInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetImageInfo_result)
SetImageInfo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetImagePlaneCount_args(object):
    """
    Attributes:
     - material_node_id

    """


    def __init__(self, material_node_id=None,):
        self.material_node_id = material_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlaneCount_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImagePlaneCount_args)
GetImagePlaneCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
)


class GetImagePlaneCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetImagePlaneCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlaneCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImagePlaneCount_result)
GetImagePlaneCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetImagePlaneCount_Out, None], None, ),  # 0
)


class GetImagePlanes_args(object):
    """
    Attributes:
     - material_node_id
     - image_plane_count

    """


    def __init__(self, material_node_id=None, image_plane_count=None,):
        self.material_node_id = material_node_id
        self.image_plane_count = image_plane_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.image_plane_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlanes_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.image_plane_count is not None:
            oprot.writeFieldBegin('image_plane_count', TType.I32, 2)
            oprot.writeI32(self.image_plane_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImagePlanes_args)
GetImagePlanes_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.I32, 'image_plane_count', None, None, ),  # 2
)


class GetImagePlanes_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetImagePlanes_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImagePlanes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImagePlanes_result)
GetImagePlanes_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetImagePlanes_Out, None], None, ),  # 0
)


class ExtractImageToFile_args(object):
    """
    Attributes:
     - material_node_id
     - image_file_format_name
     - image_planes
     - destination_folder_path
     - destination_file_name

    """


    def __init__(self, material_node_id=None, image_file_format_name=None, image_planes=None, destination_folder_path=None, destination_file_name=None,):
        self.material_node_id = material_node_id
        self.image_file_format_name = image_file_format_name
        self.image_planes = image_planes
        self.destination_folder_path = destination_folder_path
        self.destination_file_name = destination_file_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_file_format_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.image_planes = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.destination_folder_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.destination_file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToFile_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.image_file_format_name is not None:
            oprot.writeFieldBegin('image_file_format_name', TType.STRING, 2)
            oprot.writeString(self.image_file_format_name.encode('utf-8') if sys.version_info[0] == 2 else self.image_file_format_name)
            oprot.writeFieldEnd()
        if self.image_planes is not None:
            oprot.writeFieldBegin('image_planes', TType.STRING, 3)
            oprot.writeString(self.image_planes.encode('utf-8') if sys.version_info[0] == 2 else self.image_planes)
            oprot.writeFieldEnd()
        if self.destination_folder_path is not None:
            oprot.writeFieldBegin('destination_folder_path', TType.STRING, 4)
            oprot.writeString(self.destination_folder_path.encode('utf-8') if sys.version_info[0] == 2 else self.destination_folder_path)
            oprot.writeFieldEnd()
        if self.destination_file_name is not None:
            oprot.writeFieldBegin('destination_file_name', TType.STRING, 5)
            oprot.writeString(self.destination_file_name.encode('utf-8') if sys.version_info[0] == 2 else self.destination_file_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExtractImageToFile_args)
ExtractImageToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.STRING, 'image_file_format_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'image_planes', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'destination_folder_path', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'destination_file_name', 'UTF8', None, ),  # 5
)


class ExtractImageToFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExtractImageToFile_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExtractImageToFile_result)
ExtractImageToFile_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ExtractImageToFile_Out, None], None, ),  # 0
)


class GetImageFilePath_args(object):
    """
    Attributes:
     - material_node_id
     - image_file_format_name
     - image_planes
     - destination_folder_path
     - destination_file_name
     - texture_parm_id

    """


    def __init__(self, material_node_id=None, image_file_format_name=None, image_planes=None, destination_folder_path=None, destination_file_name=None, texture_parm_id=None,):
        self.material_node_id = material_node_id
        self.image_file_format_name = image_file_format_name
        self.image_planes = image_planes
        self.destination_folder_path = destination_folder_path
        self.destination_file_name = destination_file_name
        self.texture_parm_id = texture_parm_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_file_format_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.image_planes = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.destination_folder_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.destination_file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.texture_parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageFilePath_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.image_file_format_name is not None:
            oprot.writeFieldBegin('image_file_format_name', TType.STRING, 2)
            oprot.writeString(self.image_file_format_name.encode('utf-8') if sys.version_info[0] == 2 else self.image_file_format_name)
            oprot.writeFieldEnd()
        if self.image_planes is not None:
            oprot.writeFieldBegin('image_planes', TType.STRING, 3)
            oprot.writeString(self.image_planes.encode('utf-8') if sys.version_info[0] == 2 else self.image_planes)
            oprot.writeFieldEnd()
        if self.destination_folder_path is not None:
            oprot.writeFieldBegin('destination_folder_path', TType.STRING, 4)
            oprot.writeString(self.destination_folder_path.encode('utf-8') if sys.version_info[0] == 2 else self.destination_folder_path)
            oprot.writeFieldEnd()
        if self.destination_file_name is not None:
            oprot.writeFieldBegin('destination_file_name', TType.STRING, 5)
            oprot.writeString(self.destination_file_name.encode('utf-8') if sys.version_info[0] == 2 else self.destination_file_name)
            oprot.writeFieldEnd()
        if self.texture_parm_id is not None:
            oprot.writeFieldBegin('texture_parm_id', TType.I32, 6)
            oprot.writeI32(self.texture_parm_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageFilePath_args)
GetImageFilePath_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.STRING, 'image_file_format_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'image_planes', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'destination_folder_path', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'destination_file_name', 'UTF8', None, ),  # 5
    (6, TType.I32, 'texture_parm_id', None, None, ),  # 6
)


class GetImageFilePath_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetImageFilePath_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageFilePath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageFilePath_result)
GetImageFilePath_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetImageFilePath_Out, None], None, ),  # 0
)


class ExtractImageToMemory_args(object):
    """
    Attributes:
     - material_node_id
     - image_file_format_name
     - image_planes

    """


    def __init__(self, material_node_id=None, image_file_format_name=None, image_planes=None,):
        self.material_node_id = material_node_id
        self.image_file_format_name = image_file_format_name
        self.image_planes = image_planes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_file_format_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.image_planes = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToMemory_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.image_file_format_name is not None:
            oprot.writeFieldBegin('image_file_format_name', TType.STRING, 2)
            oprot.writeString(self.image_file_format_name.encode('utf-8') if sys.version_info[0] == 2 else self.image_file_format_name)
            oprot.writeFieldEnd()
        if self.image_planes is not None:
            oprot.writeFieldBegin('image_planes', TType.STRING, 3)
            oprot.writeString(self.image_planes.encode('utf-8') if sys.version_info[0] == 2 else self.image_planes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExtractImageToMemory_args)
ExtractImageToMemory_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.STRING, 'image_file_format_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'image_planes', 'UTF8', None, ),  # 3
)


class ExtractImageToMemory_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExtractImageToMemory_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExtractImageToMemory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExtractImageToMemory_result)
ExtractImageToMemory_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ExtractImageToMemory_Out, None], None, ),  # 0
)


class GetImageMemoryBuffer_args(object):
    """
    Attributes:
     - material_node_id
     - length

    """


    def __init__(self, material_node_id=None, length=None,):
        self.material_node_id = material_node_id
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.material_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageMemoryBuffer_args')
        if self.material_node_id is not None:
            oprot.writeFieldBegin('material_node_id', TType.I32, 1)
            oprot.writeI32(self.material_node_id)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageMemoryBuffer_args)
GetImageMemoryBuffer_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'material_node_id', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetImageMemoryBuffer_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetImageMemoryBuffer_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetImageMemoryBuffer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetImageMemoryBuffer_result)
GetImageMemoryBuffer_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetImageMemoryBuffer_Out, None], None, ),  # 0
)


class GetSupportedImageFileFormatCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormatCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSupportedImageFileFormatCount_args)
GetSupportedImageFileFormatCount_args.thrift_spec = (
)


class GetSupportedImageFileFormatCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSupportedImageFileFormatCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormatCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSupportedImageFileFormatCount_result)
GetSupportedImageFileFormatCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetSupportedImageFileFormatCount_Out, None], None, ),  # 0
)


class GetSupportedImageFileFormats_args(object):
    """
    Attributes:
     - file_format_count

    """


    def __init__(self, file_format_count=None,):
        self.file_format_count = file_format_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.file_format_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormats_args')
        if self.file_format_count is not None:
            oprot.writeFieldBegin('file_format_count', TType.I32, 1)
            oprot.writeI32(self.file_format_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSupportedImageFileFormats_args)
GetSupportedImageFileFormats_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'file_format_count', None, None, ),  # 1
)


class GetSupportedImageFileFormats_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSupportedImageFileFormats_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSupportedImageFileFormats_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSupportedImageFileFormats_result)
GetSupportedImageFileFormats_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetSupportedImageFileFormats_Out, None], None, ),  # 0
)


class SetAnimCurve_args(object):
    """
    Attributes:
     - node_id
     - parm_id
     - parm_index
     - curve_keyframes_array

    """


    def __init__(self, node_id=None, parm_id=None, parm_index=None, curve_keyframes_array=None,):
        self.node_id = node_id
        self.parm_id = parm_id
        self.parm_index = parm_index
        self.curve_keyframes_array = curve_keyframes_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parm_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.parm_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.curve_keyframes_array = []
                    (_etype598, _size595) = iprot.readListBegin()
                    for _i599 in range(_size595):
                        _elem600 = Keyframe()
                        _elem600.read(iprot)
                        self.curve_keyframes_array.append(_elem600)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAnimCurve_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.parm_id is not None:
            oprot.writeFieldBegin('parm_id', TType.I32, 2)
            oprot.writeI32(self.parm_id)
            oprot.writeFieldEnd()
        if self.parm_index is not None:
            oprot.writeFieldBegin('parm_index', TType.I32, 3)
            oprot.writeI32(self.parm_index)
            oprot.writeFieldEnd()
        if self.curve_keyframes_array is not None:
            oprot.writeFieldBegin('curve_keyframes_array', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.curve_keyframes_array))
            for iter601 in self.curve_keyframes_array:
                iter601.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAnimCurve_args)
SetAnimCurve_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'parm_id', None, None, ),  # 2
    (3, TType.I32, 'parm_index', None, None, ),  # 3
    (4, TType.LIST, 'curve_keyframes_array', (TType.STRUCT, [Keyframe, None], False), None, ),  # 4
)


class SetAnimCurve_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetAnimCurve_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetAnimCurve_result)
SetAnimCurve_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetTransformAnimCurve_args(object):
    """
    Attributes:
     - node_id
     - trans_comp
     - curve_keyframes_array

    """


    def __init__(self, node_id=None, trans_comp=None, curve_keyframes_array=None,):
        self.node_id = node_id
        self.trans_comp = trans_comp
        self.curve_keyframes_array = curve_keyframes_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.trans_comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.curve_keyframes_array = []
                    (_etype605, _size602) = iprot.readListBegin()
                    for _i606 in range(_size602):
                        _elem607 = Keyframe()
                        _elem607.read(iprot)
                        self.curve_keyframes_array.append(_elem607)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTransformAnimCurve_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.trans_comp is not None:
            oprot.writeFieldBegin('trans_comp', TType.I32, 2)
            oprot.writeI32(self.trans_comp)
            oprot.writeFieldEnd()
        if self.curve_keyframes_array is not None:
            oprot.writeFieldBegin('curve_keyframes_array', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.curve_keyframes_array))
            for iter608 in self.curve_keyframes_array:
                iter608.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTransformAnimCurve_args)
SetTransformAnimCurve_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'trans_comp', None, None, ),  # 2
    (3, TType.LIST, 'curve_keyframes_array', (TType.STRUCT, [Keyframe, None], False), None, ),  # 3
)


class SetTransformAnimCurve_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetTransformAnimCurve_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetTransformAnimCurve_result)
SetTransformAnimCurve_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class ResetSimulation_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResetSimulation_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ResetSimulation_args)
ResetSimulation_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class ResetSimulation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResetSimulation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ResetSimulation_result)
ResetSimulation_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetVolumeInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeInfo_args)
GetVolumeInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetVolumeInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeInfo_result)
GetVolumeInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeInfo_Out, None], None, ),  # 0
)


class GetFirstVolumeTile_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFirstVolumeTile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFirstVolumeTile_args)
GetFirstVolumeTile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetFirstVolumeTile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFirstVolumeTile_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFirstVolumeTile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFirstVolumeTile_result)
GetFirstVolumeTile_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetFirstVolumeTile_Out, None], None, ),  # 0
)


class GetNextVolumeTile_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNextVolumeTile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNextVolumeTile_args)
GetNextVolumeTile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetNextVolumeTile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNextVolumeTile_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNextVolumeTile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNextVolumeTile_result)
GetNextVolumeTile_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNextVolumeTile_Out, None], None, ),  # 0
)


class GetVolumeVoxelFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - x_index
     - y_index
     - z_index
     - value_count

    """


    def __init__(self, node_id=None, part_id=None, x_index=None, y_index=None, z_index=None, value_count=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.x_index = x_index
        self.y_index = y_index
        self.z_index = z_index
        self.value_count = value_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.x_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.y_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.z_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.x_index is not None:
            oprot.writeFieldBegin('x_index', TType.I32, 3)
            oprot.writeI32(self.x_index)
            oprot.writeFieldEnd()
        if self.y_index is not None:
            oprot.writeFieldBegin('y_index', TType.I32, 4)
            oprot.writeI32(self.y_index)
            oprot.writeFieldEnd()
        if self.z_index is not None:
            oprot.writeFieldBegin('z_index', TType.I32, 5)
            oprot.writeI32(self.z_index)
            oprot.writeFieldEnd()
        if self.value_count is not None:
            oprot.writeFieldBegin('value_count', TType.I32, 6)
            oprot.writeI32(self.value_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeVoxelFloatData_args)
GetVolumeVoxelFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'x_index', None, None, ),  # 3
    (4, TType.I32, 'y_index', None, None, ),  # 4
    (5, TType.I32, 'z_index', None, None, ),  # 5
    (6, TType.I32, 'value_count', None, None, ),  # 6
)


class GetVolumeVoxelFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeVoxelFloatData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeVoxelFloatData_result)
GetVolumeVoxelFloatData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeVoxelFloatData_Out, None], None, ),  # 0
)


class GetVolumeTileFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - fill_value
     - tile
     - length

    """


    def __init__(self, node_id=None, part_id=None, fill_value=None, tile=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.fill_value = fill_value
        self.tile = tile
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.fill_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.fill_value is not None:
            oprot.writeFieldBegin('fill_value', TType.DOUBLE, 3)
            oprot.writeDouble(self.fill_value)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 4)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 5)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeTileFloatData_args)
GetVolumeTileFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.DOUBLE, 'fill_value', None, None, ),  # 3
    (4, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 4
    (5, TType.I32, 'length', None, None, ),  # 5
)


class GetVolumeTileFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeTileFloatData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeTileFloatData_result)
GetVolumeTileFloatData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeTileFloatData_Out, None], None, ),  # 0
)


class GetVolumeVoxelIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - x_index
     - y_index
     - z_index
     - value_count

    """


    def __init__(self, node_id=None, part_id=None, x_index=None, y_index=None, z_index=None, value_count=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.x_index = x_index
        self.y_index = y_index
        self.z_index = z_index
        self.value_count = value_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.x_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.y_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.z_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.value_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.x_index is not None:
            oprot.writeFieldBegin('x_index', TType.I32, 3)
            oprot.writeI32(self.x_index)
            oprot.writeFieldEnd()
        if self.y_index is not None:
            oprot.writeFieldBegin('y_index', TType.I32, 4)
            oprot.writeI32(self.y_index)
            oprot.writeFieldEnd()
        if self.z_index is not None:
            oprot.writeFieldBegin('z_index', TType.I32, 5)
            oprot.writeI32(self.z_index)
            oprot.writeFieldEnd()
        if self.value_count is not None:
            oprot.writeFieldBegin('value_count', TType.I32, 6)
            oprot.writeI32(self.value_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeVoxelIntData_args)
GetVolumeVoxelIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'x_index', None, None, ),  # 3
    (4, TType.I32, 'y_index', None, None, ),  # 4
    (5, TType.I32, 'z_index', None, None, ),  # 5
    (6, TType.I32, 'value_count', None, None, ),  # 6
)


class GetVolumeVoxelIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeVoxelIntData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeVoxelIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeVoxelIntData_result)
GetVolumeVoxelIntData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeVoxelIntData_Out, None], None, ),  # 0
)


class GetVolumeTileIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - fill_value
     - tile
     - length

    """


    def __init__(self, node_id=None, part_id=None, fill_value=None, tile=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.fill_value = fill_value
        self.tile = tile
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fill_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.fill_value is not None:
            oprot.writeFieldBegin('fill_value', TType.I32, 3)
            oprot.writeI32(self.fill_value)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 4)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 5)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeTileIntData_args)
GetVolumeTileIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'fill_value', None, None, ),  # 3
    (4, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 4
    (5, TType.I32, 'length', None, None, ),  # 5
)


class GetVolumeTileIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeTileIntData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeTileIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeTileIntData_result)
GetVolumeTileIntData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeTileIntData_Out, None], None, ),  # 0
)


class GetHeightFieldData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHeightFieldData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHeightFieldData_args)
GetHeightFieldData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetHeightFieldData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetHeightFieldData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHeightFieldData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHeightFieldData_result)
GetHeightFieldData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetHeightFieldData_Out, None], None, ),  # 0
)


class SetVolumeInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - volume_info

    """


    def __init__(self, node_id=None, part_id=None, volume_info=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.volume_info = volume_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.volume_info = VolumeInfo()
                    self.volume_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.volume_info is not None:
            oprot.writeFieldBegin('volume_info', TType.STRUCT, 3)
            self.volume_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeInfo_args)
SetVolumeInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRUCT, 'volume_info', [VolumeInfo, None], None, ),  # 3
)


class SetVolumeInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeInfo_result)
SetVolumeInfo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetVolumeTileFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - tile
     - values_array

    """


    def __init__(self, node_id=None, part_id=None, tile=None, values_array=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.tile = tile
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype612, _size609) = iprot.readListBegin()
                    for _i613 in range(_size609):
                        _elem614 = iprot.readDouble()
                        self.values_array.append(_elem614)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeTileFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 3)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter615 in self.values_array:
                oprot.writeDouble(iter615)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeTileFloatData_args)
SetVolumeTileFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 3
    (4, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 4
)


class SetVolumeTileFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeTileFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeTileFloatData_result)
SetVolumeTileFloatData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetVolumeTileIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - tile
     - values_array

    """


    def __init__(self, node_id=None, part_id=None, tile=None, values_array=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.tile = tile
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tile = VolumeTileInfo()
                    self.tile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype619, _size616) = iprot.readListBegin()
                    for _i620 in range(_size616):
                        _elem621 = iprot.readI32()
                        self.values_array.append(_elem621)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeTileIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.tile is not None:
            oprot.writeFieldBegin('tile', TType.STRUCT, 3)
            self.tile.write(oprot)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter622 in self.values_array:
                oprot.writeI32(iter622)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeTileIntData_args)
SetVolumeTileIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRUCT, 'tile', [VolumeTileInfo, None], None, ),  # 3
    (4, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 4
)


class SetVolumeTileIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeTileIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeTileIntData_result)
SetVolumeTileIntData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetVolumeVoxelFloatData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - x_index
     - y_index
     - z_index
     - values_array

    """


    def __init__(self, node_id=None, part_id=None, x_index=None, y_index=None, z_index=None, values_array=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.x_index = x_index
        self.y_index = y_index
        self.z_index = z_index
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.x_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.y_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.z_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype626, _size623) = iprot.readListBegin()
                    for _i627 in range(_size623):
                        _elem628 = iprot.readDouble()
                        self.values_array.append(_elem628)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeVoxelFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.x_index is not None:
            oprot.writeFieldBegin('x_index', TType.I32, 3)
            oprot.writeI32(self.x_index)
            oprot.writeFieldEnd()
        if self.y_index is not None:
            oprot.writeFieldBegin('y_index', TType.I32, 4)
            oprot.writeI32(self.y_index)
            oprot.writeFieldEnd()
        if self.z_index is not None:
            oprot.writeFieldBegin('z_index', TType.I32, 5)
            oprot.writeI32(self.z_index)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 6)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter629 in self.values_array:
                oprot.writeDouble(iter629)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeVoxelFloatData_args)
SetVolumeVoxelFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'x_index', None, None, ),  # 3
    (4, TType.I32, 'y_index', None, None, ),  # 4
    (5, TType.I32, 'z_index', None, None, ),  # 5
    (6, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 6
)


class SetVolumeVoxelFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeVoxelFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeVoxelFloatData_result)
SetVolumeVoxelFloatData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetVolumeVoxelIntData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - x_index
     - y_index
     - z_index
     - values_array

    """


    def __init__(self, node_id=None, part_id=None, x_index=None, y_index=None, z_index=None, values_array=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.x_index = x_index
        self.y_index = y_index
        self.z_index = z_index
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.x_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.y_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.z_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype633, _size630) = iprot.readListBegin()
                    for _i634 in range(_size630):
                        _elem635 = iprot.readI32()
                        self.values_array.append(_elem635)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeVoxelIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.x_index is not None:
            oprot.writeFieldBegin('x_index', TType.I32, 3)
            oprot.writeI32(self.x_index)
            oprot.writeFieldEnd()
        if self.y_index is not None:
            oprot.writeFieldBegin('y_index', TType.I32, 4)
            oprot.writeI32(self.y_index)
            oprot.writeFieldEnd()
        if self.z_index is not None:
            oprot.writeFieldBegin('z_index', TType.I32, 5)
            oprot.writeI32(self.z_index)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter636 in self.values_array:
                oprot.writeI32(iter636)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeVoxelIntData_args)
SetVolumeVoxelIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'x_index', None, None, ),  # 3
    (4, TType.I32, 'y_index', None, None, ),  # 4
    (5, TType.I32, 'z_index', None, None, ),  # 5
    (6, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 6
)


class SetVolumeVoxelIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetVolumeVoxelIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetVolumeVoxelIntData_result)
SetVolumeVoxelIntData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetVolumeBounds_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeBounds_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeBounds_args)
GetVolumeBounds_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetVolumeBounds_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetVolumeBounds_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetVolumeBounds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetVolumeBounds_result)
GetVolumeBounds_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetVolumeBounds_Out, None], None, ),  # 0
)


class SetHeightFieldData_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - name
     - values_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, name=None, values_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.name = name
        self.values_array = values_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype640, _size637) = iprot.readListBegin()
                    for _i641 in range(_size637):
                        _elem642 = iprot.readDouble()
                        self.values_array.append(_elem642)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetHeightFieldData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter643 in self.values_array:
                oprot.writeDouble(iter643)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 5)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetHeightFieldData_args)
SetHeightFieldData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.I32, 'start', None, None, ),  # 5
)


class SetHeightFieldData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetHeightFieldData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetHeightFieldData_result)
SetHeightFieldData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetCurveInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id

    """


    def __init__(self, node_id=None, part_id=None,):
        self.node_id = node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveInfo_args)
GetCurveInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetCurveInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCurveInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveInfo_result)
GetCurveInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCurveInfo_Out, None], None, ),  # 0
)


class GetCurveCounts_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveCounts_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveCounts_args)
GetCurveCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetCurveCounts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCurveCounts_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveCounts_result)
GetCurveCounts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCurveCounts_Out, None], None, ),  # 0
)


class GetCurveOrders_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveOrders_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveOrders_args)
GetCurveOrders_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetCurveOrders_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCurveOrders_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveOrders_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveOrders_result)
GetCurveOrders_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCurveOrders_Out, None], None, ),  # 0
)


class GetCurveKnots_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - start
     - length

    """


    def __init__(self, node_id=None, part_id=None, start=None, length=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.start = start
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveKnots_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveKnots_args)
GetCurveKnots_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetCurveKnots_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCurveKnots_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCurveKnots_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCurveKnots_result)
GetCurveKnots_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCurveKnots_Out, None], None, ),  # 0
)


class SetCurveInfo_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - info

    """


    def __init__(self, node_id=None, part_id=None, info=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.info = CurveInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 3)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveInfo_args)
SetCurveInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.STRUCT, 'info', [CurveInfo, None], None, ),  # 3
)


class SetCurveInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveInfo_result)
SetCurveInfo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetCurveCounts_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - counts_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, counts_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.counts_array = counts_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.counts_array = []
                    (_etype647, _size644) = iprot.readListBegin()
                    for _i648 in range(_size644):
                        _elem649 = iprot.readI32()
                        self.counts_array.append(_elem649)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveCounts_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.counts_array is not None:
            oprot.writeFieldBegin('counts_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.counts_array))
            for iter650 in self.counts_array:
                oprot.writeI32(iter650)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveCounts_args)
SetCurveCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.LIST, 'counts_array', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
)


class SetCurveCounts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveCounts_result)
SetCurveCounts_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetCurveOrders_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - orders_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, orders_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.orders_array = orders_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.orders_array = []
                    (_etype654, _size651) = iprot.readListBegin()
                    for _i655 in range(_size651):
                        _elem656 = iprot.readI32()
                        self.orders_array.append(_elem656)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveOrders_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.orders_array is not None:
            oprot.writeFieldBegin('orders_array', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.orders_array))
            for iter657 in self.orders_array:
                oprot.writeI32(iter657)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveOrders_args)
SetCurveOrders_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.LIST, 'orders_array', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
)


class SetCurveOrders_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveOrders_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveOrders_result)
SetCurveOrders_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetCurveKnots_args(object):
    """
    Attributes:
     - node_id
     - part_id
     - knots_array
     - start

    """


    def __init__(self, node_id=None, part_id=None, knots_array=None, start=None,):
        self.node_id = node_id
        self.part_id = part_id
        self.knots_array = knots_array
        self.start = start

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.knots_array = []
                    (_etype661, _size658) = iprot.readListBegin()
                    for _i662 in range(_size658):
                        _elem663 = iprot.readDouble()
                        self.knots_array.append(_elem663)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveKnots_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        if self.knots_array is not None:
            oprot.writeFieldBegin('knots_array', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.knots_array))
            for iter664 in self.knots_array:
                oprot.writeDouble(iter664)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 4)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveKnots_args)
SetCurveKnots_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
    (3, TType.LIST, 'knots_array', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.I32, 'start', None, None, ),  # 4
)


class SetCurveKnots_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCurveKnots_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCurveKnots_result)
SetCurveKnots_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetBoxInfo_args(object):
    """
    Attributes:
     - geo_node_id
     - part_id

    """


    def __init__(self, geo_node_id=None, part_id=None,):
        self.geo_node_id = geo_node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.geo_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBoxInfo_args')
        if self.geo_node_id is not None:
            oprot.writeFieldBegin('geo_node_id', TType.I32, 1)
            oprot.writeI32(self.geo_node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBoxInfo_args)
GetBoxInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'geo_node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetBoxInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetBoxInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBoxInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBoxInfo_result)
GetBoxInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetBoxInfo_Out, None], None, ),  # 0
)


class GetSphereInfo_args(object):
    """
    Attributes:
     - geo_node_id
     - part_id

    """


    def __init__(self, geo_node_id=None, part_id=None,):
        self.geo_node_id = geo_node_id
        self.part_id = part_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.geo_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSphereInfo_args')
        if self.geo_node_id is not None:
            oprot.writeFieldBegin('geo_node_id', TType.I32, 1)
            oprot.writeI32(self.geo_node_id)
            oprot.writeFieldEnd()
        if self.part_id is not None:
            oprot.writeFieldBegin('part_id', TType.I32, 2)
            oprot.writeI32(self.part_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSphereInfo_args)
GetSphereInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'geo_node_id', None, None, ),  # 1
    (2, TType.I32, 'part_id', None, None, ),  # 2
)


class GetSphereInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSphereInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSphereInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSphereInfo_result)
GetSphereInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetSphereInfo_Out, None], None, ),  # 0
)


class GetActiveCacheCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetActiveCacheCount_args)
GetActiveCacheCount_args.thrift_spec = (
)


class GetActiveCacheCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetActiveCacheCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetActiveCacheCount_result)
GetActiveCacheCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetActiveCacheCount_Out, None], None, ),  # 0
)


class GetActiveCacheNames_args(object):
    """
    Attributes:
     - active_cache_count

    """


    def __init__(self, active_cache_count=None,):
        self.active_cache_count = active_cache_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.active_cache_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheNames_args')
        if self.active_cache_count is not None:
            oprot.writeFieldBegin('active_cache_count', TType.I32, 1)
            oprot.writeI32(self.active_cache_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetActiveCacheNames_args)
GetActiveCacheNames_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'active_cache_count', None, None, ),  # 1
)


class GetActiveCacheNames_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetActiveCacheNames_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetActiveCacheNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetActiveCacheNames_result)
GetActiveCacheNames_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetActiveCacheNames_Out, None], None, ),  # 0
)


class GetCacheProperty_args(object):
    """
    Attributes:
     - cache_name
     - cache_property

    """


    def __init__(self, cache_name=None, cache_property=None,):
        self.cache_name = cache_name
        self.cache_property = cache_property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cache_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.cache_property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCacheProperty_args')
        if self.cache_name is not None:
            oprot.writeFieldBegin('cache_name', TType.STRING, 1)
            oprot.writeString(self.cache_name.encode('utf-8') if sys.version_info[0] == 2 else self.cache_name)
            oprot.writeFieldEnd()
        if self.cache_property is not None:
            oprot.writeFieldBegin('cache_property', TType.I32, 2)
            oprot.writeI32(self.cache_property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCacheProperty_args)
GetCacheProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cache_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'cache_property', None, None, ),  # 2
)


class GetCacheProperty_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetCacheProperty_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCacheProperty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetCacheProperty_result)
GetCacheProperty_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetCacheProperty_Out, None], None, ),  # 0
)


class SetCacheProperty_args(object):
    """
    Attributes:
     - cache_name
     - cache_property
     - property_value

    """


    def __init__(self, cache_name=None, cache_property=None, property_value=None,):
        self.cache_name = cache_name
        self.cache_property = cache_property
        self.property_value = property_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cache_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.cache_property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCacheProperty_args')
        if self.cache_name is not None:
            oprot.writeFieldBegin('cache_name', TType.STRING, 1)
            oprot.writeString(self.cache_name.encode('utf-8') if sys.version_info[0] == 2 else self.cache_name)
            oprot.writeFieldEnd()
        if self.cache_property is not None:
            oprot.writeFieldBegin('cache_property', TType.I32, 2)
            oprot.writeI32(self.cache_property)
            oprot.writeFieldEnd()
        if self.property_value is not None:
            oprot.writeFieldBegin('property_value', TType.I32, 3)
            oprot.writeI32(self.property_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCacheProperty_args)
SetCacheProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cache_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'cache_property', None, None, ),  # 2
    (3, TType.I32, 'property_value', None, None, ),  # 3
)


class SetCacheProperty_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCacheProperty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetCacheProperty_result)
SetCacheProperty_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SaveGeoToFile_args(object):
    """
    Attributes:
     - node_id
     - file_name

    """


    def __init__(self, node_id=None, file_name=None,):
        self.node_id = node_id
        self.file_name = file_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveGeoToFile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 2)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveGeoToFile_args)
SaveGeoToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'file_name', 'UTF8', None, ),  # 2
)


class SaveGeoToFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveGeoToFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveGeoToFile_result)
SaveGeoToFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class LoadGeoFromFile_args(object):
    """
    Attributes:
     - node_id
     - file_name

    """


    def __init__(self, node_id=None, file_name=None,):
        self.node_id = node_id
        self.file_name = file_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadGeoFromFile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 2)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadGeoFromFile_args)
LoadGeoFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'file_name', 'UTF8', None, ),  # 2
)


class LoadGeoFromFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadGeoFromFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadGeoFromFile_result)
LoadGeoFromFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SaveNodeToFile_args(object):
    """
    Attributes:
     - node_id
     - file_name

    """


    def __init__(self, node_id=None, file_name=None,):
        self.node_id = node_id
        self.file_name = file_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveNodeToFile_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 2)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveNodeToFile_args)
SaveNodeToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'file_name', 'UTF8', None, ),  # 2
)


class SaveNodeToFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveNodeToFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveNodeToFile_result)
SaveNodeToFile_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class LoadNodeFromFile_args(object):
    """
    Attributes:
     - file_name
     - parent_node_id
     - node_label
     - cook_on_load

    """


    def __init__(self, file_name=None, parent_node_id=None, node_label=None, cook_on_load=None,):
        self.file_name = file_name
        self.parent_node_id = parent_node_id
        self.node_label = node_label
        self.cook_on_load = cook_on_load

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parent_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.node_label = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.cook_on_load = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadNodeFromFile_args')
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 1)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.parent_node_id is not None:
            oprot.writeFieldBegin('parent_node_id', TType.I32, 2)
            oprot.writeI32(self.parent_node_id)
            oprot.writeFieldEnd()
        if self.node_label is not None:
            oprot.writeFieldBegin('node_label', TType.STRING, 3)
            oprot.writeString(self.node_label.encode('utf-8') if sys.version_info[0] == 2 else self.node_label)
            oprot.writeFieldEnd()
        if self.cook_on_load is not None:
            oprot.writeFieldBegin('cook_on_load', TType.BOOL, 4)
            oprot.writeBool(self.cook_on_load)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadNodeFromFile_args)
LoadNodeFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'parent_node_id', None, None, ),  # 2
    (3, TType.STRING, 'node_label', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'cook_on_load', None, None, ),  # 4
)


class LoadNodeFromFile_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LoadNodeFromFile_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadNodeFromFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadNodeFromFile_result)
LoadNodeFromFile_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LoadNodeFromFile_Out, None], None, ),  # 0
)


class GetGeoSize_args(object):
    """
    Attributes:
     - node_id
     - format

    """


    def __init__(self, node_id=None, format=None,):
        self.node_id = node_id
        self.format = format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoSize_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 2)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGeoSize_args)
GetGeoSize_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'format', 'UTF8', None, ),  # 2
)


class GetGeoSize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGeoSize_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGeoSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGeoSize_result)
GetGeoSize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetGeoSize_Out, None], None, ),  # 0
)


class SaveGeoToMemory_args(object):
    """
    Attributes:
     - node_id
     - length

    """


    def __init__(self, node_id=None, length=None,):
        self.node_id = node_id
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveGeoToMemory_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveGeoToMemory_args)
SaveGeoToMemory_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class SaveGeoToMemory_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SaveGeoToMemory_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveGeoToMemory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SaveGeoToMemory_result)
SaveGeoToMemory_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SaveGeoToMemory_Out, None], None, ),  # 0
)


class LoadGeoFromMemory_args(object):
    """
    Attributes:
     - node_id
     - format
     - buffer
     - length

    """


    def __init__(self, node_id=None, format=None, buffer=None, length=None,):
        self.node_id = node_id
        self.format = format
        self.buffer = buffer
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadGeoFromMemory_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 2)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 3)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadGeoFromMemory_args)
LoadGeoFromMemory_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'format', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'buffer', 'BINARY', None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class LoadGeoFromMemory_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadGeoFromMemory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadGeoFromMemory_result)
LoadGeoFromMemory_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetNodeDisplay_args(object):
    """
    Attributes:
     - node_id
     - onOff

    """


    def __init__(self, node_id=None, onOff=None,):
        self.node_id = node_id
        self.onOff = onOff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.onOff = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetNodeDisplay_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.onOff is not None:
            oprot.writeFieldBegin('onOff', TType.I32, 2)
            oprot.writeI32(self.onOff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetNodeDisplay_args)
SetNodeDisplay_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'onOff', None, None, ),  # 2
)


class SetNodeDisplay_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetNodeDisplay_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetNodeDisplay_result)
SetNodeDisplay_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetTotalCookCount_args(object):
    """
    Attributes:
     - node_id
     - node_type_filter
     - node_flags_filter
     - recursive

    """


    def __init__(self, node_id=None, node_type_filter=None, node_flags_filter=None, recursive=None,):
        self.node_id = node_id
        self.node_type_filter = node_type_filter
        self.node_flags_filter = node_flags_filter
        self.recursive = recursive

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_type_filter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_flags_filter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.recursive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTotalCookCount_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.node_type_filter is not None:
            oprot.writeFieldBegin('node_type_filter', TType.I32, 2)
            oprot.writeI32(self.node_type_filter)
            oprot.writeFieldEnd()
        if self.node_flags_filter is not None:
            oprot.writeFieldBegin('node_flags_filter', TType.I32, 3)
            oprot.writeI32(self.node_flags_filter)
            oprot.writeFieldEnd()
        if self.recursive is not None:
            oprot.writeFieldBegin('recursive', TType.BOOL, 4)
            oprot.writeBool(self.recursive)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTotalCookCount_args)
GetTotalCookCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'node_type_filter', None, None, ),  # 2
    (3, TType.I32, 'node_flags_filter', None, None, ),  # 3
    (4, TType.BOOL, 'recursive', None, None, ),  # 4
)


class GetTotalCookCount_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTotalCookCount_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTotalCookCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetTotalCookCount_result)
GetTotalCookCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetTotalCookCount_Out, None], None, ),  # 0
)


class SetSessionSync_args(object):
    """
    Attributes:
     - enable

    """


    def __init__(self, enable=None,):
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSessionSync_args')
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 1)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSessionSync_args)
SetSessionSync_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enable', None, None, ),  # 1
)


class SetSessionSync_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSessionSync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSessionSync_result)
SetSessionSync_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetViewport_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetViewport_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetViewport_args)
GetViewport_args.thrift_spec = (
)


class GetViewport_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetViewport_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetViewport_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetViewport_result)
GetViewport_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetViewport_Out, None], None, ),  # 0
)


class SetViewport_args(object):
    """
    Attributes:
     - viewport

    """


    def __init__(self, viewport=None,):
        self.viewport = viewport

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.viewport = Viewport()
                    self.viewport.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetViewport_args')
        if self.viewport is not None:
            oprot.writeFieldBegin('viewport', TType.STRUCT, 1)
            self.viewport.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetViewport_args)
SetViewport_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'viewport', [Viewport, None], None, ),  # 1
)


class SetViewport_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetViewport_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetViewport_result)
SetViewport_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetSessionSyncInfo_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionSyncInfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSessionSyncInfo_args)
GetSessionSyncInfo_args.thrift_spec = (
)


class GetSessionSyncInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetSessionSyncInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSessionSyncInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSessionSyncInfo_result)
GetSessionSyncInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetSessionSyncInfo_Out, None], None, ),  # 0
)


class SetSessionSyncInfo_args(object):
    """
    Attributes:
     - session_sync_info

    """


    def __init__(self, session_sync_info=None,):
        self.session_sync_info = session_sync_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.session_sync_info = SessionSyncInfo()
                    self.session_sync_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSessionSyncInfo_args')
        if self.session_sync_info is not None:
            oprot.writeFieldBegin('session_sync_info', TType.STRUCT, 1)
            self.session_sync_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSessionSyncInfo_args)
SetSessionSyncInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'session_sync_info', [SessionSyncInfo, None], None, ),  # 1
)


class SetSessionSyncInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSessionSyncInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSessionSyncInfo_result)
SetSessionSyncInfo_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetPDGGraphContexts_args(object):
    """
    Attributes:
     - count

    """


    def __init__(self, count=None,):
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContexts_args')
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 1)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGGraphContexts_args)
GetPDGGraphContexts_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'count', None, None, ),  # 1
)


class GetPDGGraphContexts_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPDGGraphContexts_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContexts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGGraphContexts_result)
GetPDGGraphContexts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPDGGraphContexts_Out, None], None, ),  # 0
)


class GetPDGGraphContextId_args(object):
    """
    Attributes:
     - top_node_id

    """


    def __init__(self, top_node_id=None,):
        self.top_node_id = top_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.top_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContextId_args')
        if self.top_node_id is not None:
            oprot.writeFieldBegin('top_node_id', TType.I32, 1)
            oprot.writeI32(self.top_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGGraphContextId_args)
GetPDGGraphContextId_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'top_node_id', None, None, ),  # 1
)


class GetPDGGraphContextId_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPDGGraphContextId_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGGraphContextId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGGraphContextId_result)
GetPDGGraphContextId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPDGGraphContextId_Out, None], None, ),  # 0
)


class CookPDG_args(object):
    """
    Attributes:
     - cook_node_id
     - generate_only
     - blocking

    """


    def __init__(self, cook_node_id=None, generate_only=None, blocking=None,):
        self.cook_node_id = cook_node_id
        self.generate_only = generate_only
        self.blocking = blocking

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.cook_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.generate_only = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.blocking = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CookPDG_args')
        if self.cook_node_id is not None:
            oprot.writeFieldBegin('cook_node_id', TType.I32, 1)
            oprot.writeI32(self.cook_node_id)
            oprot.writeFieldEnd()
        if self.generate_only is not None:
            oprot.writeFieldBegin('generate_only', TType.I32, 2)
            oprot.writeI32(self.generate_only)
            oprot.writeFieldEnd()
        if self.blocking is not None:
            oprot.writeFieldBegin('blocking', TType.I32, 3)
            oprot.writeI32(self.blocking)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CookPDG_args)
CookPDG_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'cook_node_id', None, None, ),  # 1
    (2, TType.I32, 'generate_only', None, None, ),  # 2
    (3, TType.I32, 'blocking', None, None, ),  # 3
)


class CookPDG_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CookPDG_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CookPDG_result)
CookPDG_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetPDGEvents_args(object):
    """
    Attributes:
     - graph_context_id
     - length

    """


    def __init__(self, graph_context_id=None, length=None,):
        self.graph_context_id = graph_context_id
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.graph_context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGEvents_args')
        if self.graph_context_id is not None:
            oprot.writeFieldBegin('graph_context_id', TType.I32, 1)
            oprot.writeI32(self.graph_context_id)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGEvents_args)
GetPDGEvents_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'graph_context_id', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetPDGEvents_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPDGEvents_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGEvents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGEvents_result)
GetPDGEvents_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPDGEvents_Out, None], None, ),  # 0
)


class GetPDGState_args(object):
    """
    Attributes:
     - graph_context_id

    """


    def __init__(self, graph_context_id=None,):
        self.graph_context_id = graph_context_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.graph_context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGState_args')
        if self.graph_context_id is not None:
            oprot.writeFieldBegin('graph_context_id', TType.I32, 1)
            oprot.writeI32(self.graph_context_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGState_args)
GetPDGState_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'graph_context_id', None, None, ),  # 1
)


class GetPDGState_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPDGState_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPDGState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPDGState_result)
GetPDGState_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPDGState_Out, None], None, ),  # 0
)


class CreateWorkitem_args(object):
    """
    Attributes:
     - node_id
     - name
     - index

    """


    def __init__(self, node_id=None, name=None, index=None,):
        self.node_id = node_id
        self.name = name
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateWorkitem_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateWorkitem_args)
CreateWorkitem_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class CreateWorkitem_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateWorkitem_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateWorkitem_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateWorkitem_result)
CreateWorkitem_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateWorkitem_Out, None], None, ),  # 0
)


class GetWorkitemInfo_args(object):
    """
    Attributes:
     - graph_context_id
     - workitem_id

    """


    def __init__(self, graph_context_id=None, workitem_id=None,):
        self.graph_context_id = graph_context_id
        self.workitem_id = workitem_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.graph_context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemInfo_args')
        if self.graph_context_id is not None:
            oprot.writeFieldBegin('graph_context_id', TType.I32, 1)
            oprot.writeI32(self.graph_context_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemInfo_args)
GetWorkitemInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'graph_context_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
)


class GetWorkitemInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemInfo_result)
GetWorkitemInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemInfo_Out, None], None, ),  # 0
)


class SetWorkitemIntData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - values_array

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, values_array=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype668, _size665) = iprot.readListBegin()
                    for _i669 in range(_size665):
                        _elem670 = iprot.readI32()
                        self.values_array.append(_elem670)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.values_array))
            for iter671 in self.values_array:
                oprot.writeI32(iter671)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemIntData_args)
SetWorkitemIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'values_array', (TType.I32, None, False), None, ),  # 4
)


class SetWorkitemIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemIntData_result)
SetWorkitemIntData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetWorkitemFloatData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - values_array

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, values_array=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.values_array = values_array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values_array = []
                    (_etype675, _size672) = iprot.readListBegin()
                    for _i676 in range(_size672):
                        _elem677 = iprot.readDouble()
                        self.values_array.append(_elem677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.values_array is not None:
            oprot.writeFieldBegin('values_array', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.values_array))
            for iter678 in self.values_array:
                oprot.writeDouble(iter678)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemFloatData_args)
SetWorkitemFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'values_array', (TType.DOUBLE, None, False), None, ),  # 4
)


class SetWorkitemFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemFloatData_result)
SetWorkitemFloatData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SetWorkitemStringData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - data_index
     - value

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, data_index=None, value=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.data_index = data_index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.data_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemStringData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.data_index is not None:
            oprot.writeFieldBegin('data_index', TType.I32, 4)
            oprot.writeI32(self.data_index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 5)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemStringData_args)
SetWorkitemStringData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'data_index', None, None, ),  # 4
    (5, TType.STRING, 'value', 'UTF8', None, ),  # 5
)


class SetWorkitemStringData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetWorkitemStringData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetWorkitemStringData_result)
SetWorkitemStringData_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class CommitWorkitems_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitWorkitems_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CommitWorkitems_args)
CommitWorkitems_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class CommitWorkitems_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitWorkitems_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CommitWorkitems_result)
CommitWorkitems_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetNumWorkitems_args(object):
    """
    Attributes:
     - node_id

    """


    def __init__(self, node_id=None,):
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNumWorkitems_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNumWorkitems_args)
GetNumWorkitems_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
)


class GetNumWorkitems_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetNumWorkitems_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNumWorkitems_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNumWorkitems_result)
GetNumWorkitems_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetNumWorkitems_Out, None], None, ),  # 0
)


class GetWorkitems_args(object):
    """
    Attributes:
     - node_id
     - length

    """


    def __init__(self, node_id=None, length=None,):
        self.node_id = node_id
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitems_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitems_args)
GetWorkitems_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
)


class GetWorkitems_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitems_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitems_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitems_result)
GetWorkitems_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitems_Out, None], None, ),  # 0
)


class GetWorkitemDataLength_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemDataLength_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemDataLength_args)
GetWorkitemDataLength_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
)


class GetWorkitemDataLength_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemDataLength_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemDataLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemDataLength_result)
GetWorkitemDataLength_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemDataLength_Out, None], None, ),  # 0
)


class GetWorkitemIntData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - length

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, length=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemIntData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemIntData_args)
GetWorkitemIntData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetWorkitemIntData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemIntData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemIntData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemIntData_result)
GetWorkitemIntData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemIntData_Out, None], None, ),  # 0
)


class GetWorkitemFloatData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - length

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, length=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemFloatData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemFloatData_args)
GetWorkitemFloatData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetWorkitemFloatData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemFloatData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemFloatData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemFloatData_result)
GetWorkitemFloatData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemFloatData_Out, None], None, ),  # 0
)


class GetWorkitemStringData_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - data_name
     - length

    """


    def __init__(self, node_id=None, workitem_id=None, data_name=None, length=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.data_name = data_name
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemStringData_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.data_name is not None:
            oprot.writeFieldBegin('data_name', TType.STRING, 3)
            oprot.writeString(self.data_name.encode('utf-8') if sys.version_info[0] == 2 else self.data_name)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 4)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemStringData_args)
GetWorkitemStringData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.STRING, 'data_name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'length', None, None, ),  # 4
)


class GetWorkitemStringData_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemStringData_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemStringData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemStringData_result)
GetWorkitemStringData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemStringData_Out, None], None, ),  # 0
)


class GetWorkitemResultInfo_args(object):
    """
    Attributes:
     - node_id
     - workitem_id
     - resultinfo_count

    """


    def __init__(self, node_id=None, workitem_id=None, resultinfo_count=None,):
        self.node_id = node_id
        self.workitem_id = workitem_id
        self.resultinfo_count = resultinfo_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.workitem_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.resultinfo_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemResultInfo_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.workitem_id is not None:
            oprot.writeFieldBegin('workitem_id', TType.I32, 2)
            oprot.writeI32(self.workitem_id)
            oprot.writeFieldEnd()
        if self.resultinfo_count is not None:
            oprot.writeFieldBegin('resultinfo_count', TType.I32, 3)
            oprot.writeI32(self.resultinfo_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemResultInfo_args)
GetWorkitemResultInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'workitem_id', None, None, ),  # 2
    (3, TType.I32, 'resultinfo_count', None, None, ),  # 3
)


class GetWorkitemResultInfo_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetWorkitemResultInfo_Out()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetWorkitemResultInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetWorkitemResultInfo_result)
GetWorkitemResultInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetWorkitemResultInfo_Out, None], None, ),  # 0
)


class DirtyPDGNode_args(object):
    """
    Attributes:
     - node_id
     - clean_results

    """


    def __init__(self, node_id=None, clean_results=None,):
        self.node_id = node_id
        self.clean_results = clean_results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.clean_results = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DirtyPDGNode_args')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.clean_results is not None:
            oprot.writeFieldBegin('clean_results', TType.BOOL, 2)
            oprot.writeBool(self.clean_results)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DirtyPDGNode_args)
DirtyPDGNode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.BOOL, 'clean_results', None, None, ),  # 2
)


class DirtyPDGNode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DirtyPDGNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DirtyPDGNode_result)
DirtyPDGNode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class PausePDGCook_args(object):
    """
    Attributes:
     - graph_context_id

    """


    def __init__(self, graph_context_id=None,):
        self.graph_context_id = graph_context_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.graph_context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PausePDGCook_args')
        if self.graph_context_id is not None:
            oprot.writeFieldBegin('graph_context_id', TType.I32, 1)
            oprot.writeI32(self.graph_context_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PausePDGCook_args)
PausePDGCook_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'graph_context_id', None, None, ),  # 1
)


class PausePDGCook_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PausePDGCook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PausePDGCook_result)
PausePDGCook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class CancelPDGCook_args(object):
    """
    Attributes:
     - graph_context_id

    """


    def __init__(self, graph_context_id=None,):
        self.graph_context_id = graph_context_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.graph_context_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelPDGCook_args')
        if self.graph_context_id is not None:
            oprot.writeFieldBegin('graph_context_id', TType.I32, 1)
            oprot.writeI32(self.graph_context_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CancelPDGCook_args)
CancelPDGCook_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'graph_context_id', None, None, ),  # 1
)


class CancelPDGCook_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CancelPDGCook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CancelPDGCook_result)
CancelPDGCook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

